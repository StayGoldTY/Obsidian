单元测试是测试一个或者多个函数和接口，当这个函数和接口与其他函数、接口有合作关系的时候，就需要测试替身了。
测试替身包括
+ 桩对象(Stub Object)、
+ 伪造对象(Fake Object)、
+ 间谍对象(Spy Object)、
+ 模拟对象(Mock Object)
+ 哑元对象(Dummy Object)。
● 桩对象：桩对象提供在测试过程中对请求调用的屏蔽式应答，通常对该测试程序之外的任何内容无响应，即桩对象只是返回一个给定的值，不会涉及系统的任何改变。它通常是测试中的控制点。
● 伪造对象：伪造对象是模拟被测系统所依赖的组件，是生产环境下被依赖组件功能实现的简化版本。伪造对象用于测试，但它既不是测试中的控制点，也不是观测点。
● 间谍对象：间谍对象可以被看作是一类桩对象，但是会记录它在被调用后的一些信息。
● 模拟对象：模拟对象通常会被作为观察点，用于验证被测系统(SUT)执行时的间接输出（即观测点）。通常，模拟对象还会发挥桩对象的作用，因为如果测试尚未失败，它必须将值返回被测系统，但其重点是验证间接输出。一个模拟对象不仅仅是一个桩对象和断言，它们的使用方式也有着根本的不同。因此，它既可以是观察点，也可以是控制点。
● 哑元对象：哑元对象在测试中仅起到占位填充符的作用，在测试中不会被使用，也不参与测试行为或状态的验证。常见的场景是，其作为被测函数的某个参数占位符，以减少参数的构造成本。

**4.6.1 桩对象**
桩对象是通过硬编码的方式来实现的。其已在第1.1节介绍过，在这里不再详细介绍。

**4.6.2 伪造对象**
顾名思义，伪造对象就是假货。与桩对象相比，伪造对象技术是一种比较复杂的替身技术。下面我们通过一个案例来进行描述。创建文件Address.java：
![[Pasted image 20240408111543.png]]
AddressRepositor.java：
![[Pasted image 20240408111607.png]]
AddressRepositor.java是一个接口，准备通过数据库进行查询，但是现在数据库还没有创建好，这时可以先通过Address类把数据放在内存中（其实即使数据库已经建好，也是先把查询的数据放在Address类中），然后通过内存中的数据进行查询。首先，写FakeAddressRepositor类来实现AddressRepositor：
![[Pasted image 20240408111657.png]]然后，通过测试代码AddressTest.java测试FakeAddressRepositor.java：
![[Pasted image 20240408113055.png]]
![[Pasted image 20240408113142.png]]
第6行：定义AddressRepositor为FakeAddressRepositor类的变量。
第7、8、9行：定义Address类的3个变量。
第23行：测试通过“ID”寻找对应的Address类。
第33行：测试通过地址名寻找对应的Address类。
第43行：测试通过电话号码寻找对应的Address类。

**4.6.3 间谍对象**
对于没有返回值的方法，可以使用间谍对象技术来实现。在《有效的单元测试》一书中有这样一个例子。被测对象DLog.java：
![[Pasted image 20240408113245.png]]