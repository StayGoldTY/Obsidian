动态自动化单元测试动态自动化单元测试是指利用单元自动化测试框架，如CUnit、JUnit、TestNG、unittest、Pytest等编写测试脚本，对被测代码进行测试的行为（CUnit、JUnit、TestNG、unittest和Pytest在本书第3、4、5章进行详细介绍）。
**在动态自动化单元测试中，测试覆盖率是衡量测试用例好坏的一个重要指标，覆盖的种类包括
+ 语句覆盖、
+ 分支覆盖、
+ 条件覆盖、
+ 条件/分支覆盖、
+ MC/DC（Modified Condition/Decision Coverage，修改条件/判断覆盖）、
+ 路径覆盖
+ 控制流覆盖。
下面将对这些覆盖进行详细介绍。
### 被测程序被测程序如图2-1所示。
![[Pasted image 20240408085842.png]]
两个判断语句：C1和C2。
三个普通语句：M1、M2和M3。
八个条件：T1、F1、T2、F2、T3、F3、T4和F4。
四条路径：L1：ace；L2：bce；L3：ade和L4：bde。

### 1.语句覆盖
语句覆盖又叫作行覆盖、段覆盖和基本块覆盖，是最常用的一种覆盖方式，度量被测代码中每个可执行语句是否被执行到。这里说的是“可执行语句”，因此不包括C++的头文件声明、代码注释、空行等。语句覆盖率的公式如下：语句覆盖率=被执行到的语句数量/可执行的语句总数×100%下面来看看各种情况下的语句覆盖。
**1.顺序语句顺序语句**
中的语句覆盖率最简单，只要把其每条语句都覆盖到即可。针对下列代码：
![[Pasted image 20240408090031.png]]
语句覆盖率为100%的测试用例为f(1，2)。


**2.没有else的判断语句**
在没有else的判断语句中，只要执行if语句中的内容就可以了。针对下列代码：
![[Pasted image 20240408090718.png]]语句覆盖率为100%的测试用例为f(1)。

```
这里有一个关键点就是语句覆盖率是只需要覆盖每条语句而不是代码里面的每种情况.
所以上面的f(1)已经可以确保每条语句都执行了
```

**3.有else的判断语句**
在有else的判断语句中，既要执行if语句，也要执行else中的语句。针对下列代码：
![[Pasted image 20240408091048.png]]
语句覆盖率为100%的测试用例为f(1)（执行了b=1语句）和f(0)（执行了b=2语句）。

**4.循环语句**
在循环语句中，循环体内的语句必须有且有一次被运行。针对下列代码：
![[Pasted image 20240408091116.png]]
语句覆盖率为100%的测试用例为f(0)。在这里需要特别强调的是，测试用例在循环体内的语句最好有且只有一次被运行。这是因为循环体内的语句可能很长，如果让它执行两次、10次，甚至更多次，单元测试的时间就会变得很长，而且意义不大。另外，单元测试的快速性原则也要求一个单元测试用例最好在几毫秒到几十毫秒内执行完毕。

**5.多条件语句在多条件语句中，每个分支语句必须被执行一次。针对下列代码：
![[Pasted image 20240408091146.png]]语句覆盖率为100%的测试用例为f(1)、f(2)、f(3)和f(4)。

**6.被测程序分析**
假设x=2、a=2、b=0，则  
● 当通过C1进行判断时，(a＞1)&&(b== 0)代入数字(2＞1)&&(0== 0)可以推出(True&&True)，即True，执行b分支和M1语句，x=x/a代入数字得x=2/2，即x=1。  
● 当通过C2进行判断时，(a ==  2)||(x＞1)代入数字(2== 2)||(1＞1)可以推出(True||False)，即True，执行d分支和M2语句，x=x+1代入数字得x=1+1，即x=2。  
● 最后执行M3语句，返回x=2。如表2-1所示。
表2-1 语句覆盖测试用例
![[Pasted image 20240408091500.png]]由此可见，只需要设计一个测试用例就可以使语句覆盖率达到100%。

**7.语句覆盖的脆弱性**
语句覆盖常常被认为是“最弱的覆盖”，因为它只负责覆盖代码中的执行语句，却不考虑各种分支的组合等。如果只要求达到语句覆盖，测试效果则的确不明显，很难发现代码中更多的问题，如下面的被测代码：
![[Pasted image 20240408091717.png]]
测试用例：a=10，b=5。测试结果显示，代码覆盖率达到了100%，并且所有软件测试用例都通过了。然而遗憾的是，测试却没有发现最简单的Bug，如当b=0时，会抛出一个除以零的异常

***
#### 语句覆盖基本上在单元测试中不会采用，因为就算是百分百的语句覆盖测试的结果也很不稳定
***

### 2.分支覆盖

**分支覆盖**
又称为判定覆盖，就是通过设计若干测试用例运行被测程序，使得程序中每个判断的取真分支和取假分支各被执行一次。分支覆盖率的公式如下：分支覆盖率=被执行的分支数量/所有的分支数量×100%下面介绍各种情况下的分支覆盖。
**1.没有else的判断语句**
在没有else的判断语句中，既要执行if语句为Ture的情况，也要执行if语句为False的情况，这是分支覆盖与语句覆盖不同的地方。针对下列代码：
![[Pasted image 20240408090031.png]]
分支覆盖率为100%的测试用例为f(1)和f(0)。

**2.有else的判断语句**
在有else的判断语句中，同没有else的判断语句一样，既要执行if中的语句，也要执行else中的语句。针对下列代码：
![[Pasted image 20240408091048.png]]分支覆盖率为100%的测试用例为f(1)和f(0)。

**3.循环语句**
在循环语句中，循环体内的语句必须有且有一次被运行。针对下列代码：
![[Pasted image 20240408091116.png]]
语句覆盖率为100%的测试用例为f(0)。

**4.多条件语句**
在多条件语句中，每个分支语句必须被执行一次，另外多条件语句还包括所有用例没有被覆盖到的一种情形。针对下列代码：
![[Pasted image 20240408091146.png]]
分支覆盖率为100%的测试用例为f(1)、f(2)、f(3)、f(4)和f(5)［不要遗漏f(5)］。（**这个地方很重要，需要考虑到每个分支，所以一定需要f(5)**）

**5.被测程序分析**
假设x=2、a=2、b=0，则
● 当通过C1进行判断时，(a＞1)&&(b== 0)代入数字(2＞1)&&(0== 0)可以推出(True&&True)，即为True，执行b分支和M1语句，x=x/a代入数字得x=2/2，即x=1。
● 当通过C2进行判断时，(a== 2)||(x＞1)代入数字(2== 2)||(1＞1)可以推出(True||False)，即为True，执行d分支和M2语句，x=x+1代入数字得x=2。
● 最后执行M3语句，返回x=2。假设x=1、a=1、b=1，则
● 当通过C1进行判断时，(a＞1)&&(b== 0)代入数字(1＞1)&&(1== 0)可以推出(False&&False)，即为False，执行a分支，x=1。
● 当通过C2进行判断时，(a== 2)||(x＞1)代入数字(1== 2)||(1＞1)可以推出(False||False)，即为False，执行c分支。
● 最后执行M3语句，返回x=1。通过这两组数据，该程序分支覆盖率就可以达到100%，如表2-2所示。
表2-2 分支覆盖测试用例
![[Pasted image 20240408093203.png]]

**6.分支覆盖的优缺点**
优点：分支覆盖具有比语句覆盖更强的软件测试能力，而且和语句覆盖一样很简单，无须细分每个判断就可以得到测试用例。
缺点：在一般情况下，大部分判断语句都由多个逻辑条件组合而成（如判断语句中包含and、or、case），若仅仅判断其最终结果，而忽略每个条件的取值情况，则必然会遗漏部分软件测试路径。在本例中，如果将(a== 2)||(x＞1)写成(a== 2)||(x＞=1)，则即使判断覆盖测试用例达到100%，还是发现不了这个漏洞。

***
#### 总结：分支覆盖只是考虑了每个分支的情况，但是真实的软件是多个分支组合来进行判断的，每个分子其实不是完全独立的。所以如果只是独立判断每个分支的覆盖大概率会遗漏很多情况。所以实际工作中很少只采用分子覆盖。
***


### 3.条件覆盖
在软件设计过程中，因为一个判断往往由多个条件组成，而分支覆盖仅考虑了判断的结果，没有考虑每个条件的可能结果，所以需要条件覆盖作为补充。
**概念：条件覆盖是指选择足够多的测试用例，当运行这些测试用例时，使判断中每个条件所有可能的结果至少出现一次。**
条件覆盖率的公式如下：条件覆盖率=被执行的条件数量/所有的条件数量×100%

**1.案例分析**
案例代码如下：
![[Pasted image 20240408094503.png]]表2-3为条件覆盖测试用例。
![[Pasted image 20240408094522.png]]
**2.条件覆盖率不可能总是达到100%**
在某些时候，条件覆盖率达不到100%，如下列代码：
![[Pasted image 20240408094552.png]]由表2-4可以看到，既要达到a＜=0，又要达到a＞=5是不可能的。
表2-4 条件覆盖率测试用例不一定达到100%
![[Pasted image 20240408094628.png]]

**3.被测程序分析**
假设x=2、a=2、b=1，则
● 当通过C1进行判断时，(a＞1)&&(b== 0)代入数字(2＞1)&&(1== 0)可以推出(True&&False)，即为False，执行a分支。
● 当通过C2进行判断时，(a== 2)||(x＞1)代入数字(2== 2)||(2＞1)可以推出(True||True)，即为True，执行d分支和M2语句，x=x+1代入数字得x=2+1，即x=3。
● 最后执行M3语句，返回x=3。假设x=1、a=1、b=0，则
● 当通过C1进行判断时，(a＞1)&&(b== 0)带入数字(1＞1)&&(0== 0)可以推出(False&&True)，即为False，执行a分支。
● 当通过C2进行判断时，(a== 2)||(x＞1)代入数字(1== 2)||(1＞1)可以推出(False||False)，即为False，执行c分支。
● 最后执行M3语句，返回x=1。
这时，测试得到的条件判断情形分别为F1、T2、F3、T4。经过以上测试用例，T1、T2、T3、T4、F1、F2、F3、F4都被执行了一次，条件覆盖率达到了100%，如表2-5所示。
表2-5 条件覆盖测试用例
![[Pasted image 20240408095618.png]]

**4.条件覆盖率的缺陷**
可以看出，这里虽然条件覆盖率达到了100%，但是语句覆盖率没有达到100%，M1语句没有被执行。为了弥补分支覆盖的不足及条件覆盖的不充分，出现了条件/分支覆盖。
***
上面的问题其实就算是所有的条件都覆盖了，也不能保证所有的分支覆盖了，比如（a> 1 &&  b > 2），当a> 1为ture   b > 2 为 false  以及 a> 1为false   b > 2 为 ture的时候相当于a和b中所有的条件都覆盖了，但是只是走了 false分支，所以条件的百分百覆盖率是不能保证分支的覆盖率的
#### 总结：条件覆盖率也是一种不能保证所有测试正确率的方式，测试中很少只使用条件覆盖
***

### 4.条件/分支覆盖
条件/分支覆盖是指通过设计足够多的测试用例，使得判断中每个条件的所有可能取值至少被执行一次，同时每个判断的所有可能判断结果至少被执行一次，即要求各个判断的所有可能的条件取值组合至少被执行一次。
被测程序分析：假设x=2、a=2、b=1，则
● 当通过C1进行判断时，(a＞1)&&(b== 0)代入数字(1＞1)&&(1== 0)可以推出(False&&False)，即为False，执行a分支。
● 当通过C2进行判断时，(a== 2)||(x＞1)代入数字(2== 2)||(2＞1)可以推出(True||True)，即为True，执行d分支和M2语句，x=x+1代入数字得x=2+1，即x=3。
● 最后执行M3语句，返回x=3。假设x=2、a=4、b=0，则
● 当通过C1进行判断时，(a＞1)&&(b== 0)代入数字(4＞1)&&(0== 0)可以推出(True&&True)，即为True，执行b分支和M1语句，x=x/a代入数字得x=2/4，即x=0.5。
● 当通过C2进行判断时，(a== 2)||(x＞1)代入数字(4== 2)||(0.5＞1)可以推出(False||False)，即为False，执行c分支。
● 最后执行M3语句，返回x=0.5。
可以看到，8个条件都达到了，即包含T1、T2、T3、T4、F1、F2、F3和F4。两个判断True和False也达到了C1=True，False；C2=True，False。由此，既达到了分支覆盖率为100%，也达到了条件覆盖率为100%，如表2-6所示。
表2-6 条件/分支覆盖测试用例
![[Pasted image 20240408102412.png]]

### 5. MC/DC
根据百度百科的定义，MC/DC是用在航空航天安全软件文件DO-178B中的一种白盒测试方式，可以判断A等级的软件是否已经经过适当的软件测试。条件(Condition)和判断(Decision)的概念：
![[Pasted image 20240408102830.png]]

其中，A、B、C都是条件，(A||B&&C)为判断。如果其是条件覆盖，只需要两个用例就够了，即让(A||B&&C)为True和False各执行一次。
● A=True、B=False、C=True.● A=False、B=True、C=False.
如果是MC/DC，要想使覆盖率达到100%，就需要4个用例，
下面来看看这4个测试用例是如何得到的？
MC/DC测试在每个判断中的每个条件都曾经独立影响判断结果至少一次
（独立影响是指在其他条件不变的情况下，改变其中一个条件）。分析下面判断语句。
![[Pasted image 20240408102931.png]]
● A单独起作用，即当A=False时，A||B&&C=False；当A=True时，A||B&&C=True，因此只需要B&&C=False。设B=False、C=True，这样，当A=False时，B&&C=False=＞False||False=False；当A=True时，B&&C=True=＞True||False=True。测试用例：A=True、B=False、C=True；A=False、B=False、C=True。
● B单独起作用，即当B=False时，A||B&&C=False；当B=True时，A||B&&C=True，因此只需要A=False、C=True。这样，当B=False时，A||B&&C=＞False||False&&True=＞False；当B=True时，A||B&&C=＞False||True&&True=＞True。测试用例：A=False、B=True、C=True；A=False、B=False、C=True。
● C单独起作用，即当C=False时，A||B&&C=False；当C=True时，A||B&&C=True，因此只需要A||B=True。设A=False、B=True，这样，当C=False时，A||B=True=＞True&&False=False；当C=True时，A||B=True=＞True||True=True。测试用例：A=False、B=True、C=True；A=False、B=True、C=False。将这些测试用例汇集成表2-7。
表2-7 MC/DC测试用例
![[Pasted image 20240408103013.png]]由于(False、False、True)与(False、True、True)的情形均有两对相同的组合，分别为第1行的组合2和第2行的组合2，以及第2行的组合1和第3行的组合1，各自去掉一对，因此，最后的测试用例如下。
● A=True,B=False,C=True.
● A=False,B=False,C=True.
● A=False,B=True,C=True.
● A=False,B=True,C=False.需要进一步补充说明的是，MC/DC的主要作用是防止在组合条件表达式中包含副作用，见以下语句。
![[Pasted image 20240408103258.png]]
其中，当b()函数或c()函数产生副作用时，MC/DC非常必要，因为原则上不应该在组合条件表达式中调用产生副作用的函数。

### 6. 路径覆盖
路径覆盖是指通过选取足够多的软件测试数据，使程序的每条可能路径都至少被执行一次（如果程序流程图中有环，则要求每个环至少经过一次）。
路径覆盖率的公式如下：路径覆盖率=被执行的路径数量/所有的路径数量×100%
在图2-2所示的程序中，4条路径分别为(1，3)、(1，4)、(2，3)和(2，4)。为了让路径覆盖率达到100%，设计了表2-8所示的测试用例。
![[Pasted image 20240408103731.png]]表2-8 路径覆盖测试用例
![[Pasted image 20240408103824.png]]

### 7.几种覆盖率的强弱关系
![[Pasted image 20240408103921.png]]分支覆盖率达到100%，语句覆盖率一定达到100%；条件/分支覆盖率达到100%，分支覆盖率一定达到100%；MC/DC的覆盖率达到100%，条件/分支覆盖率一定达到100%。但是当路径覆盖率达到100%时，分支覆盖率可达到100%，条件/分支覆盖率不能达到100%，比如表2-9中，虽然路径覆盖率达到了100%，但是x＞1始终为False。

### 8.控制流覆盖
控制流覆盖经常被用在嵌入式软件系统中，如图2-4所示的例子。
![[Pasted image 20240408104026.png]]

首先，
● 对经过A点的线进行排序：{1，2}、{1，3}、{1，4}、{6，2}、{6，3}、{6，4}。
● 对经过B点的线进行排序：{2，6}、{3，6}、{4，6}、{2，5}、{3，5}、{4，5}。然后，总体排序为{1，2}、{1，3}、{1，4}、{2，5}、{2，6}、{3，5}、{3，6}、{4，5}、{4，6}、{6，2}、{6，3}、{6，4}。接下来，依次将从分支1开始到分支5结束的连续序列作为一个序列输出，输出过的分支组从序列中删除，一直到把所有序列都输出完毕，如表2-10所示。
表2-10 控制流覆盖过程
![[Pasted image 20240408104103.png]]最后，得到五个测试用例：{1，2，5}，{1，3，5}，{1，4，5}，{1，2，6，2，5}，{1，3，6，4，6，3，5}。特别需要指出，即使软件代码的各种覆盖率都达到了100%，也并不能说明产品的质量就非常优秀，比如代码没有实现用户需求；另外，软件代码的覆盖率没有达到100%，也不能说明产品的质量不好，比如代码中存在无效代码或者永远执行不到的代码。当然，对于这些代码应该及时删除。