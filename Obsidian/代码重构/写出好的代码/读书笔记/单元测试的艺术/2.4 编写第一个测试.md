你如何测试自己的代码?一个单元测试通常主要包含三个行为：

(1)准备(Arrange)对象，创建对象，进行必要的设置；

(2)操作(Act)对象；

(3)断言(Assert)某件事情是预期的。

下面是一段简单的代码，包含了以上全部三个行为，其中断言部分使用了NUnit框架提供的

Assert类。

```
[Test]

public void IsValidFileNae_BadExtension_ReturnsFalse()

LogAnalyzer analyzer = new LogAnalyzer();

bool result = analyzer.IsValidlogFileName("filewithbadextension.foo");

Assert.False(result);

}

```
在进行下一步之前，你需要对Assert类有所了解，这个类是编写单元测试的一个重要部分。

### 2.4.1 Assert类

Assert类位于NUnit.Framework命名空间，提供静态方法。Assert类是你的代码和NUnit框架

之前的桥梁，用于声明某个特定的假设应该成立。如果传给Assert类的参数和你断言的值不同，

NUnit会认为测试失败，向你提出警告。你可以选择Assert类在断言失败时给出什么警告信息。

Assert类有很多方法，最主要的一个是Assert.True(某个布尔表达式),用于验证一个布

尔条件。但是Assert类还有很多其他方法，你可以把它们看做是对各种不同条件的文法修饰，

使代码更清晰(例如我们使用的Assert.False)。

例如有一个方法验证预期的对象或值和实际的相同：

Assert.AreEqual(expectedobject, actualObject, message);

使用示例如下：

Assert.AreEqual(2,1+1,"Math is broken");

另一个方法验证两个参数指向同一个对象：

Assert.AreSame(expectedobject, actualobject,message);
使用示例如下：

Assert.AreSame(int.Parse("1"),int.Parse("1"),

"this test should fail").

Assert简单易学，使用方便，也容易记忆。

请注意所有的断言方法最后一个参数都是字符串类型，如果测试失败，这个字符串会和测试框架的标准输出一起显示在结果中。但是请千万不要使用这个参数(这个参数是可选的)而是用你的测试名说明应该发生的结果。人们经常会使用这个参数输出一些简单明显的信息，例如：“测试失败”,或者“期望值x,实际值y”,而这些信息测试框架本身已经提供了。这个参数就像代码里的注释，提供的是冗余的信息，如果你一定要使用这个参数，还不如把方法名起得更有意义一些。

了解完了单元测试框架API的基本知识，现在让我们来运行一个测试。

### 2.4.2 用NUnit运行第一个测试

现在来运行你的第一个测试，看它是否能通过。
至少有四种方法可以运行测试：

口 使用NUnit的图形化用户界面(NUnit GUI);

口 使用Visual Studio 2012 Test Runner的一个叫NUnit Test Adapter的NUnit运行器扩展(这个

扩展在NUget联机库中可以找到);

口 使用ReSharper测试运行器(一个有名的VS商用插件);

口 使用TestDriven.NET测试运行器(另一个有名的VS商用插件)。

虽然本书只讲解NUnit GUI,但我个人偏好使用NCrunch。NCrunch速度很快，可以自动运行，

但是要花钱购买。(本书附录介绍了了NCrunch和其他工具。)NCrunch在Visual Studio编辑器窗口提供简单、快速的反馈。在实际工作中，我认为这个运行器能够无缝地辅助测试驱动开发。你可以在www.ncrunch.net得到更多的相关信息。

要使用NUnit GUI运行测试，你需要给NUnit提供一个编译好的程序集进行检查(在本例中这个程序集是一个dll文件)。在编译好项目后，请找到编译好的程序集所在的目录。

接下来，请启动NUnitGUI。(如果你是手动安装的NUnit,请在计算机桌面上找到NUnit GUI图标。如果是用Nugget安装的NUnit.Runners,可以在解决方案根目录下的Packages文件夹里找到NUnit GUIEXE可执行文件。)选择File>Open,输入测试程序集的名字。你会在左侧窗口看到项

目里的那一个测试、类以及命名空间层次，如图2-3所示。单击按钮Run运行测试。测试会自动按命名空间(程序集，类型名)组织在一起，你可以选择只运行某种类型或者某个命名空间的测试。
(通常需要运行所有的测试，以更好地了解测试失败的情况。)

你有一个测试失败，这说明代码中有缺陷。现在需要修复代码以使测试通过。请修改代码，把原本缺失的那个!加在if子句前，修改后代码应如下所示：

```
if(1fileName.EndsWith(".SLF"))
{
	return false;
}
```
![[Pasted image 20240625142309.png]]

### 2.4.3 添加正检验

你可以看到，方法可以识别错误的扩展名，但是谁能保证这个方法也能识别正确的扩展名呢?如果你采用测试驱动的方法进行开发，这里缺少的测试就会很明显。但因为是在代码完成以后编写测试，所以你就需要想出完善的测试策略来覆盖所有的情况。以下代码又加入了几个测试，

检验传入一个扩展名正确的文件的运行结果。其中一个测试大写文件扩展名，另一个测试小写文件扩展名。

代码清单2-1 测试LogAnalyzer的文件名验证逻辑
```
[Teat] 
public void IsValidLogFileName_GoodExtensionLowercase_ReturnsTrue()
{
	LogAnalyzer analyzer = new LogAnalyzer();
	bool result =analyzer.IaValidLogFileName("filewithgoodextension.slf");
	Assert.True(result);
}

[Test]
public void IaValidLogFileName_GoodExtensionUppercase_ReturnsTrue()
{
	LogAnalyzer analyzer = new LogAnalyzer();
	bool result = analyzer.IsValidLogFileName("filewithgoodextension.SLF");
	Assert,True(result)
}
```

如果现在重新编译解决方案，你会发现NUnit GUI能检测到程序集发生了改变，在界面上自动重新加载程序集。如果重新运行测试，你会看到小写文件扩展名的测试失败。你需要修改产品代码，改用大小写不敏感的字符串匹配。

```
public bool IsValidLogFileName(string fileName)
(
	if(IfileName,EndsWith(".SLF",StringComparison.CurrentCultureIgnoreCase))
{
	return false;
}
	return true;
}
```
修改后再次运行测试，所有的测试都应该通过，NUnit界面应该再次显示美妙的绿色进度条。

### 2.4.4 从红到绿：测试成功

NUnit界面的设计理念很简单：所有的测试都应该通过，继续前行的绿灯才会亮起。哪怕有一个测试失败了，进度条上都会亮起红灯，显示你的系统(或者测试)出现了问题。

这个红绿灯的概念在单元测试领域，特别是在测试驱动开发中非常流行。它的思路是“红-绿-重构”,意思是以一个失败的测试开始，然后使这个测试通过，然后修改代码使其可读，更易维护。
如果一个预期之外的异常抛出，测试也会失败。在绝大部分测试框架中，如果一个测试因为未捕获的异常而停止运行，我们认为这个测试结果失败了。预期之外的异常有时也是缺陷的一种形式。
说到异常，你在本章稍后将看到一种测试，它的预期结果是代码抛出异常，这种异常看做被测试代码的特定结果或行为。如果预期的异常没有抛出，这些测试就失败了。

### 2.4.5 测试代码格式

请注意我使用的测试代码在格式和可读性上与“标准”代码有所不同。测试名可以很长，但是测试名中的下划线可以令你不会遗漏所有的重要信息。同时，请注意我在每个测试方法中，准备对象、操作对象以及断言阶段的代码之间都空出一行，这样可以帮助我快速阅读测试代码，更快找到测试中的问题。

我也尽量把断言和操作对象的代码分开。我会选择对一个值，而不是直接对一个函数调用进行断言。这样可以提高代码的可读性。

编写测试代码时，可读性是最为重要的方面之一。我们要尽量使测试代码易读，就算是一个从来没看过这个测试的人，也应该能读懂测试代码而不需要问太多问题，或者根本就没有问题。

第8章会更深入探讨测试代码可读性的问题。现在，让我们来尝试减少重复的测试代码，使其更简洁易懂。

## 2.5 使用参数重构测试

到现在为止，你所写的所有测试代码都不太容易维护。假设你在类LogAnalyzer的构造函数里加入一个参数，那你的三个测试都不能成功编译了。修复三个测试问题不是很大，但是你有可能需要修复30个甚至300个测试。在真实工作中，开发人员觉得他们不应该把时间浪费在修复编译失败的简单问题上。如果测试失败了，你可能就不想运行测试，甚至会想把这些讨厌的测试删掉。
让我们重构这些测试，以后就不会再遇到这个问题了。

NUnit有个很酷的功能，这时能帮大忙。这个功能叫做参数化测试(parameterized tests)。要使用这个功能，你可以从现有的测试方法中任意选择一个，进行以下修改：

(1)把属性[Test]替换成属性[TestCase];
(2)把测试中用到的硬编码的值替换成这个测试方法的参数；
(3)把替换掉的值放在属性的括号中[TestCase(param1,param2,..)];
(4)用一个比较通用的名字重新命名这个测试方法；
(5)在这个测试方法上，对每个需要合并的测试方法，用其测试值添加一个[TestCase(...)]属性；
(6)移除其他测试，只保留这个带有多个[TestCase]属性的测试方法。
让我们逐步进行这些修改。在第(4)步完成之后，测试方法代码应该如下所示：

![[Pasted image 20240625143512.png]]
在运行期间，测试运行器把传给TestCase属性的参数赋给测试方法自身的参数。你可以给测试方法和TestCase属性加任意多个参数。

接下来就是精彩的部分：你可以在一个测试方法上加多个TestCase属性。第六步完成后，测试代码应该如下所示：
![[Pasted image 20240625143907.png]]现在你就可以把之前那个使用合法的小写后缀名的测试删掉了，因为这个测试已经作为一个属性包含在当前的测试方法中了。如果再次运行测试，你会看到测试数目没有改变，但是测试代码变得更易维护，更加易读了。

你还可以更进一步，在当前的测试方法中添加一个负面测试(期待最终结果值为假的断言)。

我将示范如何添加负面测试。但是我想提醒你，如果添加负面测试，测试方法名就必需更通用，这会令测试方法可读性降低。这个示例没有对代码进行大的改动，却使得测试难以理解，对参数化测试技术的过度使用并不值得推荐，请把这个示例仅仅看做是一个文法演示好了。

下面的代码展示了如何重构类中所有的测试——在测试用例和测试方法里再添加一个参数，把断言改成Assert.AreEqual。
![[Pasted image 20240625144048.png]]
有了这个测试方法，你就可以去掉测试类里的其他测试方法。但是请注意此时测试名变得非常通用，很难根据测试名判断哪种情况是有效的，哪种是无效的。在这种情况下，传入的参数就需要简单明了，因此你必须使用尽量简单的参数，用最简单的值来证明你的观点。更多关于实现可读性目标的内容，请阅读第8章。

说到可维护性，请注意你现在只有一处对类构造函数的调用，这比之前的代码要好，但还不够。你不能只用一个庞大的参数化的测试方法来实现所有的测试。我们之后将讨论更多提高代码可维护性的技术。(对，你猜对了，还是在第8章!)

现在你能进行的另一项重构是修改产品代码里的条件语句if的实现。你可以把它简化成一个返回语句。如果你喜欢简化代码，现在就是重构的时机。我不喜欢这种极简风格，我喜欢保留一些冗余代码，这样读代码的人就不用太费脑子了。我不喜欢太过精妙的代码，如果返回语句里还有条件判断，我会觉得很别扭。但是本书不是讲程序设计的，记得吗?你愿意怎么实现测试代码都可以。关于这方面的论著,我推荐你阅读Robert Martin(Bob大叔)的《程序员的职业素养》

## 2.6 更多 NUnit属性

现在你已经看到创建能自动运行的单元测试是多么容易，接下来看怎样为每个测试设置初始状态，以及如何清除测试留下的垃圾。
在一个单元测试的生命周期中，你需要控制其中的某些关键阶段，运行测试只是其中之一。
在每个测试运行之前还有特殊的setup方法，这部分会在下一节讨论。

### 2.6.1 setup和teardown

进行单元测试时，很重要的一点是保证之前测试的遗留数据或者实例得到销毁，新测试的状态是重建的，就好像之前没有测试运行过一样。如果系统中有前一个测试遗留的状态，可能会导致你的测试失败，但是它只在别的某个测试之后会失败，其他时候都能通过。这种测试之间依赖性的缺陷很难定位，花费时间很也长，我不推荐大家在这上面花费精力。我会在本书第二部分讨论单元测试的最佳实践，编写完全独立的测试就是其中一条。

NUnit有一些特别的属性，可以很方便地控制测试前后的设置和清理状态工作，那就是[SetUp]和[TearDown]动作属性。图2-4展示了运行一个包含setup和teardown动作的测试运行过程。
![[Pasted image 20240625150402.png]]在现阶段，你只需确保每个测试都使用被测试类的一个新实例，这样前一个测试的遗留状态就不会影响你的测试了。
你可以使用两个NUnit属性控制系统在setup和teardown步骤的行为。
+  [setUp] 这个属性可以像属性[Test]一样加在一个方法上，NUnit每次在运行测试类里的任何一个测试时都会先运行这个setup方法。
+  [TearDown] 这个属性标识一个方法应该在测试类里的每个测试运行之后执行。

代码清单2-2展示了怎么使用属性[Setup]和[TearDown],确保每个测试都得到一个LogAnalyzer类的新实例，同时还能省去一些重复的输入。
但是要注意，使用[SetUp]越多，测试代码可读性就越差。为了理解测试怎么得到实例，使用的对象是什么类型，人们不得不同时看文件里的两处代码。我告诉我的学生：“想象一下，代码的读者和你从未谋面也无法联系，在你离职两年之后才来读你的测试代码。你使得代码易读的每一个微小的努力，对他们都是极大的帮助。他们如果对你的代码有任何问题，周围都不会有人能够解答，所以你是他们唯一的希望。”如果读代码的人为了能理解你的测试而不得不在两段代码间来回地看，那可不是什么好主意。
![[Pasted image 20240625150620.png]]
你可以把setup和teardown方法想象成测试类中测试的构造函数和析构函数。在每个测试类中只能有一个setup和一个teardown方法，这两个方法对测试类中的每个方法只执行一次。代码清单2-2中有两个单元测试，因此NUnit的执行路径会类似图2-5所示。

在实际工作中，我并不用setup方法初始化被测试类的实例。这个示例代码中的用法是为了让你知道有这种用法，但你应该避免这么用。在setup方法中初始化示例看似不错，但是随着代码的增加，setup方法后面的测试方法很快就变得难以阅读。我采用工厂方法(factory method)初始化被测试的实例。具体做法请参见第7章。

NUnit还包含其他几个辅助设置和清理系统状态的属性。例如：[TestFixtureSetUp]和
[TestFixtureTearDown]可以在一个特定类里所有测试运行之前进行一次状态设置，在所有测试运行之后进行另一次(每个测试固件一次)。如果设置和清理工作花费时间很长，你希望对每个测试固件进行一次，这两个属性就很适用。使用这些属性应该谨慎，不小心的话会导致几个测试共享系统状态。
在单元测试项目中几乎永远不会用到TearDown或者TestFixture方法。如果用了这两个方
法，你很有可能用到了文件系统或者数据库，编写的是集成测试。我发现只有一种情况下在单元测试中使用TearDown方法是有意义的，那就是需要在测试之间“重置”一个静态变量或者单例的状态。任何其他情况下使用TearDown,你都有可能是在做集成测试。做集成测试也没什么不好，但是你应该把它放在另一个专门写集成测试的单独的项目里。

接下来，我们要了解如何测试一个应该由代码抛出的异常。
![[Pasted image 20240625150831.png]]

### 2.6.2 检验预期的异常

一个常见的测试场景是：保证当异常应该抛出时，被测试的方法能够抛出正确的异常。
假设传入一个空文件名的时候，你的方法应该抛出一个ArgumentException异常。如果
代码在这种情况下没有抛出异常，你的测试就应该失败。我们将要测试如下所示的代码清单中的逻辑
![[Pasted image 20240625151839.png]]对此有两种测试方法。让我们先来看不应该用的那种，因为这种方法很流行，而且曾经是做这种测试的唯一方法。NUnit有一个特殊属性可以用来测试异常：[ExpectedException]。检查异常出现的测试代码示例如下：
```
[Test]

[ExpectedException(typeof(ArgumentException),ExpectedMessage ="filename has to be provided")]
public void IaValidFileNae_EmptyFileName_ThrowSException()
(
	m_analyzer.IaValidLogFileName(string.Empty);
}

private LogAnalyzer MakeAnalyzer()
{
	return new LogAnalyzer();
}

```
这段代码有几个需要注意的重要地方。

+  预期的异常消息作为一个参数传递给[ExceptedException]属性。

+  测试自身没有使用Assert调用。[ExceptedException]属性内部包含断言。

+  因为被测试方法调用预期触发一个异常，所以测试不需要从被测试方法取得布尔结果值。

示例中创建LogAnalyzer类实例的代码放到了一个工厂方法中，这和我们当前讨论的问题

无关。我在所有的测试中都使用这种工厂方法，这样被测试类的构造函数发生改变时就不用修改

很多测试代码，维护工作更加容易。

对代码清单2-3中的方法，这个测试应该通过。如果你的方法不抛出一个Argument

Exception,或者异常的消息和预期的值不同，测试就会失败

结果显示一个异常没有抛出，

或者异常消息和预期不同。

那我之前为什么说不应该使用这种方法呢?因为这个属性基本上是告诉测试运行器把这整

个方法包在一个大的try-catch块里，如果没有东西“捕捉”到，就认为测试失败。这种做法有

一个很大的问题，就是你不知道是哪一行代码抛出的这个异常。实际上，如果构造函数有问题，

抛出了一个异常，你的测试也会通过，而构造函数是绝对不应该抛出异常的。这样的话，使用这

个属性，测试结果可能是不真实的。所以，尽量不要用这种方法。