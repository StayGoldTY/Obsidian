有时候将测试安置到位并不是件简单的事情。如果能够在测试用具中单独实例化你的类，那 你算是比较幸运的。许多人无法做到这一点。不过，如果你也在这上面遇到麻烦了，不妨尝试一 下第9章描述的技术。
(在测试用具中)实例化一个类通常只是第一步。
接下去便是为需要修改的方法编写测试。 
有些时候我们无需实例化那个类便可以直接进入第二步。例如，假设待修改的方法并没有使用多少实例变量，便可以使用暴露静态方法 (273页)手法来访问该方法的代码。倘若该方法相当长 且难于对付，则可使用分解出方法对象 (261页)手法来将其中的代码移到一个相对来讲更容易 实例化的类当中去。

幸运的是，大多数情况下，为一个方法编写测试所需的必要工作量并不算太夸张。下面列出 了我们可能会遇到的一些问题：

+ 无法在测试中访问那个方法。比如说，它可能是私有的，或者有其他可访问性限制。
+ 无法轻易地调用那个方法，因为很难构建调用它所需的参数。
+ 那个方法可能会产生糟糕的副作用(如修改数据库、发射 一枚巡航导弹，等等),因而无法在测试用具中运行它。
+ 我们可能会需要通过该方法所使用的某些对象来进行感知。
本章接下来将会描述一系列的问题场景，展示了解决这些问题的不同方式，以及解决过程中 的权衡与折中。

**10.1**  **隐藏的方法**

我们需要对一个类中的某方法作修改，但它是一个私有的方法，这时该怎么办呢?

第一个问题就是，能否通过一个公用的方法来进行我们的测试。如果能，则值得那么做，以 免我们得想方设法去访问那个私有方法。而且，这么做还有另一个好处，即当我们通过公用方法 来进行测试时，肯定是按照该方法被用在实际代码中的方式来测试它的'。这有助于稍微缩小我 们的工作范围。
在遗留代码中，常常会出现一些质量有问题的方法。要想使一个私有方法对其每个调用方都可用，可能需要进行相当量的重构工作才行。有些一般性很强的方法能够被许多调用 方调用，能这样固然不错，但实际上每个方法在功能上应当刚好足够满足它的调用者，在清晰程度上也应当足够清晰，以便于理解和修改。在测试一个私有方法时，倘若是通过一个使用了它的 公用方法来间接测试的话，则把这个私有方法做得一般化倒也没多大危险。如果有朝一日该方法需要成为公用的，那么其外的第一个使用者应当编写一系列测试用例，准确说明该方法的用途以及调用者该如何使用它。

以上这些都没问题，但有时我们就是想要直接为一个私有方法编写测试用例(对该方法的调 用被深深埋藏在类中)。这么做的原因可能是因为我们想要获得一些具体的反馈，以及能够解释 该方法是怎样被使用的测试用例，或者，也有可能只是因为通过它的类上面的公用方法来测试它 太困难了，等等。

那么,如何为一个私有方法编写测试呢?这肯定是在测试中被问得最多的问题之一了。幸运 的是，这个问题有一个非常直接的答案：如果需要测试一个私有方法，那么就应该将它设为公用 的。如果不大方便将其设为公用的，则大多数情况下便意味着我们的类做的事情太多了，应该 进行适当调整。让我们来看看什么时候不大方便将一个私有方法置为公用的呢?有两个可能的 原因：

**(1)该方法只是个工具方法；客户并不会去关心它。
(2)如果客户代码使用了该方法，那么他们可能会反过来影响到该类上的其他方法调用的 结果。

第一个原因并不算很严重。类的接口上多出一个公用方法并没什么大不了，不过我们还是应该试试看将它放到另一个类当中会不会更好一些。
而第二个原因要严重一点，不过幸运的是还有补救措施：

<span style="color: #3CB371;">这个私有方法可以被转移到一个新类当中去。我们可以让它成为这个新类上的公用方法，而我们原先的那个类则可以在内部创建该新类的实例。这么一来，这个方法也就变得得可测试 了，而同时我们的设计也得到了改善。</span>

是的，我知道这个建议有点不中听，但它帶来的一些效果却是很积极的。无论如何这个事实 都不会改变：好的设计应当是可测试的，不具可测试性的设计是糟糕的。遇到上面这类情况，应对之策是尝试采用第20章中所描述的技术。不过，当并没有多少现有测试可用时，就不得不小心 行事，先做一些其他工作，然后再开始分解。

先来看一个真实的案例，看看我们是如何来解决上面提到的问题的。下面是一个C++类声明 的一部分：
![[Pasted image 20240523105420.png]]CCAImage是一个保安系统中的一个类，负责拍照功能。你可能想知道为什么一个图像类会 负责拍照，但别忘了，这是遗留代码。该类有一个snap() 方法，该方法使用一个低层的C API 来控制一个摄像头进行“拍”照，但是，它“拍”下来的是一种非常特殊的图像。 一次对snap() 的调用会导致好几个不同的摄像头被调动起来，它们各自都会拍下一幅图片，这些图片被分别放 到CCAImage 内部的图像缓存中的不同部位。而决定每幅图片分别被安放在哪个部位的逻辑则是 动态的，取决于被拍对象的移动。根据其移动方式的不同， snap() 方法会重复调用 setSnapRegion() 来确定当前照片应当被放在缓存的哪个部位。然而遗憾的是，现在，摄像头 的API改变了，于是我们需要对setSnapRegion 作相应的修改。那么,具体该怎样进行呢?
一种可能的做法就是简单地将该方法设为公用的。但可惜的是这么做会带来非常消极的影 响。CCAImage类中有一些变量负责记录拍照区域的当前位置。所以倘若产品代码不小心在snap()  方法外部直接调用了setSnapRegion    的话，便会给摄像头跟踪系统带来严重问题。
是的，问题就在这儿。不过，在开始寻找解决方案之前，让我们先来看一下当初是怎么踏进 这团泥沼中的。之所以无法测试这个图像类，真正的原因在于它负担的职责太多了。理想情况下 我们应当可以使用第20章所讲的技术来将它分解为几个小类，那样的确不错，但首先得仔细考虑 一下眼前是否应该进行这么多的重构工作。诚然，这么做是有极大好处的，不过能否这么做却取 决于当前我们在整个产品发布周期中所处的阶段，有无足够时间以及所有相关的风险。
如果目前我们负担不起这个风险去将职责分离开来，那至少能为待修改方法编写测试吧?幸 运的是，答案是肯定的。下面便是具体做法：
![[Pasted image 20240523105547.png]]
在完成这些之后，便可以在测试中调用CCAImage上的setSnapRegion    方法了(虽然是间接 调用)。然而，这样做是好主意吗?记得一开始的时候我们并不想将这个方法设为公用，但现在 我们通过其他途径达到了类似的效果。我们将方法设为受保护的，从而削弱了它的访问控制。

坦白地说，我并不介意这么做。对我来说，这样做令我们能够编写测试，是一宗公平交易。 没错，这样的改动的确破坏了封装，从而当我们在分析代码是如何工作的时候，就得把ccAImage   的子类也能调用setSnapRegion 这一事实也考虑进去，但是，这毕竟是一个相对来说比较次要  的问题。或许后面当我们再次接触该类时，当初那点小小的改动就足以引发我们对该类的彻底重 构。届时我们便可以将CCAImage 中的职责分解到几个不同的类当中，并让后者成为可测试的。

![](file:///C:\Users\TY\AppData\Local\Temp\ksohtml32088\wps63.png)

**10.2**   **“有益的”语言特性**

语言设计者经常会试图加入一些方便的语言特性，但这件事并不容易。他们得在易编程性与 安全性中进行折中。有些语言特性一开始看上去的确是“面面俱到”了，然而当我们想要测试使 用了这些特性的代码时，残酷的现实就显露出来了。

下面这段C# 代码负责从一个Web客户端接收一组上载的文件，然后遍历它们，从中挑出具有 特定特征的文件，然后返回一组与这些文件关联的流。
![[Pasted image 20240523105753.png]]现在，我们想要对以上代码作一些修改，或许再来一点重构，但问题是给它编写测试就不那么容易了。我们想要创建 一个HttpFileCollection         容器对象并往它里面放入 一 组 HttpPostedPile 对象，而这又是不可能的。首先， HttpPostedFile 类并没有公用的构造函数。 其次，它是一个封闭的类。在C# 中，这两点便意味着我们没法创建HttpPostedFile 的实例，而  且我们也无法从它进行派生。HttpPostedFile 是.NET 库的一部分。里面的其他一些类会在运行  期创建它的实例，但我们却没有对它的访问权。此外，打开HttpPileCollection 类的定义稍  微看一看就会发现，它也有同样的问题：无公用构造函数，无法创建其派生类。
.NET 类库为什么要这么做呢?毕竟我们花钱买了它的许可证啊。说实话我倒并不认为这是故意的，如果说微软是故意这么做的话，那Sun也一样，因为这并不只是微软的语言的问题。Sun 的语言也有阻止子类化的特性。在Java中 ，final 关键字正是用来干这个的，当一个类在安全性 方面很敏感时，便可对它使用final 。 若是任何人都能创建HttpPostedFile        (或者甚至像 string 这样的类)的子类的话，他们岂不就能编写出一些恶意的代码并将其用于那些使用了这些类的代码中了?这是非常危险的，不过sealed和fina1关键字有时候对我们来说又显得过于激进了，就拿刚才讨论的情况来说吧，它给我们带来了不小的麻烦。

那么,要想为getKSRStreams 编写测试的话有什么办法呢?我们不能使用接口提取(285页)  或实现提取(281页),因为HttpPostedFile     和HttpFileCollection 并不由我们控制，它们是类 库里面的类，是不能随便去修改的。所以我们只能使用参数适配 (Adapt Parameter,258页)手法了。
不过，就这个例子来说我们还是挺幸运的，因为我们对那个HttpFileCollection         所作的 只不过是遍历而已。虽然HttpFileCollection 是个封闭类，但它却有一个非封闭的基类，叫 做NameObjectCollectionBase 。   我们可以对后者进行子类化，并将所得子类的对象传给 getKSRStreams 方法。借助于依靠编译器(251页)技术，我们的修改既安全又容易。
![[Pasted image 20240523110320.png]]OurHttpFileCollection  是 NameObjectCollectionBase  的子类，而NameObjectCollectionBase 则是一个抽象类，其功能是将字符串关联到对象。
这样一来我们就解决了其中一个问题。接下来的问题要稍困难一些：要在测试中运行 getKSRStreams, 我们需要一组HttpPostedFiles,  而不幸的是我们偏偏又无法创建 HttpPostedFile 的实例。既然如此，不妨换个角度来思考：我们实际上需要用到的是 HttpPostedFile 上的两个属性： FileName  和ContentLength 。  故而我们可以利用剥离并外覆 API(169 页)技术，解开代码与HttpPostedFile之间的耦合。为此，首先提取一个接口 IHttpPostedFile,  然后编写一个外覆类HttpPostedFileWrapper:
![[Pasted image 20240523110510.png]]唯一麻烦的就是，我们必须得在产品代码中先遍历一遍原先的HttpFileCollection         容器， 将其中的每个HttpPostedFile 对象都“打包”进一个相应的HttpPostedFileWrapper  对象中， 然后将这些外覆对象放进一个新的容器 (OurHttpFilecollection)   中，并将后者传给 getKSRstreams 方法。这就是安全性所要付出的代价。

说真的，我们很容易相信sealed 跟final 都是错误的特性，本就不应该加入到编程语言中。 然而实际上，真正的错误却出在我们自己身上，是我们自己选择直接依赖于不由我们控制的库的， 这一举动等于是在自寻烦恼。
将来的主流编程语言或许会给测试提供特殊访问权限，但现在，保守使用sealed   和final
还是有好处的。当我们需要使用标记为sealed/final 的类时，最好将它们隔离在一层外覆类后 面，这样以后对代码作修改时才能有一些回旋余地。关于如何解决该问题的更多讨论和技术，请 参考第14章以及第15章。

**10.3**  **无法探知的副作用**

理论上，为一段功能编写测试不应该太难。实例化一个类，调用它的方法，然后检查结果， 就这样简单。那么,哪个环节可能出问题呢?实际上，如果我们欲创建的对象不跟其他任何对象  沟通的话，事情的确就像刚才描述的那样简单。甚至就算其他对象使用了该对象，但只要该对象  并不使用其他对象，我们的测试就可以像程序的其他部分那样使用它。然而遗憾的是，不使用其  他对象的对象少之又少。

程序是一个各部分互相协作的整体。常常会看到一些并不返回任何值的方法。我们调用这些 方法，它们完成各自的工作，而我们(指调用方代码)则根本不知道它背后都干了些什么。某对 象调用其他对象上的方法，而我们则根本无从知道结果。

下面这个类暴露了上面所说的问题：
![[Pasted image 20240523110637.png]]这个遗留的Java类什么都做。它创建GUI 构件，并使用actionPerformed  事件处理函数从它 们那里接收通知消息，然后计算需要显示的内容并显示它们。不过，它做这些事情的方式非常奇 怪：首先建造一段详细文本，然后创建并显示另一个窗口。当该窗口完成它的工作时，该类再直 接从它获取信息，作一点处理，然后放入到一个文本框中。

我们可以试着在一个测试用具中运行该方法，但这么做没有任何意义。它会创建一个窗口， 显示给我们，让我们输入数据，然后接着在另一个窗口显示一些东西。没有合适的地方可以感知 这段代码做了什么。

那么,我们可以做些什么呢?首先，可以将依赖于GUI 的代码与不依赖于GUI 的代码分离开 来。由于所用的编程语言是Java,  所以我们可以选一个Java的重构工具来用。第一步工作就是执 行一组方法提取 (325页),将这个大方法中的工作分割成小块。

那么,具体从哪开始呢?

该方法本身主要是起到一个事件响应“钩子”的作用，负责响应窗口框架传递来的通知消息。 
它所做的第一件事情便是从接受到的动作事件³中获取命令的名字。所以，如果将该方法的整个 方法体都提取出来的话，也就可以完全脱离对ActionEvent 类的依赖了，如下所示：
![[Pasted image 20240523110743.png]]然而要想让这些代码真正变成可测试的，这点工作还不够。下一步便是将访问另一个窗体的 代码提取成方法。为此， 一个有益的做法是将detailDisplay       设成该类的一个实例变量，如下 所示：
![[Pasted image 20240523110824.png]]有了这一步铺垫，我们便可以将使用detailDisplay       窗体的代码提取成一组方法了。那么 该如何为这组方法命名呢?为此，我们从该类的角度来考虑每段代码都做了些什么,或者说它们 都为该类计算了些什么。此外，我们不应该使用与显示组件有关的名字，可以在提取出的代码中 使用显示组件，但其方法名却应当隐藏这一事实。有了这些考虑，我们便可以将提取出的每块代 码做成一个命令式方法或查询式方法了。

**命令/查询分离
命令/查询分离是最先由Bertrand Meyer提出的设计准则。简而言之就是： 一个方法要么是一个命令，要么是一个查询；但不能两者都是。命令式方法指那些会改变对象状态但并不返回 值的方法。而查询式方法则是指那些有返回值但不改变对象状态的方法。
那么,为什么说这是个重要的原则呢?有几个原因，其中最重要的就是它向用户传达的信 息。例如，如果一个方法是查询式的，那么无需查看其方法体就知道可以连续多次使用它而不 用担心会带来什么副作用。

在经过了一系列的方法提取之后，performCommand 方法看起来就像这样：
![[Pasted image 20240523110948.png]]
既然我们已经将所有与detailDisplay       窗体有关的代码都提取出来了，那么接下来就可以找出并提取那些访问AccountDetailFrame 上的组件的代码了。
![[Pasted image 20240523111020.png]]在作了这一番提取之后，我们便可以运用一下子类化并重写方法技术，并对performCommand 中剩下来的代码进行测试了。例如，像下面这样子类化了AccountDetailFrame      之后，我们便 可以测试当给出"project            activity"命令时display文本框能否得到正确的文本了：
![[Pasted image 20240523111052.png]]在像上面这样非常保守地通过自动方法提取进行解依赖之后，得到的代码可能会让我们心生 怯意。例如， setDescription 方法负责创建并显示一个窗体，这样的方法绝对是令人头大的。 如果我们不小心两次调用了它会怎么样呢?得解决这个问题，以上一系列粗糙的方法提取是个不错的起点。接下来我们可以看看能否将这些窗体创建代码重新安置到一个更好的地方去。

我们来理一 下目前的状况： 一开始我们有一个类，该类上面有一个重要的方法： performAction。  而现在的状况则可以用下图来显示(图10-1)。

虽然从UML 图中看不出来，但实际上getAccountSymbol  和setDescription  只使用了 detailDisplay        成员变量。而setDisplayText        也只是使用了display     成员变量而已。于是我们可以将它们看作互相独立的职责，从而最终得到如图10-2所示的设计：
![[Pasted image 20240523111138.png]]

虽说这是极其粗糙的重构，但至少在某种程度上将几个职责分离开来了。不过， AccountDetailFrame(Frame    的子类)仍跟GUI 联系紧密，并且它里面仍然包含着业务逻辑。 进一步的重构可以解决这个问题，但至少现在我们可以在测试用例中运行那个原先包含了业务逻 辑的方法了。这不能不说是一个积极的进展。

SymbolSource 类是一个具体类，它代表着创建另一个窗体并从其获取信息的决策。然而， 我们之所以将它起名为SymbolSource,  是因为从AccountDetailFrame  的角度来说该类的工作 只是通过它所认为必要的方法获取到某些符号形式的信息。如果symbolSource    演化成了一个接 口我也肯定不会感到惊讶，只要背后获取信息的途径'改变了便可能会出现这一情况。

本例中我们采取的步骤是很常见的。在有重构工具可用的情况下，很容易就可以对一个类进行方法提取，然后将方法分组，以便可以放到新类中去。 一个好的重构工具能够判断你想要进行 的自动方法提取是不是安全的，如果不安全便不会予以进行。然而，这只会令我们进行的其他修 改成为工作中最危险的部分。所以说，记住，如果目的是为了让测试能够安置到位的话，提取出具有糟糕名字或糟糕结构的方法是可以接受的。毕竟，安全才是第一位。在测试到位之后，就可以放心着手让代码变得更清爽了。

***
1.如不再通过窗体+用户输入的方式，而是通过网络或数据库来获取，等等。——译者注
***
