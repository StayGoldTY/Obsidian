一个开发周期很长的应用会越来越复杂臃肿。 一开始的时候它或许还拥有设计良好的架构， 然而几年之后，在进度的压力之下，其结构或许就复杂到没人能够真正理解的地步了。人们在一 个项目上投入好几年的时间，却仍可能根本不知道新的特性应该放在哪里；他们只知道最近系统 中哪儿又进行了毫无章法的修改 (hack) 。 在添加新特性的时候，他们就会去找那些进行修改的 地 方 (hack     point),  因为那些才是他们最了解的地方。

对于这类情况，并没有什么轻而易举的解决办法，况且事情也分轻重缓急；
比如有时候项目 组里的程序员撞了南墙，发现没法往系统里添加新特性了，然后整个项目组上上下下就立即如临 大敌一般。
于是有人便被临危授命，要去分析出当前到底是该对系统重新架构还是推翻重写。另 一方面，对于其他一些团队来说，可能在几年的时间里系统都是磕磕碰碰地前进的。
这种情况下添加一个新特性往往需要更长的时间，但人们只当这是必要的成本。没人知道项目因这种糟糕的代码结构损失了多少钱，没人知道代码的结构能够改善到什么程度。

如果一个团队不了解他们的代码的架构，后者就会变得越来越糟糕。那么,到底是什么东西 阻碍了一个团队去了解他们的代码架构呢?

+ 系统可能过于复杂，要想对它有一个整体认识需要花很长时间。

+ 系统可能过于复杂，乃至于根本没有所谓的整体认识。

+ 整个团队就像绷紧的弹簧一样，光顾着埋头解决一个又一个的紧急情况，根本无暇顾及什么整体认识了。

传统上，许多团队会使用架构师这一角色来解决这些问题。通常架构师的任务就是掌控全局， 为团队作出能够维持系统整体架构不变的决策。
其实这种利用架构师的做法也不是不行，只是有 一个需要特别注意的地方，那就是架构师必须得跟团队的其他成员打成一片，否则代码就会逐渐偏离主航向。
有两种情况可能会导致这一结果的发生：
其一就是有人可能会对代码做一些不当的改动，
另一种可能就是“主航向”本身需要调整。
在我所遇到过的最糟糕的情形当中，就曾经出现过这样的事情：系统在架构师跟小组中的其他程序员眼里完全是不同的样子。发生这种事情通常是因为架构师有其他职责，从而无法参与编码或跟团队的其他成员交流来弄清楚系统最近的改变。结果团队的交流整个就无法进行了。

一个残酷的事实是，架构师不是少数人所专有的，而必须是大家的，因为这个角色太重要了。 有架构师固然是件好事，但要想发挥架构师的最大作用，关键还是要看团队的成员是否能够清楚

  架构师到底意味着什么,并能夠感到架构师是跟他们休戚相关的一个角色。每一个接触代码的人 都应该了解架构，而其他每一个接触代码的人都应该能够从刚才那个人所学到的东西那儿获益。 
  如果团队里的每个人都有共同的想法，那么整体的力量就会大大增強。如果你有一个20个人的团 队，其中只有3个人了解架構细节，则要么这3人需要多做许多额外的工作来讓其余17人都能夠跟上，要么就等着其余17人因对大局不熟而犯错误吧。

那么,我们怎样才能获得对一个大型系统的整体认识呢?方法很多。Serge Demeyer、Stephane_Ducasse__和__Oscar  M.Nierstrasz__合著的__Object-Oriented  Reengineering  Patlerns(Morgan__Kaufmann__出_版，2002)一书'中就包含了一组用来解决这些问题的技术。这里我再介绍几个相当强大的技术。 如果你常在团队里实践这些技术，就会发现它们能夠使你的團队始终保持对架构的关注，对于架  构的维持来说，或许没有什么比这个还要重要了。因为通常我们很难对不常想到的事情保持关注。

**17.1** **讲述系统的故事**

在跟团队共事的过程中，我常常会使用一种手法，我把它叫做“讲述系统的故事”。
要成功实施这一手法至少需要两个人。像唱双簧那样， 一个人开始问，“該系统的架構是怎样的?”然 后另一个人就回答，他应该尽量只使用两到三个概念就把系统的架構解释清楚。如果你就是那个负责解释的人，那么就假设另一方对该系统一无所知。
你用寥寥数句就解释清楚系统的设计由哪些部分构成以及它们之间是如何进行交互的。通过这寥寥数语，你就清楚地解释了这个系统最为本质的东西。接下来再选第二重要的方面来讲述。就这样， 一直到你们把有关这个系统的核心设 计的所有重要的方面都说明白了为止。

但一开始的时候你可能会感覺有点别扭。因为要想真正简潔地将系统的架構表述出来，就得 简化你的语言。你可能会这样说，“网关从活动数据库那兒获取规则集”,然而这时候你可能会听 到内心的一个声音在大喊，“錯!它不是还会从当前工作集那儿获取规则集嘛。”所以说当你用简 化了的方式来表达的时候，你可能会感覺自己在撒谎似的，因为你覺得自己并没有把事情说全面。 但是别忘了，你讲的这个简化版本能够描述一个易于理解的架構。比如说为什么网关要从不止一 个地方获取规则集呢?统一对待不是更简單吗?

一些实际考虑常常会把事情弄得复杂化，但把复杂的东西看得简单起来仍然还是有价值的。 至少它能够帮助每个人理解理想的系统会是什么样子的，以及哪些东西是作为权宜之计加进去 的。该做法的另一个重要的作用就是，它能强迫你去思考系统当中重要的东西是哪些，要传达和 交流的最重要的东西又是哪些?

如果一个团队连他们面对的系统都搞不清楚的话，可想而知是走不了多远的。从某种意义上 来说，了解关于系统如何工作的简單“故事”就像是有了一个路标一样，当你想要弄清哪兒才是 添加一个特性的正確地点时它能够幫你指明方向。而且，它还能够消除你对系统的畏惧感。

所以说，尽量经常讲讲你们系统的故事吧，让你的团队成员之间能够时时保持对系统的共识。

并且试着以多种不同的方式来讲述。权衡两个概念哪个更为重要。在考虑对系统的修改时，你会注意到其中有些修改与你们讲述的故事更为一致。也就是说他们令你讲述的那个简化版本的故事 更接近真实。如果达到一个目标有两种方式，而你需要在这两者之间选择其一，那么系统的故事 就能够帮助你判断出哪种方式能够导向一个更易理解的系统。

下面就是一个有关的例子，它描述了这种“讲述系统的故事”的做法是如何运用的。这是一 个关于JUnit的会议讨论，我假定你了解一点关于JUnit架构的知识，否则建议你先花一点时间阅 读JUnit的源代码(从wwwjunitorg  下载)。

![](file:///C:\Users\TY\AppData\Local\Temp\ksohtml32088\wps93.png)

我们把上面这段描述所省掉的东西一一列出来：

(1)JUnit中还有许许多多其他的类。之所以说Test 和TestResult 是重要的只是因为我认为它们是重要的。对我来说它们之间的交互是系统当中最重要的交互。其他人可能会对架构有一个 不同但同样有效的认识。

(2)用户并不负责创建测试对象。测试对象是通过反射从测试用例类创建出来的。

(3)Test 并不是一个类，而是一个接口。JUnit中运行的测试通常是在一个名叫TestCase 的 类的子类中写的，TestCase 实现了Test 接口。

(4)人们通常并非主动向TestResult 对象询问失败情况。TestResult 可以接收监听对象的 注册，当TestResult对象从测试那儿收到信息的时候，这些注册的监听对象都会收到通知。

(5)测试除了报告失败之外还报告其他东西：比如运行的测试个数以及错误个数错误(error) 是指那些没有显式检查的问题，而失败 (failure)   则是指你检查了但失败了。

那么,这种简化式描述是否给了我们一些关于JUnit可以怎样简化的启发呢?答案是肯定的。 比如一些较简单的xUnit测试框架会让Test成为一个类，并完全扔掉TestCase。而另一些框架则将  错误跟失败一起考虑，从而以统一的方式来报告它们。

回到我们的故事。

![](file:///C:\Users\TY\AppData\Local\Temp\ksohtml32088\wps94.png)

上面这段话我们又作了多少省略呢?

(1)测试套件并不仅仅是持有并运行一组测试而已。它们还会通过反射来创建派生自 TestCase 的类的实例。

(2)还有一个省略掉的地方，不过这个其实应该算是前面一段关于Test&TestResult  的简 化描述省掉的东西。即测试其实并不运行它们自身，而是把自身传递给TestResult  类，后者再负责调用前者身上负责执行测试的方法。这个回调的过程发生在一个相当低的层次上。所以还不 如把它看得简单一点。虽然这似乎是在隐瞒事实，但其实JUnit早年简单一点的版本里的确是这么 做的。

![](file:///C:\Users\TY\AppData\Local\Temp\ksohtml32088\wps95.png)

其实还可以继续下去。但目前所展示的已经能够让你对JUnit有一定的认识了。我们一开始先 给出一个简洁的描述。当我们通过简化以及剥掉细节的方式来描述一个系统时，其实是在进行抽象。我们往往在逼迫自己对系统作出一个非常简单的描述的时候，会发现新的抽象。

如果系统实际上并不像我们把它简化成的那样，是不是就意味着什么糟糕的事情呢?不是的。 一个系统在不断成长的过程中总会变得越来越复杂。我们的简化描述只是为了给自己引路。

现在假设我们想给JUnit添加一个新特性。想要生成一个报告，汇报有哪些测试在被运行时没 有调用任何断言。那么,基于我们对JUnit的描述，有哪些选择呢?

一个选择是往TestCase类中添加一个叫做buildUsageReport的方法，该方法逐一调用每 个(测试)方法，把其中那些不调用断言的记录下来，建立一个报表。那么,要添加这一特性， 这算是一个好方法吗?它会给我们的系统的故事带来什么样的影响呢?嗯……它会令我们原先 关于系统的简洁描述里面又多出一个“隐瞒的事实”,原先的描述如下：

![](file:///C:\Users\TY\AppData\Local\Temp\ksohtml32088\wps96.png)

现在，看上去Test  类有了另一个完全不同的职责：生成报告。我们可从未提及。

那么倘若我们换种方式来添加该特性呢?我们可以修改TestCase   与TestResult      的交互方 式，让TestResult     在任一测试被运行时获知被调用的断言的数目。然后我们可以创建一个负责 生成报告的类，并把它作为一个监听者挂到TestResult 上面去。以上做法对我们的系统描述又 会有什么样的影响?我们可以把它当成一个不错的动机，把前面对系统的描述表述得更一般化一 点。考虑到Test 对象并不仅仅向TestResult 汇报失败数目，还汇报错误数目、运行的测试数目 以及调用的断言数目，因此我们可以将系统的描述修改为：

JUnit包含两个主要的类。 一个叫Test, 另一个叫TestResult。  用户创建测试并运行它 们，同时传递一个TestResult 给它们。测试运行时会把与它该次运行有关的信息传递给TestResult对象。人们于是可以通过询问TestResult  对象来获得所有有关测试运行的信息。

这样的表述是否好一些呢?坦白地说我倒还是倾向原来的，即那个用“失败”(而不是“信 息”)字眼的版本。对我而言，这是JUnit的核心行为之一。如果我们修改代码让TestResult  来 记录运行的断言的个数，则我们的描述虽说还是不太符合事实，但我们本就已经省略了对从Test  发送到TestResult  的其他信息的具体描述。然而刚才提到的另一个策略，即让Testcase 类去负责运行一堆用例并生成关于调用断言的报告，与事实就更为不符：我们在描述里面压根就没有 提到restCase 的这个新职责。所以说，还不如就让测试在运行的时候报告它们所执行的断言数。 我们的第一版描述虽说一般化得有点过，但至少是充分正确的。这意味着我们的修改跟系统的架 构更一致。

**17.2**  **Naked** **CRC**

在面向对象理论发展的早期，许多人都曾在设计问题上有过痛苦的经历。对于大多数编程经验都是来自过程式语言的程序员来说，要想习惯面向对象不是件容易的事。简单地说就是你思考代码的方式被改变了。我还记得自己头一次“面向对象”的时候，有人把一张画了面向对象设计 的纸给我看，我看着满纸的圆圈和线条，听着那人的描述，脑子里只想着问一句话 “main()    到 哪儿去了?这些所谓的对象总得有一个入口点吧?”有那么一会儿我是一头雾水，但没多久就开 始上手了。不仅仅是我有这个问题，那一段时间业界的大部分人基本都遭遇到了这个问题。而且 每天都有新手加入这个行列，他们在第一次遇到面向对象代码的时候都得面对这些问题。

Ward Cunningham和Kent Beck在20世纪80年代对这个问题下了工夫。他们想帮助人们学会用 对象来思考设计。那段时间Ward正使用着一个名叫Hypercard 的工具，这个工具让你在计算机屏 幕上创建卡片，并在卡片之间建立连接。于是，Ward 脑子里灵光一闪：干嘛不干脆使用真正的索引卡片来表示类呢?这将使得我们能够并容易地去谈论这些类。“我们来谈谈那个事务类吧?” “好啊，给，这是它的卡片，上面写着它的职责和与它交互的类。”

“CRC” 这一缩写表示“类(Class)”、“ 职 责 (Responsibility)”和“协作(Collaboration)”。 每一个卡片都被标上对应类的类名、职责以及与它交互的类(协作类)。如果你觉得某个职责并 不属于某个类，可以把它从相应卡片上划掉，并写到另一个(它应属的那个)类的卡片上，或者 新增一个类卡片。

CRC 方案很是流行了一阵子，但最终人们还是纷纷呼唤以图方式来表达；因为几乎每一个教 面向对象的人都有自己的一套表示类和关系的记号。于是最终人们不得不花好几年的时间来统一 记号表达。
UML就是这样诞生的，许多人都觉得UML 的出现终结了人们关于如何设计系统的争论。人们开始觉得记号是手段，而UML 是开发系统之道：画大量的图，然后编写代码。过了好 一段时间人们才明白过来，发现尽管UML 用在文档化系统方面不错，但在表达和讨论我们用于 构建系统的概念方面，它并不是唯一的手段。现在我们知道，在团队中传达有关设计的概念还有 一个更好的办法，我的一些做测试的朋友把它称为 “Naked     CRC”,  因为除了不是把东西写在卡片上之外，它几乎跟CRC 一样。只不过遗憾的是，要用文字来描述它不是那么容易的。下面我尽 量试图把它讲清楚

我是在几年前的一个会议上遇到Ron Jeffries的。当时他答应给我展示如何使用卡片来解释系 统架构，并称他的方法可以使整个交流的过程生动且令人印象深刻。当然，后来他的确做给我看 了。现在我再把这个方法传达给你，它是这样的：负责描述系统的那个人使用一组空白的索引卡 片，把它们一个个摊在桌上。他可以作移动或指向卡片等动作，反正目的是通过这些卡片来传达 系统中的典型对象以及它们之间是如何交互的。

下面是一个例子，是对一个在线投票系统的描述。

“下面我来描述一下这个实时投票系统是如何工作的。这是一个客户端会话。”(指着相应的卡片说)

![](file:///C:\Users\TY\AppData\Local\Temp\ksohtml32088\wps101.jpg) 

“每个会话上都有两个连接， 一个接入， 一个接出。”(动作：把两个卡片分别放到刚才那个 卡片上，指一下它们)

![](file:///C:\Users\TY\AppData\Local\Temp\ksohtml32088\wps102.png) 

“开始的时候，服务器创建一个会话，这儿。”(动作：把一个卡片放在右边)
![[Pasted image 20240523141153.png]]

“每个服务器会话也都有两个连接。”(把表示连接的两张卡片分别放好)
![[Pasted image 20240523141222.png]]

“当一个服务器端会话发起时，它会向选票管理器注册。”(把代表选票管理器的那张卡片摊 在服务器会话卡片的上方)
![[Pasted image 20240523141246.png]]
“服务器端可以有许多会话。”(再用三张卡片来代表一个新的服务器端会话和它的连接)
![[Pasted image 20240523141304.png]]
“客户端在进行投票时，选票被发送到服务器端的会话那里。”(用手指向客户端会话上的一 个连接，然后在空中划一道线，到服务器端会话的一个连接那里)

“服务器端会话回复一个确认信息，然后用选票管理器记录下选票。”(用手从服务器端会话 指向客户端会话，再从服务器端会话指向选票管理器)

“然后，选票管理器再叫每个服务器端会话去告知它们各自的客户端会话最新的选票数目。” (依次从选票管理器指向每一个服务器端会话)

当然，以上的假想场景肯定不全面，因为如果我们是真的一块儿坐在桌前的话，我就可以在  桌上移动卡片，或者按我喜欢的方式来用手指着或操纵它们。但无论如何，该技术是相当强大的。 它使得一个系统的各部分成为真实可触摸的东西。关键在于，借助卡片，你可以使用肢体动作来 表达系统的各部分之间是如何交互的。这往往能令复杂的场景变得更易掌握。由于某些原因，这些借助于卡片的交流也更令人印象深刻。

“Naked    CRC” 在使用的时候有两条原则：

(1)卡片代表实例，而非类；

(2)用叠在一起的卡片来表示“一组实例”。

**17.3**  **反省你们的交流或讨论**

在对付遗留代码时，我们一般都不愿看到系统里面再出现新的抽象了。在面对四五个类，其中每个都具有大约一千行代码的时候，除了竭力试图搞清哪些地方得修改之外，我想谁也不会愿 意再去往里面塞两个新类。

正因为我们在考察系统的时候瞻前顾后束手束脚，所以往往会错过一些能够给我们额外启发 的地方。例如，我以前曾有一次跟一个团队的几个成员共事，他们那时正试图使一块规模不小的 代码能够被多个线程调用执行。代码相当复杂，而且有好几处可能会导致死锁。我们意识到如果 可以保证资源按照特定顺序被加锁和解锁的话，代码中的死锁就可以避免。于是便开始思考怎样 修改代码才能使之成为可能。接下来的时间我们就一直在讨论这一新的资源加锁/解锁策略，并想办法用数组来保存(锁)计数。当其他程序员中有一个人开始直接往既有代码中插入为该策略 编写的代码时我说：“等等，不就是锁策略吗?干嘛不创建一个LockingPolicy 类，然后在它里 面维护计数器呢?我们可以用恰当的方法名来描述我们想要做的事情，这可比在数组里保存计数 清楚得多。”

这件事情的可怕之处在于，该团队并不是毫无经验的团队。代码基中一些其他地方的代码也 有很漂亮的，但大块大块的过程式代码仿佛对人有种催眠的魔力：吸引人再往里面加代码。

听听那些关于你们的设计的讨论。你们在交流过程中使用的概念与实际出现在代码中的概念 是一样的吗?我觉得肯定不尽然。实际编码可不像纸上谈兵那样只要意思到了就行，而是需要满足更强的约束，但若是在交流与实际编码之间没有一个牢固的共性，就得问问为什么了。
实际上 答案往往由两部分构成：代码不允许被修改成跟团队的理解一致的样子，或者团队需要换个角度 去理解它。不管哪种情况，与人们自然地用来描述设计的概念保持一致是一个强有力的做法。人们在谈论设计时会努力试图让其他人理解被谈论的设计。放一些理解在代码里面吧。

本章描述了一系列的技术，这些技术可以用来揭示并传达大型系统的架构。其中许多技术也 完全可以用于交流或讨论新系统的设计。
记住，设计就是设计，不管它发生在开发周期中的哪一 个环节。
人们会犯的最糟糕的错误之一便是认为到了开发周期的某个阶段设计也就宣告死亡了。 
如果设计“已死”而人们却仍在修改的话，很可能就会把新的代码放在糟糕的地方，类会膨胀， 因为没人会对引入新的抽象感到舒服。
唉，如果你想把一个已是“遗留”的系统搞得更糟的话， 以上方式真是再合适不过了。