本章将要讨论的是一个困难的问题。如果在测试用具中实例化一个类总是那么容易的话，本 书也就会简短得多了。遗憾的是情况并非如此。

下面就是我们会遇到的四种最为常见的问题(其中“该类”代表我们所针对的问题类): (1)无法轻易创建该类的对象。

(2)当该类位于测试用具中时，测试用具无法轻易通过编译构建。

(3)我们需要用到的构造函数具有副作用。

(4)构造函数中有一些要紧的工作，我们需要感知到它们。

![](file:///C:\Users\TY\AppData\Local\Temp\ksohtml32088\wps38.png)本章我们将会看到一系列的例子，这些来自不同语言编程环境下的例子展示了上面提到的这 些问题。实际上，每个问题都不止一种解决方案。不过，要熟悉一大堆解依赖技术，学习如何在 它们之间进行权衡，以及如何在特定场合下运用的话，通过这些例子来学习是极好的途径。

**9.1** **令人恼火的参数**

当需要在一个遗留系统中作修改时，我通常是以一种轻松乐观的心态开始工作的。我不知道 为什么。虽然一直试图让自己尽量变得更现实一些，但总会存在那么一点儿乐观情绪。“嗨，”我 对自己(或工作伙伴)说，“这听起来蛮简单的，我们只需把这个类这么处理一下就成了。”然而， 虽然嘴上说得简单，当正儿八经打开那个类时却发现……“好吧，看来我们需要在这儿添加一个 方法，并修改这儿的另一个方法。当然，我们还得把它放入测试用具。”直到这时我才开始有点 怀疑。“唉……看来这个类就连最简单的构造函数也接受3个参数嘛，不过……”我乐观地安慰自 己，“也许构造起来并没那么困难。”

让我们来看一个具体的例子，看看到底我的乐观是有道理的还是自我安慰。

在一个计费系统中，我们有一个未测试的Java类 ：Creditvalidator。
![[Pasted image 20240523083647.png]]该类的众多职责之一便是告诉我们某个客户是否有足够的余额。是则返回一个认证，告诉我 们该客户的余额到底是多少。否则抛出一个异常。

而我们的任务(如果我们选择接受该任务的话)则是往该类中添加一个新方法。这个方法将 被命名为getvalidationPercent,   其职责是告诉我们在一个creditValidator  对象的生命周 期中对validateCustomer()  的调用的成功率。

那么,我们该怎么做呢?

如果需要看看能否在测试用具中创建一个对象，最佳做法就是试一试。我们当然可以通过一

**系列的分析来确定在测试用具中创建某个类的对象容易与否；不过还有一个方法同样轻而易举， 即创建一个JUnit测试类，并将下面的代码填到里面然后编译：

```
public void testCreate() {
	Creditvalidator validator = new CreditValidator();
}
```

![](file:///C:\Users\TY\AppData\Local\Temp\ksohtml32088\wps39.png)

以上测试是个构造测试。构造测试看起来的确有点怪异。编写这类测试时我通常并不在里面 放置任何断言，而只是试着创建对象。最后，当终于能够在测试用具中构造某类的对象时，我通 常会删掉该测试，或将它重命名以便能够用来做一些更为实质性的测试。

返回到我们的例子

在上面那个简单的testCreate 方法中，我们在创建creditvalidator对象时并未向它的  构造函数提供任何实参，因此编译会报错。错误消息会说creditvalidator 没有默认构造函数。

于是我们翻开creditvalidator的代码 一 看，发现其构造函数需要3个参数：  一 个
RGHConnection、 所示：
![[Pasted image 20240523083753.png]]

RGHConnection 在构造时会连接到一个服务器，这个连接被用来从服务器获取必要的信息 以检查客户的余额。

另一个类creditMaster,  则提供了一些我们在检查余额的过程中会用到的策略信息。creditMaster 的构造函数会从一个文件中加载相关信息，并把这些信息保存在内存中以备后用。
这么看来，把这个类放入测试用具的确是举手之劳，对不对?别这么快下结论。虽说我们的确可以为它编写出一个测试来，但我们能否忍受这个测试的速度呢?如下所示：
![[Pasted image 20240523083920.png]]
看起来，在测试中建立到服务器的RGHConnection 并不是个好主意。首先其耗时就比较长， 况且服务器也并不总是处于服务状态。相比之下creditMaster倒不算什么问题了。 CreditMaster在创建时会加载一个文件，而这个过程比较快速。况且它所加载的文件还是只读 的，这就确保了我们无需担心它被测试程序破坏掉。
真正妨碍我们顺利创建creditValidator对象的其实是RGHConnection 。这是个令人恼火的参数。
我们的设想是：若能够创建某种伪造的RGHConnection 对象并使creditValidator相信它是一个真正的RGHConnection 的话，就可以避开所有的连接问题了。所以，让我们来看一 看RGHConnection 所拥有的方法(如图9-1所示):

|                                                                                                                                                                                                                      |
| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **RGHConnection**                                                                                                                                                                                                    |
| **+RGHConnection(porl,name,passward)** **+connect()**<br><br>**+disconnect()**<br><br>**+RFDIReportFor(id:int):RFDIReport**<br><br>**+ACTIOReportFor(customerlD:int)ACTIOReport** <br><br>**-lormPacket():RFPacket** |
| **-retry)**                                                                                                                                                                                                          |

图9-1 RGHConnection

看上去RGHConnection 中有一些方法是用来处理与连接相关的任务的：如connect、
disconnect 以 及retry 。  
另外还有 一 些与业务相关的方法，如RFDIReportFor   和 ACTIOReportFor 。 前面曾提过，我们的任务是往CreditValidator 中添加一个新方法，用于 获知在一creditvalidator  对象的生命周期中它上面的validateCustomer()调用的成功 百分比，为此得调用RFDIReportFor 来获取我们所需要的一切信息，通常所有这些信息都是来
自服务器的，所以，如果我们想如刚才所言伪造一个RGHConnection  的话，就必须想办法让那个伪造的RGHConnection 也能提供这些信息。

在这些条件之下，伪造一个RGHConnection  的最佳方法是对RGHConnection类应用接口提取。如果你手头有一个支持重构的工具，那么它很可能也会支持接口提取手法。如果没有支持这 108    一手法的工具的话，别担心，自己动手也同样简单。

在对RGHConnection  运用接口提取技术之后，我们最终得到了如图9-2所示的结构：

![](file:///C:\Users\TY\AppData\Local\Temp\ksohtml32088\wps40.png)

图9-2 接口提取后的RGHConnection

至此，我们便可以创建一个轻便的FakeConnection  类，并使它能够提供我们所需的反馈信 息，然后将这个伪造的“RGHConnection” 用在测试中：
![[Pasted image 20240523084833.png]]

FakeConnection 类看起来有点古怪：它的方法要么是空的要么就是简单地返迴null。这种 情形并不常见。更糟的是，它有一个任何人都可以看到并随意设置的公共变量。这样一个类似乎 违反了所有的良好准则。但你要看到，实际上并非如此。对于一个用来使得测试可行的类，规则 是有所不同的。FakeConnection    中的代码并非产品代码。它永远也不属于最终投入运行的应用， 而只是为了测试用具而诞生的。

现在，既然我们已经可以创建一个creditValidator, 那么便可以开始编写它的 getValidationPercent 方法了。在这之前我们先編写其测试，如下所示：
![[Pasted image 20240523085019.png]]![](file:///C:\Users\TY\AppData\Local\Temp\ksohtml32088\wps41.png)

以上测试检查creditValidator 对象在验证了一个具有足够余额的客户之后其验证成功率 是否约为百分之百。

这个测试工作起来没问题，但随着我们真正开始编写getValidationPercent,            却发现一 些有趣的现象。似乎getValidationPercent  并不需要用到creditMaster,         既然这样，当我 们在测试用例中创建creditvalidator 对象时为什么还要提供一个creditMaster 呢?或许并 不一定要这么做。我们可以像这样来创建测试用的creditValidator对象：

```
CreditValidator validator =new CreditValidator(connection,null, "a");
```

是不是很麻烦?
人们对于上述代码的反应往往很能体现出他们对付的是一个什么样的系统。比如一种反应是   这样的：“好吧，也就是说他将一个null传递给了这个构造函数——我们在系统中就经常这么做。”

这种人很可能对付的是一个相当糟糕的系统。
系统中可能到处都是针对null的检查，另外还有许多条件代码用于判断某些引用到底引用的是什么以及能用来做什么。
另一种反应则是这样的：“这 家伙到底怎么了?!竟然在一个系统中把nul 传来传去?到底有没有知识啊?
”呃……如果你属 于后一种人(或者至少你读到这里还没有把书狠狠合上并扔回书店的书架上),请听我一句善意 的辩解：别忘了我们只是在测试中才这么做。可能发生的最糟糕的事情就是某些代码试图去使用 我们传递的null,  如果这真的发生的话， Java运行时便会抛出一个异常。又由于测试用具能够捕 获测试当中抛出的任何异常，所以最终我们很快就会发现参数是否被使用了。

![](file:///C:\Users\TY\AppData\Local\Temp\ksohtml32088\wps42.png)

当我使用Java语言来工作时，通常一开始编写的测试是像下面这样的，然后根据实际情况需 要决定是否把其中的null替换成有血有肉的对象。

```
publicvoid testCreate()(
CreditValidator validator  =new CreditValidator(null,null,"a");
}
```

**关键要记住一点：不到万不得已千万别在产品代码中传递null。我知道现在有些库会期望你 在某些情况下传递null,  这是无法控制的事情，但当编写自己的代码时，请务必记住还有更好的

选择。如果忍不住想在产品代码中使用null,   那么建议你找出所有返回null或传null的地方，并考 虑采用另一种协议。比如，考虑使用空对象模式 (Null  Object Pattern)。

![](file:///C:\Users\TY\AppData\Local\Temp\ksohtml32088\wps43.png)

就迫使调用方显式地去处理这个异常；另一个选择便是返回mull, 但这么一来调用方就必须显 式检查其返回值是否null.

但其实我们还有第三个选择。回顾上面的示例代码，这段代码真的关心是否存在一个需要 支酬的雇员吗?另外它是否必须得关心这个呢?如果我们新添一个叫NullEmployee 的类  怎么样? Nul1Employee 的对象相当于一个既没有名字也没有地址的雇员，当你向他支酬时  (调用其pay() 方法),什么也不会发生。

空对象模式在这类情况下就可以派上用场了；它们可以免除让调用方进行显式错误检查的 烦恼。不过，虽说这个模式不错，但用的时候也得小心。例如，下面这段代码试图计算已被支 酬的雇员人数，而事实上这样做是非常糟糕的：
![[Pasted image 20240523085808.png]]在上面的循环中， 一旦获取到的是空雇员，最终的计算结果就会是错误的。

当调用方无须关心某个操作是否成功时，空对象模式尤其有用。而许多时候我们又都可以 通过对设计进行一些巧妙的处理从而使其符合这个前提。

传Null和接口提取(285页)是两种可以用来解决恼人的参数的途径。但有时我们也可以使 用另一个方案，如果一个参数类型中的问题依赖并不是被硬编码在其构造函数中的话，就可以使 用子类化并重写方法 (Subclass and Override Method,314页)来对付该依赖。比如在上面的例子 中这一方案就是可行的。如果RGHConnection 的构造函数使用了它的connect() 方法来建立一 个连接的话，我们就可以通过在RGHConnection 的一个为测试而造的子类中重写其connect()  方法来解开依赖。子类化并重写方法在有些场合下是非常有用的解依赖手段，但在使用的时候我 们得注意别把想要测试的行为给篡改了。

**9.2**  **隐藏依赖**

有些类是具有欺骗性的。比如我们发现它上面有一个构造函数是我们想要使用的，然后试图 去调用这个构造函数。结果，砰的一声!我们撞上了一块石头。而这块“石头”最常见的可能就 是隐藏依赖；比如构造函数中使用了一些我们在测试用具中根本无法很好地访问到的资源。下面 就是一个有关的例子，这是一个设计得很糟糕的C++类，它负责管理一个邮件列表：
![[Pasted image 20240523090001.png]]下面是该类的构造函数的部分代码。它先是在构造函数的初始化列表中new 了一个 mail_service      对象。这是个差劲的编码风格，而且还不止这些。这个构造函数后面又用这个 mail_service      对象做了很多细节的工作。此外它还使用了一个所谓的“魔数”——12,这里12 究竟代表什么意思?
![[Pasted image 20240523090033.png]]我们可以在测试中创建该类的对象，但或许这么做没什么好处。首先，需要连接到邮件库， 并配置邮件系统以便进行注册。而且倘若我们在测试中使用send_message 函数，就会真的给某 个人发邮件了。所以很难自动地对该功能进行测试，除非我们配置一个特殊的邮箱，然后不断重  复登录它，看看邮件消息是否已到达。如果我们要做的是一个整体的系统测试，那么这样做没问 题，但如果我们只是想往该类中添加一些经过测试的新功能的话，这么做就未免太小题大做了。 我们只是想创建一个用于测试的简单对象，以便添加一些新的功能而已，如何才能达到这一目 的呢?

根本问题在于对mail_service 的依赖被隐藏在了mailing_list_dispatcher 这个构造

函数中。如果有办法把那个mail_service对象替换成一个伪对象的话，就可以通过这个伪对象 来进行感知，并在修改过程中获取一些反馈信息了。

这里可以采用的一个技术是参数化构造函数 (Parameterize Constructor,297页)。运用该技 术，可以将一个藏在构造函数中的依赖“外在化”,即让它以参数的形式从外面传进来。

下面就是对mailing_list_dispatcher的构造函数运用参数化构造函数的结果：
![[Pasted image 20240523090154.png]]
实际上这里面唯一的区别就在于现在mail_service  对象是在外面创建并以参数的形式传 递进来的了。看上去这可能算不上多大的改进，但它的确给了我们不可低估的优势。现在便可以使用接口提取技术来给mail_service提取一个接口了。该接口的实现之一是一个真正会发送邮件的产品类，而另一个实现则可以是一个“伪造的”类，它的作用只是在测试时感知我们对它所 做的动作，让我们确信这些事情都发生了。

利用**参数化构造函数技术**，可以很方便地将构造函数中的依赖外在化，但人们却常常想不到使用它。
一个原因是人们往往会认为随着某构造函数中的依赖被外在化，它的所有调用方都得进行相应的改动，以便传递新的参数。
但实际上这种想法并不正确。
我们可以解决这个问题：首先将构造函数的函数体提取到一个新的方法initialize中。跟大多数的方法提取有所不同，这一提取在 没有测试保护的情况下也是相当安全的，因为我们可以在提取时运用签名保持(249页)技术。
![[Pasted image 20240523090445.png]]
现在，我们可以额外再提供一个跟原先的签名一模一样的构造函数(如下所示)。于是，在测试时可以调用具有mail_service参数的那个构造函数，而其他客户代码则调用那个签名跟原 先 一 样 的 构 造 函 数 ， 这 么 一 来 客 户 代 码 便 可 以 维 持 原 样 ， 无 需 关 心 我 们 作 了哪 些 改 动 。
```
mailing_list_dispatcher::mailing_list_dispatcher()
{
	initialize(new   mail_service);
}
```
这种重构在像C#和Java这样的语言中甚至更为容易，因为这些语言支持在一个构造函数中调 用另一个构造函数。

例如，假设我们要在C#中完成类似的工作，结果代码可能看起来像这样：
![[Pasted image 20240523090818.png]]
有多种技术可以用来克服隐藏在构造函数中的依赖。通常我们可以使用提取并重写获取方法 (Extract and Override Getter,278页)、提取并重写工厂方法 (Extract and Override Factory Method, 276页)以及替换实例变量 (Supersede Instance Variable,317页),但我比较倾向于尽可能地使用 参数化构造函数。当一个构造函数在它的函数体中创建了一个对象，并且该对象本身并没有任何构造性依赖时，运用参数化构造函数就比较轻松了。

**9.3** **构造块**

参数化构造函数在解开构造函数中隐藏的依赖方面是一项易用的技术，而且它往往也是我第 一个诉诸的技术。然而遗憾的是，它并非总是最佳选择。如果一个构造函数中创建了大量的对象， 或者访问了大量的全局变量，采用这一技术可能最终会导致一个非常长的参数列表。最糟糕的是， 某个构造函数可能会先创建一些对象，然后使用它们来创建另一些对象：
![[Pasted image 20240523092002.png]]
如果想要通过cursor   变量进行感知的话，我们就遇到麻烦了。 cursor   对象被嵌在一系列的 对象创建中。我们可以尝试将所有用于创建cursor   对象的代码都移至类外面，让客户代码去创 建cursor 并将它作为参数传递给该类。但这么做没有测试保护的话不是很安全，而且还可能会给该类的客户代码带来不小的负担。
如果有一个能够安全地提取方法的重构工具，我们就可以对构造函数中的代码运用提取并重写工厂方法(276页)手法了，然而这一做法也并非在所有语言中都可行。
在Java和C#中没问题， 但C++中就不同了，因为在C++ 中，构造函数中对虚函数的调用是不会被决议到派生类的相应虚 函数上去的。况且一般来讲这也并不是个好主意，因为派生类中的虚函数往往会认为它们可以使用 基类的成员变量，所以倘若在基类的构造函数完全结束之前，其派生类中的虚函数被调用起来并且 后者试图去访问基类中的某个成员变量的话，很可能它访问到的就会是一个未初始化的变量。
还有一个选择，便是采用替换实例变量(317页)手法。我们为这个类编写一个设置方法， 该方法允许我们在对象构造完毕之后替换掉其中的某个成员变量。
![[Pasted image 20240523092144.png]]在C+  中进行这类重构时得非常小心。在替换掉一个对象之前，得先将旧的对象处理掉。通常这就意味着使用删除操作符来调用其析构函数并释放其内存。这么做的时候我们得清楚该析构函数会做些什么事情以及它是否会销毁某些当初传递给该对象的构造函数的东西'。如果我们在 清理内存的时候不小心的话，就可能会引入一些难以察觉的bug。
而在大多数其他语言中，替换实例变量手法则是相当直观的。下面就是上例在Java中的版本。 我们无需操心cursor原先指向的对象，垃圾收集器会负责将其回收。但我们得非常注意的是别在 产品代码中使用这一技术，因为如果被替换的对象管理了某些资源的话，替换它们就可能会导致 一些严重的资源问题。
![[Pasted image 20240523092223.png]]

现在，既然我们已经有了一个替换方法 (supersedeCursor),          便可以试着在类的外部创建 一个FocusWidget, 然后在该对象构造完毕之后通过这个替换方法把它传递进去。又因为我们需要进行感知，所以可以对FocusWidget 使用接口提取或实现提取，然后创建其伪对象传递进去。显然，这个伪对象的创建比起前面的在构造函数中创建FocusWidget 的过程要简单多了。
![[Pasted image 20240523092326.png]]
除非万不得已，否则我是不愿使用替换实例变量手法的。这一做法很可能带来一些资源管理 方面的问题。不过在C++中的有些场合下我还是会使用它的。由于我常常想要使用提取并重写工 厂方法，而在C++ 中这一技术又是无法用在构造函数中的，所以有时我只能改用替换实例变量作 为替代方案了。

**9.4**  **恼人的全局依赖**

多年来业界人们一直抱怨市面上没有更多的可复用组件。随着时间的推移，这种情况也在逐 渐好转，市面上已经出现了大量商业的和开源的框架，但总体上，它们中的许多其实并不是在被 我们使用，而是我们的代码在被它们“使用”着。框架通常会管理一个应用的生命周期，而我们 则是往框架的空档之中填塞代码。这一点在各种框架中都能看到，从ASPNET到Java Struts。甚 至xUnit这样的框架也如此，我们编写测试类，而xUnit则负责调用这些类并显示结果。

框架解决了许多问题，而且它们也的确能在项目开始时助我们一臂之力，但这并非人们所真正期盼的那种复用。
旧风格的复用是这样的：我们发现一些类或一组类是我们想要用在项目中的， 于是便这么做了：将它们添加到项目中，并使用它们，就这么简单。
如果这种情形能够成为日常程序的话倒是不错，但坦白的说，通常我们连把一个类从它所在的项目中挖出来并在测试用具中单独编译它都无法轻松做到，既然如此，也就根本不用奢望这种复用了。
有各种各样的依赖可能会令我们难以在测试框架中创建并使用一个类，其中最难对付的依赖之一便是全局变量的使用。简单的情况下，我们可以使用参数化构造函数(297页)、参数化方法 (301页)以及提取并重写调用(275页)这三种技术来对付这些依赖，但有些时候对于全局变量 的依赖是如此的广泛，以致于从根本上解决问题倒成了较容易的途径。下面的例子就展示了这种情况，这是一个Java类，其作用是记录政府机构颁发的建筑许可。下面就是其中一个主要的类：
![[Pasted image 20240523092640.png]]以上测试代码能够通过编译，但我们开始编写其他测试时便会发现一个问题：Facility的构造函数使用了一个名为PermitRepository的类，为了将我们的测试条件设置妥当，必须使用一个或一组许可证 (permit)  来初始化这个全局的PermitRepository 。   下面就是Facility 构造函数中的相关语句：
```
PermitassociatedPermit =PermitRepository.getInstance().findAssociatedPermit(notice);
```
我们固然可以通过参数化构造函数来解决这儿的问题，但整个应用中并非只有此处有这个问 题，另外还有10个类中也有类似的代码。构造函数中有， 一般方法中有，静态方法中也有。可想 而知，不花上一大把时间是没法处理代码基中的这些问题的。

如果你学过设计模式，可能会发现这里用的正是单例模式： PermitRepository  的 getInstance 方法是一个静态方法，其职责是返回该应用中有且仅允许有的那唯一一个 PermitRepository 实例。
持有该实例的变量也是静态的，是PermitRepository 的一个静态成员变量。

在Java当中，单例模式是人们用于实现全局变量的机制之一。通常，全局变量不是个好做法， 原因有好几个方面，其一就是不透明性。当我们查看一段代码时，能够知道这段代码会产生什么 样的影响是件不错的事情。例如，在Java中，当我们想要理解某段代码会产生什么样的影响时， 只需查看几个地方：

```
Account  example  =new  Account();
example.deposit(1);
int  balance =example.getBalance();
```

对于上面这段代码，我们知道一个Account 对象可能会影响我们传递给它的构造函数的参数，但在上面的代码中并没有传递任何参数给它的构造函数。Account  对象同样也可能会影响我们传递给它的方法的实参对象，不过在这里我们并没有传递任何可被改变的东西，只不过是一个 整型数。最后，我们将getBalance    的返回值赋给了一个变量，这其实也应当就是这几行语句所 影响到的唯一的变量了。

然而， 一旦其中涉及全局变量的使用，情况就完全不同了。对于像Account 这样的类，光从它的使用代码上可能怎么也看不出来它在背后是否访问或修改了在程序的其他地方声明的变量。 毫无疑问，这使得我们对程序的理解变得更困难了。

测试过程中一个麻烦的部分就是我们得找出哪些全局变量正在被我们的类使用，并根据测试 需要将它们设置到适当的状态。而且，如果对于不同的测试，设置也不同的话，每个测试开始之 前就都得做一番设置工作。这个过程相当烦人，虽说我在好多个系统上都做过这类事情，但还是 觉得相当枯燥乏味。

回到我们原先讨论的线路上来。

PermitRepository 是一个单件。而正因为它是个单件，所以“仿造”它变得尤其困难。单 件模式的核心理念便是使人们无法在应用中创建一个以上单件类的实例。这在产品代码中或许是 件好事，然而到了测试中可能就成了一场灾难： 一套测试中的每个测试在某种程度上都应当被看成是一个小型的应用，互相之间应当完全隔离开来。因此，要在测试用具中运行一段涉及了单件的代码，就得放松单件性约束。下面就来看看具体是怎么做的。

第一步就是为单件类添加一个新的静态方法。该方法允许我们替换掉该单件类中的那个静态 实例。我们将这个方法命名为setTestingInstance,  如下所示：
![[Pasted image 20240523100811.png]]

有了这个设置方法，便可以创建一个PermitRepository 测试用例并设置它。从而在测试的 setUp()方法中，可以编写如下的代码

```
public    void    setUp(){
	PermitRepository    repository    =new    PermitRepository();
	//add   permits   to   the   repository   here
	PermitRepository.setTestingInstance(repository);
)
```

![](file:///C:\Users\TY\AppData\Local\Temp\ksohtml32088\wps52.png)

这样就可以了吗?还没有。人们在使用单件模式时往往会将单件类的构造函数设为私有，这 样做是有充分理由的，因为这是令外部代码无法创建该类的其他实例的最明明白白的办法。
到这里，我们发现在两个设计目标之间出现了一个冲突。 一方面，我们想要确保在系统中只 有一个PermitRepository 的实例，而另一方面我们又想要系统中的类能够被单独测试。两者可 以兼得吗?
让我们作一点回顾：为什么我们会希望某类的实例在系统中是唯一的呢?答案因系统不同而 有所不同，但仍还是有一些最为常见的原因的：

(1) 我们建模的是现实世界，而在现实世界中这种东西只有一个。比如一些硬件控制系统就 是这样的。人们为它们需要控制的每种电路板都创建一个类，如果每种电路板都只有一块的话， 这些类就应该是单件类。对于数据库也是这样。前面提到的政府机构中只有唯——组许可证，因 此提供对它们的访问的对象应当是个单件。



(2)创建某个类的两个(乃至多个)对象可能会导致严重的问题。同样，这种情况在硬件控 制领域也经常发生。假设我们一不小心创建了两个核控制棒的控制器对象，并且同一个程序中的两个不同的部分在互相不知道的情况下(通过这两个控制器对象)操纵同一个控制棒，想想看有多可怕。

(3)创建某个类的两个(乃至多个)对象可能会使用过多的资源。这种情况也经常出现。这 里所说的资源既可以是物理资源，如磁盘空间或内存；也可以是一些抽象的资源，如软件许可证的数目。

以上便是人们要求实例唯一性的主要原因，但并不是他们使用单件模式的主要原因。实际上， 人们常常会为了创建全局变量而使用单件模式，他们觉得每次都得将变量传递到需要的地方实在 是太麻烦了。

如果是出于后一个原因而使用单件的，那么其实并没有什么理由一定要保持其单件性。我们 完全可以将构造函数改设为受保护的、公用的或者包作用域的，同时系统仍是一个可测试的良好 系统。而且，就算是出于其他原因而使用单件，仍然值得去尝试一下这一方案。如果需要的话我 们可以引入其他的保护措施。例如可以在构建系统中加入一个检查，通过搜索所有的源文件来确 保setTestingInstance          没有被非测试代码调用。运行期检测也能实现同样的目的：如果 setTestingInstance           在运行期被调用，我们便可以发出一个警告或挂起系统，等待人为操作 介入。事实上，在许多“前面向对象”语言中是无法实施单件性强制的，但人们仍然做出了许多 安全的系统。说到底，关键还是要看你的设计和编码是否可靠。

如果打破单件性并不会带来严重问题的话，我们就可以依赖于一个团队守则。例如，团队中的每个人都应当清楚，某应用程序中的某数据库只能有一个实例，不能有第二个。

按照这一说法，要想放松PermitRepository  的单件性约束，可以将其构造函数设为公用的。 只要PermitRepository 中的公用方法允许我们配置出一个测试用的PermitRepository,          这么 做就是行之有效的。例如，倘若PermitRepository 上有一个名为adaPermit 的方法可以用来将 这个许可证仓库用一堆测试用的许可证填满的话，我们就只需简单地用一组测试用许可证来把它填 充，然后在测试中使用这个许可证仓库对象即可。不过，有时候我们可能没有这个便利条件，或者， 更糟的是，单件可能做了一些我们决不想在测试用具中见到的事情，例如在幕后与一个数据库进行 通信。这时可以采用子类化并重写方法 (314页)技术，创建一个派生类来让测试更为容易。

下面就是来自我们的许可证系统中的一个例子。PermitRepository 中除了一些使其成为单 件类的方法和变量之外，还有一个名为findAssociatedPermit  的方法：
![[Pasted image 20240523101214.png]]
这么一来便可以保留住部分的单件性：由于我们使用的是PermitRepository 的一个子类而 不是PermitRepository本身，所以可以将PermitRepository 的构造函数设为受保护的，而不用设成公用的。这便阻止了客户代码创建PermitRepository 对象，同时又允许派生出一个 PermitRepository 的子类：
![[Pasted image 20240523101335.png]]许多时候我们都可以像这样通过子类化并重写方法来设置一个“伪造的”单件。其他时候，依 赖是如此的广泛以至于更简单的做法是对单件使用接口提取并将应用中所有相关的引用改为提取出 的接口的引用。这么做可能工作量很大，不过我们可以利用依靠编译器(lean on the compiler,251页) 手法来进行修改。以下便是对PermitRepository 进行接口提取后的样子：
![[Pasted image 20240523101419.png]]如果你使用的语言有重构工具支持，则或许可以利用该工具自动进行接口提取。而如果你的 语言没有重构工具支持的话，则使用实现提取可能是较容易的办法。

以上整个重构过程被称为引入静态设置方法(292页)。即便是在面对广泛的全局依赖的情况 下，我们也可以运用该技术来将测试安置妥当。然而遗憾的是，它对全局依赖的状况并无多大改 善。若想要解决全局依赖问题，可以使用参数化方法(301页)和参数化构造函数(297页)。这 两种技术相当于将一个全局变量变为方法中的局部变量或对象中的成员变量。参数化方法的缺点 在于最后的类当中会出现很多额外的方法，影响人们的理解。而参数化构造函数的缺点则在于那 些原先使用全局变量的对象都新添了一个成员变量。这个成员变量在该对象构造的时候通过其构 造函数传递进来，因而创建这个对象的客户代码必须要能够访问到那个全局实例才行。如果太多的对象需要这个额外的成员变量，就可能会极大影响整个应用程序的内存使用量，但如果这种情 况真的出现的话通常就意味着存在其他的设计问题。

让我们来看看最糟糕的情况。考虑这样一个应用：它里面有几百个类，在运行期会创建数千个对象，其中每个对象都需要访问数据库。甚至无需看这个应用一眼，我们大脑里就会首先闪现 出这样一个问题：为什么这么多类都要访问数据库。如果该系统所做的不仅是访问数据库，那么 应当能够将做其他事情的那些代码分解出来，如此一来， 一些类负责做其他事情，而另一些类则负责数据的存储和获取。当我们努力将应用程序中的各种职责互相分离开来，依赖变得局部化了； 我们或许也就不需要让每个对象都自己去访问数据库了。有些对象内的数据来自数据库；另一些对象则对它们的构造函数接受的数据进行计算。

作为一个练习，你可以在一个大型应用中选取一个全局变量，并在整个项目中搜索对它的使 用。大多数情况下全局变量都是全局可访问的，但它们其实并没有被全局使用，而是被用在相对 较少的一些地方。设想，如果它们不是全局变量，该如何将它们传递给那些需要它们的对象呢? 应当如何来重构我们的应用?我们可以从一组组类当中分离出某些职责从而缩小全局变量的作 用域吗?

如果你发现一个全局变量真的被到处使用，这便意味着你的代码没有进行任何层次化设计。 请阅读第15章以及第17章。
**9.5** **可怕的包含依赖**

C++是我使用的第一门面向对象语言，我得承认，对于自己能够掌握C++中的许多细节和复 杂性而感到非常自豪。C++ 当初能够成为业界主流是因为它对当时许多麻烦的问题提供了完全实 际的解决方案。机器太慢?没关系，在这门语言中所有东西都是可选的。如果你只使用其中的C 特性，你就能够得到跟C语言一样的效率。你的团队还不会使用一门面向对象语言?没关系，这 里是一个C++编译器，你可以先用C++的C子集编码，然后再慢慢学习面向对象。

尽管C++ 确实非常流行了一段时间，但最终还是落在了Java以及一些新兴的语言后面。C++ 在保持对C的向后兼容方面的确有些优势，但对于一门语言来说，易用性要重要得多。用C++开 发的团队们一次又一次地认识到，这门语言在“默认”情况下可维护性并不理想，他们必须得走 得更远一点才能使系统敏捷且易于修改。

C++从C那儿继承了一些特性，尤为严重的问题便是C语言使程序的一部分“知道”另一部分。 在Java和C# 中，如果某个文件中的类需要使用另一个文件中的类，我们可以使用import或using语 句。编译器会去寻找相应的类，并检查它是否己被编译。如果没有则对它进行编译。如果己被编  译，则编译器从该类编译后的文件中读出一小段摘要信息，只要足够确认原先那个类所试图使用  的方法在这个类身上都存在即可。

然 而 ，C++ 编译器通常并没有这项优化。在C++ 中，如果一个类需要知道另一个类，则后者 的声明(位于另一个文件中)就会从文本上被一字不差地包含到欲使用它的文件中。这可能会是 一个慢得多的过程。编译器每次见到该声明时都得重新解析它，并建立其内部表示。更糟的是，这种包含机制一不小心就会被误用。 一个文件包含另一个文件，而后者再包含另一个文件，如此 一层层包含下去。如果你在项目中对此未加小心的话，搞不好就会发现一些小的文件最终因一层 层的包含而实际上包含上万行的代码。人们想知道为什么项目的构建要花上那么长的时间，但由于系统中到处都是文件包含，所以，对任何一个特定的文件，要想弄清它为何需要花那么长时间  编译都不是件易事。

读到这里你可能会觉得我现在已经不再喜欢C++了，但实际上并非如此。C++是一门重要的 语言，而且目前C++ 的现存代码量非常巨大，只不过要想驾驭好这门语言的确得花更多的心思。
在遗留代码中，要想将一个C++类放入测试用具可能会很难。我们面对的最直接的挑战之一 便是头文件依赖。要在测试用具中创建一个类需要哪些头文件呢?
下面便是一个庞大的C++类Scheduler    的部分声明。它含有200多个成员函数，不过我只在 下面列出了其中的5个。除了体积庞大之外，这个类还跟其他许多类之间有着非常紧密的、千丝 万缕的依赖。问题是：我们怎样才能在测试中创建Scheduler   对象呢?
![[Pasted image 20240523101753.png]]Scheduler 用到的类，包括Meetings、MailDaemons、Events、SchedulerDisplays、

Dates 等。如果我们想要为Schedulers    创建一个测试，最简单的做法便是在同一目录下新建一

个名为schedulerTests 的文件，然后在里面编写测试。那么,为什么要在同一目录下呢?因为   在有预处理的情况下这样做通常更容易。如果你的项目不使用目录路径来统一文件包含的方式，那么在其他目录下创建测试的话就可能会很麻烦。
![[Pasted image 20240523102137.png]]如果我们创建一个文件，并将上面的那行对象声明放入测试的话，就可能会遇到包含问题了： 为了编译Scheduler, 我们得确保编译器和连接器知道scheduler 所需要用到的一切东西，以 及后者所需要用到的一切东西，依此类推。幸运的是，构建系统给了我们一大堆出错信息，无比 详尽地告诉了我们有关情况。

在简单的情况下， Scheduler.h 文件包含了创建Scheduler 对象所需的所有东西，但有时 候头文件并不能包含得面面俱到，我们得另外再包含一些文件才能创建并使用该类的对象。

我们可以简单地将Scheduler 类的源文件中的所有#include 语句一股脑儿拷贝到我们的 测试文件中，但实际上可能并不需要它们中的全部。最好的办法是一个一个的添加这些#include语句，看看我们是否真的需要那些依赖。

在理想情况下，最简单的做法就是不断包含我们所需的文件，直到不出现任何构建错误为止， 不过这种做法可能会把我们推进一种混乱的情况当中。
**如果依赖传递的链条很长，则我们可能最 终会发现包含了许多我们其实根本不需要的东西。而且，就算依赖链并不长，最后也可能依赖于一些在测试用具中很难对付的东西。**
如本例中的SchedulerDisplay 类就是这样一个依赖。
这在上面给出的代码中没有显示出来，但Scheduler的构造函数的确访问了它。我们可以像下面这样来对付这个依赖：
![[Pasted image 20240523102348.png]]![](file:///C:\Users\TY\AppData\Local\Temp\ksohtml32088\wps54.png)这里我们为schedulerDisplay::displayEntry   编写了一个替代定义。不过遗憾的是，如果这么做，就需要对该文件中的测试用例单独进行编译/构建了，因SchedulerDisplay中的 每个方法只能有唯一定义。所以，我们的scheduler 测试必须构建为一个单独的程序。
幸运的是，像上面这样编写的“伪定义”是可以复用的，我们只需将它们从测试文件中剪切 出来放到一个单独的头文件当中，这样一来我们便可以在多个源文件当中通过#include   该头文 件来使用这个“伪定义”了。如下所示：
![[Pasted image 20240523102526.png]]熟练了之后，像这样使一个C+ 类能够在测试用具中被实例化就会变得相当容易和机械化。 不过，这种做法有几个非常严重的缺点。首先，我们得为这个测试单独构建程序，另外我们其实 也并没有在语言层面将依赖解开，因此代码并没有变得更清晰。更糟的是，只要我们的测试还在， 我们放在测试文件中的重复定义(本例中即schedulerDisplay::displayEntry)   就必须被 保留。
这一技术适合留给类非常巨大且依赖非常严重的时候。这不是一门应该经常使用的技术，也不是一门能轻松使用的技术。如果那个类随着时间的推移会被逐渐分解为一大堆小类，那么为一 个类创建一个单独的测试程序也许是有用的。
它可以作为一系列重构的测试点。随着时间的推移， 你会提取出更多的类，并将这些类纳入测试，从而这些单独的测试程序也就可以随之“退休”了。

**9.6**   **“洋葱”参数**

我喜欢简单的构造函数。想想看，当你想要创建一个类时，只要敲进一个构造函数调用，立即就得到了一个可用的对象，这是一件多么美好的事情。但很多时候，创建对象可能会较难。每 个对象都得被设置到一个适当的状态， 一个使它准备投入后续工作的状态。许多时候这便意味着 我们得向它提供本身已被设置妥当的对象，而后者可能又需要另一些对象来设置，这样一来我们为了创建一个对象可能先要进行一连串的“创建-设置—创建”工作，最后才能得到一组对象作 为待测试类的构造函数的参数。“对象里面包着对象”,听起来就跟洋葱似的， 一层一层的。下面 就是这类问题的一个例子：

下面这个类的作用是显示一个schedulingTask:

```
public    class    SchedulingTaskPane     extends    SchedulerPane{
	public     SchedulingTaskPane(SchedulingTask     task)   {

	}
}
```

为了创建这个类的对象，我们需要传一个schedulingTask对象给它的构造函数，而为了创 建schedulingTask 对象，我们又不得不使用它那唯一的一个构造函数，如下所示：

```
public    class     SchedulingTask    extends     SerialTask
{
	public  SchedulingTask(Scheduler  scheduler,   MeetingResolver resolver)
    {
    }
}

```
然后，如果我们接着又发现还需要另一些对象来作为创建schedulers     和MeetingResolver      对 象的参数的话，可就真要抓狂了。唯一能够使我们免于完全绝望的一点就是这个过程总是有尽头 的，最终总会有对象不再需要其他对象而创建。要是这个过程永无止境的话，系统岂不是永远也编译不完了?!

**应付这种情形的办法是仔细考察我们究竞想要做什么。是的，我们得编写测试，但对于那些 传给构造函数的参数，我们真的需要它们吗?如果并不需要的话，就可以使用传Null手法了。而 如果我们需要的只是一些基本的行为，则可以使用接口提取或实现提取。

遗憾的是，SchedulingTask     是从一个名为SerialTask     的类派生来的，SchedulingTask所做的仅仅是重写SerialTask 中的一些受保护的方法。所有的公用方法都来自于SerialTask。 我们可以对SchedulingTask    使用接口提取吗?或者说，我们必须也对SerialTask使用接口提 取 吗 ? 在Java中我们不必这么做。我们可以为schedulingTask创建一个包含了来自SerialTask 的方法的接口，提取后的结果如图9-3所示：  
![[Pasted image 20240523103343.png]]

就这个例子而言，应该说我们是比较幸运的，因为我们使用的是Java而不是C++。如果是C++ 就不能这样来处理了。因为C++并不支持像Java那样的接口。C++中的接口通常是由只包含纯虚函 数 的 抽 象 类 来 实 现 的 。 如 果 把 上 面 这 个 例 子 移 植 到C++  下 面 ，SchedulingTask  就 应 该 变 成 一

个抽象类，因为它从ISchedulingTask     那里继承了 一 个纯虚函数。所以要想创建 SchedulingTask    的对象，就必须为它的纯虚成员函数run()   提供一个定义体，该定义体负责把 任务转发给SerialTask     的run()   去做。幸运的是这很容易做到。下面就是代码：
![[Pasted image 20240523103500.png]]于一门语言来说，只要能用它来创建接口，或者类似接口行为的类，我们就可以系统地使 用它们来进行解依赖。
***
通过接口来接触依赖是接触依赖最主要的方法之一
***
**9.7**  **化名参数**

当遇到构造函数参数问题时，通常可以借助于接口提取或实现提取技术来克服。但有时候这 两种做法却是不实际的。让我们来看一看上节提到的关于建筑许可系统中的另一个类：
![[Pasted image 20240523103739.png]]![](file:///C:\Users\TY\AppData\Local\Temp\ksohtml32088\wps56.png)我们想要在测试用具中实例化该类，但这里存在几个问题。其中之一便是，我们又一次遇到  了单件PermitRepository。当然，可以借助于前面讨论全局依赖时提到的技术来解决这个问题。 但这之前我们首先得解决另一个问题，就是我们很难创建出一个originationPermit 对象来传  给这个类的构造函数。OriginationPermit       上的依赖情况很严重。我第一时间想到的是：“噢， 我可以对OriginationPermit       使用接口提取技术来解决这些依赖问题啊。”但事情并没那么简 单。请看图9-4展示的这个Permit 体系结构图：

IndustrialFacility 的构造函数的参数之一便是OriginationPermit, 该构造函数接着 从PermitRepository     获取一个与之关联的许可(Permit  对象):这是通过PermitRepository
上的方法findAssociatedFromOrigination 来实现的，该方法接受一个OriginationPermit
对象并返回与之关联的Permit    对象。如果找到了这个关联的许可，IndustrialFacility 的构造函数就会将它保存到成员basePermit 中。如果没有，则将那个作为构造函数参数的 originationPermit 对象保存到basePermit 中。我们可以为OriginationPermit 创建一个接 口，但这样做没什么好处，因为这么一来当我们将这个参数赋给basePermit 时，它们的类型一 个是IoriginationPermit,          而另一个则是Permit,     这是行不通的。在Java里面，接口不能从 类派生得来。最显而易见的解决方案就是顺着继承体系一路往下创建接口，并将basePermit       的 类型改为IPermit 。   图9-5显示了这种情形：
![[Pasted image 20240523103850.png]]这样做的工作量也太大了，而且我也不是特别喜欢代码最后的样子。接口的确是解依赖的利  器，但如果出现了接口与类几乎一一对应的情形，设计就变得混乱起来了。别误会，如果我们别  无退路，那么像上面这样的设计也是可以的，但如果还有其他选择的话，我们当然应该尝试一下。

幸运的是，的确存在其他方案：接口提取只是对参数进行解依赖的途径之一。有时候问一问“为什么这个依赖是糟糕的”往 往是有好处的。例如，有时候对象创建是麻烦所在，而有时候参数则会具有糟糕的副作用，比如跟一个文件系统或数据库进行通信；而还有些时候呢，也许只不过是创建起来太费时间了。当我们使用接口提取时，可以克服所有这些问题，但代价是我们粗鲁地切断了与一个类之间的联系。 如果某个类只是有某几个地方有问题，则我们可以采取另一个方案，只切断与这些地方之间的联 系即可。

让我们更仔细地来考察一下originationPermit类。我们不想在测试中使用它，因为当我 们希望它进行自身验证时，它便会悄无声息地在幕后访问一个数据库：
![[Pasted image 20240523104031.png]]我们可不希望在测试时发生这种事情：那样的话就不得不在数据库中放一些“伪造的”(测 试用)条目，搞得数据库管理员不得安宁。 一旦被他发现，我们就不得不请他吃顿饭还是什么的 来赔礼道歉，而且就算那样他还未必领情。他的工作本就已经难做了。

可以采取的另一个策略就是子类化并重写方法。我们可以创建一个名为FakeoriginationPermit  的类，该类提供一些方法使得外界可以很容易地改变其验证标志。接着，便可以在 FakeOriginationPermit  的子类中重写validate() 方法，按照测试所需来设置验证标志。下 面就是我们的第一个有效的测试：
![[Pasted image 20240523104123.png]]在许多语言当中，我们都可以像这样在一个方法当中“即时”地创建一个新类。虽然我并不喜欢经常在产品代码中这么做，但在测试当中这是个非常便利的特性。借助于它我们很容易就能 实现一些特殊的用例。
子类化并重写方法能够帮助我们解开参数上的依赖，但有时类中的方法的分解方式并不十分 适合这个技术。就本例来说我们比较幸运，因为我们不希望看到的依赖被隔离在了那个validate() 方法中。在情况最糟糕的时候，那些依赖可能会和我们所需要的逻辑混在一起，令我们不得不先进行方法提取。这时如果我们手头有一个重构工具就会很好办，但如果没有，请参考第22章中的 一些技术，可能会有帮助。