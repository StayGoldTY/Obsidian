在对付遗留系统时，也许没有比遇到下面的事情更令人沮丧的了。比如，你需要做一处修改， 看到了需要修改的地方，但接下来你却发现另一处一模一样的地方也需要作相应的修改，然后又 是另一处，另一处……,因为你的系统里面其他很多地方的代码都与这个地方的几乎一模一样。 你可能会觉得，如果对系统做一些重构的话这样的问题可能就不会存在了，但谁又有这个时间 呢?于是也只能让这个问题在系统里面搁着，看着心烦却又无计可施。

如果你会重构的话，情况就会好一些。你会知道消除重复代码并不一定要像重新设计或重新 架构那样大张旗鼓，消耗大量精力；而是可以在工作的过程中小块小块地进行修改。这样系统的 状况就会逐步得到改善；当然，前提是别人不要跟在你后面继续往里猛塞重复代码才行——不过 就算这一情况不幸发生了，也仍然还是有办法解决的(别玩真人PK就成②),但这就不是我们 这里应该讨论的问题了。关键是，值不值得这么做。把一块代码里面的重复成分挤干对我们来说 到底有什么好处?我想答案会让你吃惊。先让我们来看一个例子。

现有一个不大的用Java写的网络系统，我们需要用它来发送命令到一个服务器端。有两个命 令类，分别叫AddEmployeeCmd 和LogonCommand。  当需要发起一个命令时，我们就实例化相应 的命令类并传一个输出流给它的写方法。

下面就是这两个命令类的定义，从中你能看出有哪些重复代码吗?

![[Pasted image 20240524085242.png]]
![[Pasted image 20240524085317.png]]
![[Pasted image 20240524085331.png]]
![[Pasted image 20240524085341.png]]

看起来重复成分还不少，但那又怎样呢?反正代码量又不多。我们可以重构，切出重复成分， 缩减代码量。但是，这么做是不是就让我们的工作变得容易些了呢?可能是，也可能不是；光是就这样看上两眼脑袋里想一想是很难给出答案的。

那么就让我们试试看吧。首先找出那些重复的地方，删除它们，然后看看得到的代码是什么 样子的。这样我们便可以判断我们的重复消除能否带来帮助了。

开始之前，首先需要一组测试，以便在每次重构之后都能够运行它们来确保一切正常。不过 为了叙述的简洁，这里就不描述这组测试了，你只需记住它们在哪儿就可以了。

**开始步骤**

面对代码重复，我的第一反应便是“后退一步”好对它有一个更整体的认知。这么做时，我 便开始思考最终得到的类会是什么样子的，以及抽取出来的重复代码成分看起来会是怎样的。然 后我意识到自己想得太多了。其实只需从删除小块重复代码开始，而且它使得我们以后更容易看 到更大块的重复成分。例如，在LoginCommand 的写方法中，有如下的代码：

```
outputStream.write(userName.getBytes())

outputStream.write(0x00);

outputStream.write(passwd.getBytes());

outputStream.write(0x00);
```

从以上代码可以看出，每写出一个字符串，结尾都会跟上一个结束符(0x00)。 于是我们可 以这样来提取这里的重复成分：创建一个名叫writeField      的新方法，该方法接受一个字符串和 一个输出流，然后负责将字符串写入流中，并写入一个结束符。

```
void writeField(Outputstream outputstream, String field) {

outputStream.write(field.getBytes());

outputstream.write(0x00);

}
```

![[Pasted image 20240524085727.png]]有了这个新方法之后，我们便可以将每个成对的“串/结束符”写入都替换成单个调用，同 时别忘了每次都要运行测试来确保一切正常。下面就是LoginCommand 的write   方法修改之后的 样子：
![[Pasted image 20240524085828.png]]

这便解决了LoginCommand类的问题，但还剩下AddEmployeeCmd类呢? AddEmployeeCmd 里面同样也存在重复的串/结束符写入序列。由于这两个类都是命令(Command)类，因此我们可以 考虑引入一个公共基类，比如就叫Command。 有了这个公共基类之后，便可以将writeField 放 在其中供这两个派生类使用。
![[Pasted image 20240524085954.png]]现在代码干净一些了，但还没有结束呢。AddEmployeeCmd和LoginCommand的写方法形式 上其实是一样的：依次是写入命令的首部 (header) 、大小 (size)   以及命令符 (command  Char);   然后是写入一组字段；最后是写上尾部(footer)。如果我们可以将它们之间的差异成分抽取出来， 就能够得到如下写方法(以LoginCommand的为例)。
![[Pasted image 20240524090041.png]]

[如果两个方法看上去大致相同，则可以抽取出它们之间的差异成分。通过这种做法，我们 往往能够令它们变得完全一样，从而消除掉其中一个。]

现在，这两个类的写方法看上去完全相同了。那么我们是否可以将这个写方法提升到 Command基类中了呢?等等。就算两个方法“看上去”完全一样了，但它们所使用到的成员数据 仍然还是属于它们各自的类的：header 、footer      以及commandChar。如果想要实现单一的写方 法，则这个写方法必须能够调用其派生类的特定方法来获取相应的数据成员才行。因此就让我们 来考察一下AddBmployeeCmd 和LoginCommand中的数据成员吧。

![[Pasted image 20240524090227.png]]
看得出来，这两个类里面的公共数据还是挺多的，比如header、footer、SIZE_LENGTH 以 及CMD_BYTE_LENGTH,  由于它们的值对应相同，因此我们可以将它们全都提升到Command 类 中来。为了重新编译和测试的目的，我们先将它们设为受保护的。
![[Pasted image 20240524090300.png]]这样一来，我们只需在每个相应的派生类上使用重写的getCommandChar方法来表示commandChar变量即可：
![[Pasted image 20240524090331.png]]注意，我们还引入了一个抽象的writeBody  方法(见图21-3)。
![[Pasted image 20240524090352.png]]这是个相当简洁清爽的类。AddEmployeecmd 也与此相似： 一个getsize 方法、 一个 getCommandChar 方法，几乎就这些。现在让我们稍微仔细地看一下getSize   方法。

![[Pasted image 20240524090416.png]]
这两个getSize 的相同点有哪些，不同点又有哪些呢?看起来它们都将首部长度、 SIZE_LENGTH、  命令字节长度以及尾部长度计算进去了。然后剩下的就是每个字段的长度，在 这一点上两者不同。那么,若是我们将这个不同点提取出来呢?把getBodySize()     作为计算各 字段长度总和的函数，于是：

```
private int getSize() {
	return    header.length    +    SIZE_LENGTH
	+ CMD_BYTE_LENGTH +   footer.length          +getBodySize();
}
```

这么一来，两者的getsize()      就又一样了。getsize     的逻辑是所有的簿记 (bookkeeping)   数据的长度，加上命令消息体的长度(即所有字段的长度总和)。这么一来我们便又可以将getSize   提升到Command基类当中去了，而不同的派生类只需实现不同的getBodySize    即可(见       图2I-4)。
![[Pasted image 20240524090533.png]]看起来，我们还是漏掉了一些相当讨厌的重复代码。虽然数量不多，但就让我们再热心一回， 把它们完全消除掉看看。
![[Pasted image 20240524090610.png]]还有什么重复的成分吗?实际上还有，但已经不多了。我们注意到LoginCommand和 AddEmployeeCmd 都是接受一组参数，获取它们的大小，然后将它们写出。除了commandChar    变量之外，这两个类也就只剩这点差别了：我们能否通过一点泛化来解决掉这一重复呢?事实上， 通过在基类中引入一个链表，我们便可以在每个派生类中的构造函数里面这样做。
![[Pasted image 20240524090641.png]]现在我们可以将这些方法统统都提升到Command基类中了。这样便真正消除了所有的重复。 以下便是Command类修改后的样子。注意Command里面的那些不再被派生类访问的方法都已经改 成私有的了。
![[Pasted image 20240524090715.png]]
![[Pasted image 20240524090730.png]]现在我们到哪了呢?消除掉了那么多的重复代码，以致于我们的两个命令类简直都成了一层 空壳了。所有的功能性代码都转移到了公共基类Command中。实际上，如果你开始怀疑究竟是否 要给这两种命令分别引入各自的类，你的怀疑是不无道理的。那么替代方案又是什么呢?

我们可以拿掉这两个派生类，并往Command类中加入一个静态方法，该方法允许我们发送一 个命令。
![[Pasted image 20240524090818.png]]但这又使得所有的客户代码都得作出相应改动。就目前来说，代码中创建AddBmployeeCmd 和LoginCommand 对象的地方还真不少。

或许最好的办法还是就让这两个类留在那儿。的确，它们小到不够资格，但那又如何呢?反 正它们又没有带来什么坏的影响，是吧。

完了吗?还没有。有 一件事情我们还没做，实际上早该做了。那就是我们可以将 AddEmployeeCmd 重命名为AddEmployeeCommand 。 这样两个命令类的名字就一致了。命名的 一致性可以减少出错的机会。
***
**缩写
类名和方法名缩写是问题的来源之一。缩写风格一致的话倒还好，但总的来说我不喜欢这种做法。
我曾遇到过这样的一个团队，该团队试图在它们系统中的几乎每一个类的类名里面使用 manager和management这两个字眼。这种命名习惯没带来好处，更糟的是它们居然还用了好多 种不同的缩写法。例如，有些类被命名为XXXXMgr,  而同时另一些类则被命名为XXXXMngt。
这就使得想要使用这些类的人几乎每次都要把类翻出来看看以确信自己使用了正确的类。而对 于我个人来说，要猜测某个特定的类用的应该是哪个后缀，有一半以上的时候猜错。
***

好了，现在我们已经将所有重复成分消除。剩下的问题就是检验它是否真的带来了好处。为 此让我们来设想几个场景。场景一：当我们需要增加一个新命令时，我们该怎么办?我们可以从 Conmmand派生出一个新类，创建该类的对象即可。而如果是在消除重复之前的系统里呢?我们便 需要创建一个新的命令类，然后从另一个命令类那儿剪切/粘贴一些代码，修改变量等等。而这 又会引入更多的重复，并让事情变得更糟；除此之外还更容易出错。比如可能会弄错了变量什么的。而且在消除重复之前，这 一 过程绝对要花上更长 一 点的时间。

那么,重复成分的消除是否导致我们丢掉了 一 部分灵活性呢?如果我们必须得发送非字符串 类的命令该怎么办呢?其实，从某种程度上说我们已经解决了这个问题。AddEmployeeCommand本身就能接受 一 个整型参数，并将其转换为字符串然后作为命令发送。对于其他任何类型，我们 也可以用同样的做法。因为要想发送 一 个命令，反正总是要转换为字符串形式的。我们可以在具 体派生类的构造函数中完成这 一 步骤。

另 一 个问题：如果我们需要另 一 种形式的命令怎么办?比如说 一 个可以将其他命令嵌套进命 令体的命令。这个问题其实也可以轻易解决。只需从Command  派生 一 个新类，重写其writeBody方法 ：
![[Pasted image 20240524091053.png]]剩下的就不用你操心了。

现在，想象 一 下倘若不是消除了重复，情况会怎样吧。

这最后 一 个例子揭示出了 一 些非常重要的东西。即当消除类之间的重复成分时，会得到 一 些 很小，功能很集中的方法。每 一 个方法所做的事情都跟其他方法不同，这其实便意味着 一 个极大的好处：正交性。

<span style="color: #3CB371;">正交性说白了其实就是独立性(无关性)。比如说你想要修改代码的既有行为，然后发现只 需到代码中的 一 处地方改 一 下就成了。</span>

**这就是正交性。如果把我们的应用比作外面嵌着 一 些旋钮的盒子，那么具有正交性的应用就好比是 一 个行为只对应 一 个旋钮，调节起来很容易。反之如果  重复情况很严重的话，就可能会出现 一 个行为涉及多个旋钮的情况。

就拿前面例子中的字段写出  来说，在 一 开始的设计中，如果我们想改用0x01 作 为 结 束 符 ( 原 来 是 0x00),  我们就得“遍历” 代码，将每 一 处使用0×00的地方都改成0x01。  此外设想有人要求我们用两个0×00作为结束符，  那么情况也会变得相当糟糕。 一 句话，没有单 一 切入点。另 一 方面，在经过我们重构之后的代码  中，要想改变字段的写出行为，只需编辑或重写writeField   方法即可，对于 一 些像命令嵌套之  类的特殊任务则可以重写writeBody   方法。总之， 一 旦将行为局部化到了单个方法中，想要替换或是修改它就很容易了。

本例中我们做了很多事情：把一些方法和变量从一个类移到另一个类、将方法分解，等等。 但其中大部分事情都是机械的。我们只不过是注意到了代码中的重复情况然后将它们消除而已。 

<span style="color: #3CB371;">真正具有创造性的事情其实只有一件，那就是给新方法想出合适的名字。原来的代码并没有字段 或命令体的概念，但其实某种程度上这些概念是隐藏在代码中的。例如，有些变量是被特殊对待 的，我们将它们称为字段。最后我们得到了一个优雅得多的正交设计，但我们并不觉得是在进行 设计而更多只是将一段代码改得更符合它的本意而已。</span>

***
**好的设计是看到代码本来应该的样子的，坏的代码是扭曲了本意的代码。就是小孩子一样，虽然扭曲她的天性她还是能长大，但是大概率会越来混乱，到一个临界点会爆发出来导致你再也不好管教了
***


当你热情地去消除代码中的重复时，就会惊讶地发现，设计会自已浮现出来。是的，系统中 的大部分正交性都无需你刻意去实现，它们自然而然就会出现。但这还不够完美，例如，考虑 Command 类上的如下方法：
![[Pasted image 20240524091942.png]]

现在我们的代码中就多出了两个新的切入点。 一个是命令头的写出，另一个是命令尾的写出。 我们当然可以根据需要往代码中添加这样的切入点，然而毕竟看到它们自然而然地出现还是令人  欣喜的。

重复消除是锤炼设计的强大手段。它不仅能让设计变得更灵活，还能令代码修改更快更容易。

***
**开放/封闭原则
开放/封闭原则是由Bertrand Meyer首先提出的。其背后的理念是，代码对于扩展应该是开 放的而对于修改则应是封闭的。这就是说，对于一个好的设计，我们无需对代码作太多的修改  就可以添加新的特性。
那么,具体到本章的例子，我们最后得到的代码具备这一要素吗?答案是肯定的。我们前 面已经考察了一系列的修改场景，许多情况下只需要对极少的方法稍加修改即可。还有一些情  况下则只需派生一个新类即可解决问题。当然，派生之后很重要的一点是要记得消除重复(见  关于差异式编程的描述，其中介绍了如何通过派生来添加新特性以及通过重构来整合它们)。
此外，消除了重复之后，我们的代码往往便会自然而然地往开放/封闭原则靠拢了。
***

开放/封闭原则（Open/Closed Principle，OCP）是面向对象设计中的SOLID原则之一，由Bertrand Meyer提出。这个原则指出：

**“软件实体（类、模块、函数等）应该对扩展开放，对修改封闭。”**

### 详细解释

- **对扩展开放**：意味着可以通过增加新功能来扩展模块的行为。
- **对修改封闭**：意味着不应通过修改已有代码来改变模块的行为。

这种设计原则的目标是提高系统的可维护性和灵活性，通过允许添加新功能而不改变现有代码，降低因修改代码而引入错误的风险。

### 实现开放/封闭原则

实现开放/封闭原则的一种常见方法是使用抽象类和接口，以及面向对象编程中的继承和多态机制。通过这些手段，我们可以在不修改现有代码的情况下，扩展系统的功能。

### 示例讲解

假设我们正在开发一个图形绘制应用程序，需要绘制不同的形状。我们希望在不修改现有形状类的情况下，能够添加新的形状。

#### 不遵循OCP的设计

首先，假设我们有一个简单的设计，其中绘图类 `GraphicEditor` 直接依赖于具体的形状类：

```csharp
public class GraphicEditor
{
    public void DrawShape(object shape)
    {
        if (shape is Circle)
        {
            DrawCircle((Circle)shape);
        }
        else if (shape is Rectangle)
        {
            DrawRectangle((Rectangle)shape);
        }
        // 需要添加更多形状时必须修改这个类
    }

    private void DrawCircle(Circle circle)
    {
        Console.WriteLine("Drawing a circle");
    }

    private void DrawRectangle(Rectangle rectangle)
    {
        Console.WriteLine("Drawing a rectangle");
    }
}

public class Circle
{
}

public class Rectangle
{
}
```

在这个设计中，如果我们需要添加新的形状，比如三角形，我们需要修改 `GraphicEditor` 类，违反了开放/封闭原则。

#### 遵循OCP的设计

为了遵循开放/封闭原则，我们可以引入一个抽象的 `Shape` 基类，并让所有具体的形状类继承这个基类。同时，绘图类 `GraphicEditor` 依赖于 `Shape` 基类，而不是具体的形状类。

##### 定义抽象形状类

```csharp
public abstract class Shape
{
    public abstract void Draw();
}
```

##### 实现具体的形状类

```csharp
public class Circle : Shape
{
    public override void Draw()
    {
        Console.WriteLine("Drawing a circle");
    }
}

public class Rectangle : Shape
{
    public override void Draw()
    {
        Console.WriteLine("Drawing a rectangle");
    }
}

public class Triangle : Shape
{
    public override void Draw()
    {
        Console.WriteLine("Drawing a triangle");
    }
}
```

##### 修改绘图类

```csharp
public class GraphicEditor
{
    public void DrawShape(Shape shape)
    {
        shape.Draw();
    }
}
```

##### 使用新的设计

```csharp
class Program
{
    static void Main(string[] args)
    {
        GraphicEditor editor = new GraphicEditor();
        Shape circle = new Circle();
        Shape rectangle = new Rectangle();
        Shape triangle = new Triangle();

        editor.DrawShape(circle);
        editor.DrawShape(rectangle);
        editor.DrawShape(triangle);
    }
}
```

### 结果输出

```
Drawing a circle
Drawing a rectangle
Drawing a triangle
```

在这个设计中，`GraphicEditor` 类不需要知道具体的形状类，它依赖于 `Shape` 抽象类。每个具体的形状类负责实现自己的绘制逻辑。如果需要添加新的形状，只需创建一个新的形状类并实现 `Shape` 抽象类，而不需要修改 `GraphicEditor` 类，从而遵循了开放/封闭原则。

### 总结

开放/封闭原则旨在通过避免修改现有代码来减少错误和提高系统的灵活性。通过使用抽象类和接口，以及面向对象编程中的继承和多态机制，我们可以在不修改现有代码的情况下扩展系统的功能，从而提高代码的可维护性和可扩展性。