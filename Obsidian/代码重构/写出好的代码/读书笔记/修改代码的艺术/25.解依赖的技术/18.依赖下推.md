有些类里面的问题依赖并不多。如果这些依赖被包含在少数几个方法中的话，你可以采用子  类化并重写 (314页)手法来将它们解决掉。但如果依赖猖獗，则这条路可能就行不通了，这时  你可能就需要动用接口提取技术，重复运用接口提取来解除对某些特定类型的依赖。依赖下推 (Push  Down  Dependency) 则是另一个选择。该手法能够将目标类其他部分的问题依赖分离出来， 使你能够更容易地在测试用具中将它实例化。
在使用依赖下推技术时，首先把目标类设为抽象类，然后创建一个它的子类，后者便是你的 新的产品类了。接着将所有的问题依赖都“下推”到这个子类中。到这一步，你便可以通过子类 化原类来让它的有关方法接受测试了。下面是一个C++ 的例子：
![[Pasted image 20240524162939.png]]对于上面这个类，如果想要修改它里面的isValid()      的验证逻辑的话就会遇到麻烦了，我们 可不希望将UI相关的函数和类牵扯到测试用具中来。这时依赖下推手法便有用武之地了。

对上面的类作依赖下推之后的情形如下：
![[Pasted image 20240524163103.png]]一旦UI相关的工作被下推到了一个新的子类 (windowsOffMarketValidator)           中，我们 便可以创建另一个测试用的子类了，后者只需实现一个空的showMessage()   方法即可：
![[Pasted image 20240524163130.png]]如此一来我们便有了一个可测试但同时又不依赖于任何UI相关事物的类。那么,在这个例子中使用继承是否为理想的方案呢?不是的，但它最大的好处就是能帮助我们将目标类的一部分逻 辑纳入测试。而一 旦有了对offMarketTradeValidator  的测试，便可以开始清理 showMessage()   里面的重试逻辑，并将其从WindowsOffMarketTradeValidator         提升到基类 中来。然后，当windowsOffMarketTradeValidator    最终被掏空得只剩UI相关的调用时，我们 便可以转向委托式的设计了，即将UI相关调用委托给一个UI依赖的新类。

**步** **骤
依赖下推的步骤如下：
(1)在测试用具中构建目标类。
(2)找出哪些依赖是导致构建问题的依赖。
(3)创建目标类的子类，子类的名字须反映上一步找出的依赖的特征'。
(4)将目标类中的依赖变量和方法全部复制到新建的子类中，注意保持签名；将目标类中的相应方法设为受保护及抽象的；将目标类设为抽象的。
(5)创建目标类的一个测试子类，修改你的测试，实例化该测试子类。
(6)创建测试来验证你的确能实例化这个新的测试子类。