**25.4**  **封装全局引用**

在测试依赖于全局变量的代码时本质上有三个选择：想办法让它依赖的全局变量在测试期间具 有另一种行为；利用连接器，连接到另一个全局变量定义；或将它封装起来，从而可以进一步进行 解耦。最后一个选择称作封装全局引用(Encapsulate Global References)。下面是一个C++ 的例子：
![[Pasted image 20240524142536.png]]以上代码用到了几个全局数组。suspend_frame 函数需要访问AGG230_activeframe 和 AGG230_suspemdedframe  这两个全局数组。初看起来似乎可以将这两个数组做成 AGGController  类的成员变量，然而其实行不通，因为还有另外一些类(没有展示在代码中) 也要用到这两个数组。那怎么办呢?

你可能会立即想到：干嘛不使用参数化方法(301页),将它们作为参数传给suspend_frame  函数呢。实际上这么做有一个问题：如果suspend_frame    调用了某个函数，而后者也使用了该全 局变量的话，我们就必须同样将该变量作为参数传递给它。如本例中的flush_frame_buffer。

另一个选择是将两个全局数组传递给AGGController 的构造函数。这么做是可行的，但实际上还可以进一步检查一下这两个全局数组还在哪些地方被用到，如果发现它们每次都是被一起 用到的，则可以考虑把它们绑在一起。

**如果若干全局变量总是被一起使用一起修改，则它们应属同一个类。

应付这种状况的最佳办法就是建立一个“智能”的类(并给它想一个好名字)来持有这两个全局变量。有时候这并不像听起来那么简单。我们需要考虑这些全局变量在设计中的意义以及它们为什么在那里。如果为它们建立了一个新类，那么我们迟早会往里面添加/转移方法的，而且 很可能这些方法的代码早已存在于某些使用这些变量的代码段中了。

**命名一个类的时候，考虑最终会位于它里面的方法。当然我们应当给它起一个好名字，但并不一定是完美的。别忘了，你总是可以重命名它的。**

在上例中，我期望随着时间的推移， frame_copy 和clear 能被移至我们将要建立的新类中。 那么,有哪些工作对于这两个全局变量来说是公共的呢? AGGController        的suspend_frame函数或许可以被移到新类中，只要后者包含那两个数组 (suspended_frame         和active_frame)就行。我们可以管这个新类叫什么呢?可以叫Frame,  并说明每个Frame 包含一个活动 (active) 缓冲区和悬置 (suspended)    缓冲区。这一做法要求我们对系统中的概念作一些修改，并重命名几 个变量，但我们所得到的是一个智能的、隐藏了更多细节的类。

**你想到的类名可能已经被用掉了。这时候可以考虑重命名那些使用了该名字的实体，从而 将该名字腾出来。**

![[Pasted image 20240524142808.png]]
这时，编译器会告诉我们AGG_activeframe    和AGG230_suspendedframe      不存在。如果你的构建系统足够烂的话，它可能会徒劳地试图通过连接来寻找符号，结果给出长达10页的连接错 误。但是别慌张，这些都是意料之中的。

要解决所有这些错误。我们可以顺着编译错误找到每一行出错代码，将里面对这两个全局数 组的引用加上 “frameForAGG230”  前缀，如下：
![[Pasted image 20240524142851.png]]
完成这些之后，你会发现代码更加丑陋了，但重要的是它能正确编译运行，所以说前面的步骤是保持行为的。完成了这些工作之后，我们便可以通过AGGController 类的构造函数来传递 Frame 对象，并得到所需的分离了。

**从引用一个简单的全局变量到引用一个类成员只是第一步。之后你还需要考虑是否应当使 用引入静态设置方法或参数化构造函数，又或者参数化方法。**

以上我们创建了一个新类，将两个全局变量添加到其中并设成公有的。为什么要这么做呢?  毕竟我们已经花了一些时间思考新类应该叫什么名字以及什么样的方法可以放到里面。我们本可 以创建一个伪Frame 对象，并在AGG_Controller  中将任务委托给它；然后我们可以把所有用到 了这两个变量的代码都移到一个真正的Frame 类中。没错，我们是可以这么做。但凡事不宜操之 过急。更何况手头还没有测试，而且我们要花尽量少的工作先将测试安置到位再说，这时候最好 能不碰就不去碰代码中的逻辑。我们应当尽量避免触动这些逻辑，并尝试往代码中引入接缝，以 便通过这些接缝来植入测试用的代码或数据。后面，当测试逐渐丰富的时候，便可以开始放心地 将行为从一个类转移到另一个类了。

一旦实现了将Frame 对象传递进AGGController     之后，我们便可以做一点小小的重命名， 让代码变得稍微清晰一些。以上重构之后的代码可能像这样：
![[Pasted image 20240524143008.png]]看起来改进不大，是不是?但实际上这是非常有价值的第一步。在将数据转移到一个类中之后，我们便拥有了分离，并能够在接下来的工作中不紧不慢地将代码朝着良性的方向改进。我们 甚至看到了创建一个FrameBuffer 类的潜在可能性。

**在使用封装全局引用手法时，从数据或小型方法开始着手。稍大一点的方法可以等测试到位之后再移至新类中。

前面的例子展示了如何对全局数据作封装全局引用。实际上，不仅是全局数据，对于C++中 的非成员函数(也称自由函数),也可以做同样的事情。常常，当你面对的是CAPI 时，会发现你 想要改进的代码里面随处可见对全局函数的调用，这时你唯一的接缝就是被调用函数的连接期接 缝。你可以使用连接替换(296页)手法来实现分离，但实际上还有更好的选择，如果你使用封 装全局引用来建立另一种接缝的话，就能得到更佳的代码结构。下面就是一个例子：

在一块我们想要测试的代码中，有两个对全局函数的调用： Getoption(const              stringoptionName)  和SetOption(string      name,Option    option)。这两个函数是自由函数，没有附着在任何类上，但代码中到处都用到了它们，比如下面这段：
![[Pasted image 20240524143309.png]]遇到这类情况，我们可以诉诸一些老技术，如参数化方法(301页)和提取并重写获取方法 (278页),但如果这些调用跨越多个方法多个类，则使用封装全局引用就要干净…些了。做法如下， 首先创建一个新类：
![[Pasted image 20240524144025.png]]该类包含了我们所需的每个自由函数的抽象成员版本。下一步，从optionSource 派生出一  个伪类。比如说这儿我们可以让该伪类持有一个vector或map, 内含测试期间用到的option   对象。我们可以给该伪类提供一个add 成员函数，或者也可以直接让它的构造函数接受一个map,  哪种方便就选哪种。完成伪类之后，再创建真正的optionSource:
![[Pasted image 20240524144143.png]]

**要封装对全局自由函数的引用，只需创建一个接口类，然后从它派生出伪类及产品类。产品类中的代码什么都不用做，只需直接委托/调用相应的全局函数即可。

这一重构表现不错。我们引入了接缝，并最终将任务简单地委托给相应的全局API函数完成。

之后我们便可以对目标类进行参数化，让它接受一个optionSource 对象(通过指针或引用), 然后我们便可以在测试时向它传递伪OptionSource     对象，并在产品代码中传入真正的对象。

在上例中，我们将函数放入类，并把它们做成虚的。但可不可以不这么做呢?可以。我们可 以建立一些自由函数，让它们委托给其他自由函数，或者将它们做成一个新类的静态函数，但这 两种方案都不能提供良好的接缝。根据它们的做法，我们就不得不使用连接期接缝(32页)或预 编译期接缝 (29页)来替换函数实现了。然而，若是使用类/虚函数方案并辅以参数化类的话， 引入的接缝就既明显又易于掌控了。

**步** **骤
封装全局引用手法的步骤如下：
(1)找出有待封装的全局变量/函数。
(2)为它们创建一个类(你将通过该类来引用它们)。
(3)将全局变量/函数复制到该类中。如果其中有些是变量，别忘了在类的构造函数中进行适当的初始化。
(4)将全局变量/函数的原始声明注释掉。
(5)声明新类的一个全局对象。
(6)依靠编译器 (251页)帮你找出所有用到了这些全局变量/函数的地方。
(7)将所有对它们的引用加上刚建立的那个新类的全局对象为前缀。
(8)在想要使用伪对象的地方，利用引入静态设置方法(292页)、参数化构造函数(297页)、 参数化方法(301页 ) 或以获取方法替换全局引用(313页)。