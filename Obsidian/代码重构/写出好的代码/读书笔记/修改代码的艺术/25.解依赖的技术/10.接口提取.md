**25.10**  **接口提取**

在许多语言中接口提取( Extract  Interface)都是最安全的解依赖技术之一。如果某步出错了， 编译器就会立即告诉你，所以说用接口提取的时候，极少可能引入bug。接口提取的关键在于为  你的类创建一个接口，该接口包含你想要在某些上下文中使用的所有方法。完成接口之后，就可  以让你的类实现它，从而通过该接口来感知或分离(比如传递一个伪对象给你想要测试的类)。

接口提取有三种方式，以及一些注意点。
第一种方式是利用现成的自动重构工具(如果你的 IDE支持的话)。支持接口提取的工具往往会允许你选中一个类上的某些方法然后键入新接口的名 字。更好一些的则会询问你是否需要它帮你将代码中的某些地方自动改为使用新接口。这些工具 会帮你节省可观的工作量。

如果没有相应的工具，则可以采用第二种方式：即采用本节所讲的方法和步骤， 一步一步地 提取。

接口提取的第三种方式就是一次性从类里面剪切/复制出多个方法，然后将它们放到一个新 的接口中。这种做法虽然没有前两种做法安全，但仍然还算是相当不错的；而且如果没有重构工 具支持并且构建耗时很长的话，该方式往往是唯一的选择。

下 面 我 们 重 点 描 述 第 二 种 方 式 。 在 讨 论 的 过 程 中 会 提 及 一 些 需 要 注 意 的 地 方 。

我们需要提取 一 个接口来将PaydayTransaction 类置于测试之下。图25-5展示了PaydayTransaction  类的UML 图，以及它所依赖的一个叫做TransactionLog 的类。

![[Pasted image 20240524150914.png]]

要想让上面的代码通过编译，必须为TransactionLog 类提取一个接口，然后从该接口派生 出一个FakeTransactionLog,  最后修改一下PaydayTransaction,  让它能够接受FakeTransactionLog 为参数。

但首要的是接口提取。为此我们创建一个新的空类，叫做TransactionRecorder。  如果你想知道这个名字是哪来的，看一看下面的注记。

**接口命名
接口，作为一种语言结构，算是比较新的事物。Java以及许多.NET 语言都具备这一语言特性。在C++ 中你得通过创建一个只含纯虚函数的类来模拟它。
接口这个概念最初被引入语言的时候，有些人发明了用它们所来自的类的类名加上 “I”
前缀来命名的办法。例如，假设你有一个叫做Account  的类，并且想要一个接口，于是就可以 给这个接口起名叫IAccount 。 这种命名方式的好处就是不用动脑筋，只要加个前缀就行了。  但也有它的坏处，那就是你最终会发现许多代码都不知道对付的究竟是一个接口还是一个类。 当然，理想情况下你的代码应该无需关心这些。同样，最后你的代码基中将既有带“I”前缀  的名字又有不带 “I”  前缀的名字。如果你想将一个带 “I” 前缀的接口做成一个普通类的话就 会引发大规模的改动。而如果不改的话，那个名字又会作为一个微小的谎言躺在代码中。
在编写新类时，最简单的事情莫过于起个简单的类名了，即便是对于大型的抽象也是如此。 例如，如果我们正在编写一个account   包，则我们可以从一个就叫Account  的类开始。然后开 始编写测试来添加新特性。随着系统的增长，迟早你会想要把Account 做成一个接口。这时可 以在Account 下创建一个派生类，并将Account 中的所有数据和方法都转移到它里面，将 Account 架空成一个接口。这么做的好处是你无需将代码中所有引用Account 的地方修改成引 用新的接口(因为Account 本身就是那个接口)。
在 像PaydayTransaction 这样的例子中，我们已经有了一个不错的候选名字  (TransactionLog),  这时同样可以采用上面的办法。但缺点是将所有数据成员和方法统统转 移到另一个类中需要不少步骤。不过只要风险足够小，我还是会时不时用这招的。这其实就是 所谓的实现提取。
如果我觉得缺少一些测试，于是想通过提取出一个接口好让更多的测试能够安置到位的 话，常常会给这个接口起一个新名字。有时候想这么个名字也不是件易事。如果你手头缺少能 够自动重命名类的工具的话，最好在使用该接口的代码还没有大量出现之前给它起个稳定的 名字。

![[Pasted image 20240524151214.png]]
这几步之后，所有代码应当仍然完全能够通过编译，因为我们所做的只不过是引入了几个新类，并让一个既有类实现了一个空的接口。但后面就要进行真正的重构了。首先我们将想要使用 接口的地方改为对接口的引用。比如PaydayTransaction  原本使用的是一个TransactionLog;

现在我们需将其改为引用TransactionRecorder 。 然后我们编译代码，并从编译错误中发现许 多地方调用了TransactionRecorder 上的方法，我们将相应方法加到TransactionRecorder接口中来解决这些编译错误，同时也将该方法的一个空的实现加到FakeTransactionLog 中。

下面是示例代码：
![[Pasted image 20240524151454.png]]

本例中，TransactionRecorder        上唯一被调用的就是saveTransaction       方法。而由于 TransactionRecorder        接口现在还是空的，所以会遇到编译错误。但我们只需将这个方法添加 到TransactionRecorder 上便可以了，同时也别忘了往FakeTransactionLog 上添加一个空的 实现：
![[Pasted image 20240524151518.png]]任务完成!现在我们无需在测试的时候创建真正的TransactionLog  对象了。

你可能会说：“不是吧，我们还没有往接口以及伪类上添加recordError     方法呢。”没错， TransactionLog 上的确有这个方法。如果需要提取出TransactionLog 的整个接口，我们或许 的确会把recoraError 放到它上面，但实际情况是，我们的测试并不需要这个方法。尽管，把 一个类的所有公有方法都放到接口上是个不错的做法，但如果顺着这条路走下去，就有可能要做 许多不必要的工作才能将代码最终纳入测试了。如果你觉得代码的设计走向的确要求接口拥有相应类上的所有公有方法的话，不妨考虑递增式地扩充该接口。许多时候，在得到足够的测试覆盖 之前，最好避免大规模的改动。

**提取接口时并不一定要提取类上的所有公有方法。你可以依靠编译器来帮你发现哪些方法 需要加到接口上去。

该手法唯一的困难之处在于当面对非虚方法的时候。这里所谓的非虚方法在Java里面可能是 静态方法，而在C#或C+ 里面则可能是非虚成员函数。对于这类情况请参考下文的附注。

**步** **骤
接口提取的步骤如下：
(1)创建一个新接口，给它起一个好名字。暂时不要往里面添加任何方法。
(2)令你提取接口的目标类实现该接口。这一步不会破坏任何东西，因为接口上还没有任何方法。但你也可以编译确认一下。
(3)将你想要使用伪对象的地方从引用原类改为引用你新建的接口。
(4)编译系统。如果编译器汇报接口上缺少某某方法，则添加相应的方法(同时也往伪类上面添加一个空的实现),直到编译通过。