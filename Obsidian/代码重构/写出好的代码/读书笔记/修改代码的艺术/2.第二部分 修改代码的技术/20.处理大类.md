人们往系统中加入的特性其实有许多都是一些小调整。在添加它们的时候需要添加一点儿代码，或许再加上几个方法。这时候你就会发现，把这些东西添加到一个既有的类身上是一个较具诱惑力的选择。
很可能你需要添加的代码必须用到某个既有类中的数据，因此最简單的做法便是直接把代码塞到那个类当中。
遗憾的是，这种省力的修改代码的方式可能会帶来严重的麻烦。随着我们一再地往既有类中添加代码，既有类的方法和类本身就会變得越来越庞大，我们的软件会变成一个沼泽，然后你就得花上更长的时间才能搞清如何往里添加新特性，甚至连理解旧特性都会花更多时间。

有一次我去协助一个团队，该团队做了一个从纸上看来相当不错的架构设计。他们告诉我系 统中哪些类是主要类，以及通常情况下它们之间如何交互。接着他们给我看了一些展示架构的 UML 图。然而，当我看到代码时却愣住了。系统中的每个类几乎都可以被分解为大约10个类， 而这么做正是帮助他们摆脱目前面临的最紧迫问题的钥匙。

那么,庞大的类有哪些问题呢?首先就是容易混淆。如果一个类有五六十个方法，那么要想 搞清哪些东西需要修改以及你的修改是否会影响到其他什么东西往往就困难了。最糟糕的情况就是， 一个庞大的类具有多得不可思议的成员变量，对于这样一个类，我们很难知道修改一个变量 会帶来什么样的影响。另一个问题就是任务调度。如果一个类具有大约20个职责，那么很可能有许多原因要修改它，多得你忙不过来。于是你可能会遇到在同一个迭代期中好几个程序员要对该类进行不同的修改的情况。如果他们同时进行修改，就可能会导致一些严重的冲突，尤其是当考虑到第三个问题的存在的时候，即庞大的类测试起来非常痛苦。
封装是好事情，但可别对测试人 员这么说，他们可不这样想。过分庞大的类往往隐藏了过多的东西。
当封装能够帮助我们推断代码的行为，当我们知道某些特定的东西只有在特定的情况下才能被修改时，封装是好事情。
然而， 封装一旦过了头，被封在里头的东西便会腐烂发臭了。比如你没法容易地感知到修改帶来的影响， 于是只能退而采用编辑并祈祷的法子。而一旦事情到了这个地步，要么你的修改耗时漫长，要么 bug 数目增长。反正你得为代码缺乏清晰性付出代价。

如果有一个庞大的类，那么第一个需要面对的问题就是：怎样修改才能不至于令已经糟糕的 状况雪上加霜?可以使用的两个关键技术是新生类(54页)和新生方法 (52页)。当需要修改代 码时，我们应该考虑将新添的代码放进一个新类或新方法中。新生类方法能够防止系统的状况變 得更糟。没错，当你将新加的代码放进新类中时，可能会需要从原类中调用这个新类，但至少没有令原类变得更大。新生方法也有帮助，不过比起新生类来，它起到的帮助就比较微妙了。把添 加的代码放到新方法中的确会导致系统中多出一个方法来，但至少你给它所属类所做的另一件 事情起了一个名字，并在系统中把它标识出来；而且往往这些新生方法的名字能够暗示你如何 将一个类分解成更小的类。

对于庞大的类， 一个关键的补救手段就是重构。将大类分解为一组小类是有帮助的。然而最 大的问题在于要搞清楚这些小类应该是什么样子的。幸运的是，对此我们有一些指导原则。

![](file:///C:\Users\TY\AppData\Local\Temp\ksohtml32088\wps118.png)

单一职责原则描述起来有点困难，因为“职责”这个概念有点含糊。如果我们以一种非常单一的视角来看待这个概念的话，我们也许会说：“哦，那是不是意味着每个类应该只有一个方法?” 呃……方法的确可以被看成职责。比如Task 类，它的run 方法的职责是运行该Task, 它的taskCount    方法的职责是告诉我们它有多少个子任务，等等。但当我们关心的是主要意图时，“职责”这个词到底意味着什么就不是无关紧要的了。图20-1给出了一个例子。
![[Pasted image 20240523145211.png]]RuleParser 是个不大的类，它会对一个包含了一组规则表达式的字符串进行求值(该字符 串内的规则表达式是用什么语言写的我们不用关心)。顾名思义，该类的一个职责是解析。但这 还不是它的主要意图，除了解析规则之外它还进行求值。

那么,这个类还做哪些事情呢?它持有一个当前字符串，即它正在解析的串。它还有一个成 员变量，该变量保存当前解析到的位置。这两个小小的职责看起来还是属于“解析”这个职责范畴的。

RuleParser 类还有另一个成员变量variables。  它持有一组变量，这组变量被该类用来对 规则内的如“a+3” 这样的算数表达式进行求值。比如，你用a和1作为参数来调用addvariable  方法，则 “a+3”   就会被求值为4。因此，这似乎意味着该类还有另一个职责变量管理。

还有其他职责吗?另一个寻找职责的方法就是观察方法名。这些方法可以这样自然分组：
![[Pasted image 20240523145306.png]]evaluate     方法是这个类的进入点。 一共只有两个公有方法，它就是其一，它标明了该类的一 个关键职责：求值。然后，所有以Expression 为后缀的方法基本都一样。它们不仅名字相似，并且全都接受Nodes 为参数，并返回一个int   来表明一个子表达式的值。再然后就是nextTerm   和 hasMoreTerms  这两个方法，它们是用来辅助对串里面的项进行某种特殊的字元化 (tokenization) 操作的。最后，前面已经说过， addVariable  方法的作用是变量管理。

所以，总的来说， Parser 类具有如下的职责：

+ 解析；

+ 表达式求值；

+ 项的字元化；

+ 变量管理。

假设我们现在必须得从头对这个类体系进行设计，并且在我们的设计中，上面列出的职责必须是分离开的。那么我们可以做出什么样的设计呢?如图20-2所示：
![[Pasted image 20240523145438.png]]这是不是有点设计过度了?可以这么说。编写小型语言解释器的程序员们通常会把解析模块 和表达式求值模块并在一起， 一边解析一边求值。虽然这种做法比较方便，但随着语言的演化， 其在可伸缩性上面的不足就会暴露出来了。另外一个有点微不足道的职责就是SymbolTable 的 职责。如果symbolTable 的唯一职责就是将变量映射到值的话，用一个类来实现并不比用一个散列表或链表来实现具有更多的优势。所以，这虽说是个不错的设计，但相当不现实。除非我们选择重写系统的这一部分，否则这堆漂亮的多类设计只是空中楼阁。
在现实世界中，对于大型类，关键在于找出其中不同的职责，然后想出一个方案能够逐步向 更集中的职责发展。

**20.1** **职责识别**

在上一节的RuleParser     例子里，我展示了一种将这个类分解为一组小类的做法。实际上在 做那个分解的时候基本是依葫芦画瓢的。把所有方法都列出来，然后就思考它们的意图是什么。 我问自己的两个关键的问题就是，“这个方法为什么在这儿?”“它为这个类做了什么?”接着把 这些方法分组，将具有相近目的的方法放在一起。

我把这种职责识别的方式叫做方法分组。当然，方法远不止这一种。

识别职责是一个关键的设计技能，而且需要锻炼才能掌握。
你可能会觉得在一本关于如何对付遗留代码的书中谈论设计技能有点不伦不类，但其实从现有代码中发现职责跟描述出尚未编写的代码的职责并没有太大的区别。
关键是要能够看清职责并学习如何将它们很好地分离开来。如果硬要说它们之间有什么区别的话，遗留代码比起新加特性来说，它提供了多得多的运用设计技能 的机会。当会被你的设计所影响的代码真实地存在眼皮底下时，谈论起设计权衡来会更容易一些， 同样，也更容易知道某个结构在特定上下文中是否合适，因为上下文就真实地存在于我们面前。

本节描述了一组可以用于在既有代码中识别出职责的启发式方法。注意，我们并没有创造出新的职责，而仅仅是识别出本就存在的职责。不管你的遗留代码具有什么样的结构，组成它的部件所干的事情肯定都是可识别的。但有时候比较难以识别，这时便可以借助于这里介绍的技术了。 你甚至可以试着把它用到并不需要立即修改的代码上去。对代码内在的职责越是关注，你就越了 解代码。

**探索式方法#1:方法分组
寻找相似的方法名。将一个类上的所有方法列出来(别忘了它们的访问权限),找出那些 看起来是一伙的。

这种方法分组的技术是个相当好的开始，尤其对于大型类而言。关键是要认识到，并不需要将所有方法都分组放到新类中去。你只需看看能否找到一些看上去属于同一职责的方法就行了。 然后，如果能够找到一些有点偏离类的主要职责的职责，你心里对代码如何改进也就有了一个大 概的方向了。然后你就等待，直到必须得去修改那些你已经分好类的方法时再决定是否要提取出 一个类来。

方法分组还是一个极佳的团队练习。放上一块黑板，上面列出你们的每个主要类里面的所有 方法名。团队成员可以在上面做标记，指出不同的方法分组方式。而整个团队则可以共同筛选出 比较好的那些分组方式，并决定代码今后的走向。

**探索式方法#2:观察隐藏方法
注意那些私有或受保护的方法。大量私有或受保护的方法往往意味着一个类内部有另一个类急迫地想要独立出来。

庞大的类可能会隐藏很多东西。对于刚刚接触单元测试的人来说，这个问题总是会困扰他们。 比如“我怎么才能测试私有方法呢?”许多人花了大量时间试图避开这个问题，然而正如我在前面的章节中所说，真正的答案是，如果你迫切需要测试一个私有方法，那么该方法就不应该是私有的；如果将它改为公有会帶来麻烦，那么可能是因为它本就应属于另一个独立的职责。它应该在另一个类上。

前面提到的RuleParser     类就是个很好的例子。它有两个公有方法： evaluate     和 addvariable。  除此以外其他所有东西都是私有的。现在，假设我门将nextTerm 和hasMoreTerm  也设为公有，会发生什么事情呢?呃……会令RuleParser     类看起来相当的怪异。使用RuleParser的人可能会认为他们需要使用这两个方法结合evaluate 方法来解析并求值表达式。的确，讓 nextTerm  和 hasMoreTerm  成为RuleParser     类的公有方法是比较怪异，但若是把它们放到一个 新类TermTokenizer     上面作为公有方法的话就好得多了，甚至可以说是完全合适。这么做并不会损害RuleParser     的封装性。因为虽说nextTerm   和hasMoreTerm   在TermTo-kenizer       上面是公有的，但在RuleParser     里面却是被“私下地”访问的。如图20-3所示：
![[Pasted image 20240523145908.png]]

**探索式方法#3:寻找可以更改的决定
寻找代码中的决定——这里所说的“决定”并非指你正在做的决定，而是指已经作出的决定。比如代码中有什么地方(与数据库交互、与另一组对象交互，等等)采用了硬编码吗?你 可以设想它们发生变化后的情况吗?

人们在试图去分解一个庞大的类时往往容易把大量精力花在关心那些方法名上。因为毕竞方法名是一个类里面最引人注意的东西之一。然而，方法名并不代表一切。通常，对于一个大型类 而言，它里面的方法会在许多不同的抽象层面做许多事情。例如， 一个叫做updatescreen的方法可能会给显示屏生成文本，格式化然后发送到好几个不同的GUI对象那里。这时如果光看方法 名，你是没法知道背后真正发生了多少事情以及它里面到底隐藏了多少职责的。

因此，在真正开始拿类开刀之前，最好先对它的方法做一点方法提取。应该提取什么样的方法呢?
我的做法是寻找代码中的决定。
代码中对多少东西作了假设?代码调用了某个特定API中 的方法吗?代码是否假定它将总是访问同一个数据库?
如果你的代码作了以上这些事情，那么我 建议你最好提取出一些能在较高层面反映你的意图的方法。如果你的代码从某个数据库中获取特定的信息，那么你可以提取出一个方法，给它起一个能够反映你所获取的信息的名字。做完这些方法提取之后会多出许多新的方法，但你同样可能会发现方法分组变得更容易了。
更好的是，你可能会发现你已经把某些资源完全封装在一组方法之后了。从而当你为这些方法提取出一个类时， 一些底层细节上的依赖也就被你解开了。

**探索式方法#4:寻找内部关系
寻找成员变量和方法之间的关系。“这个变量只被这些方法使用吗?”

随便找一个类来几乎总能发现其中并非所有的方法都使用了所有的成员变量。形象地说， 一 个类里面的方法总是堆成一团一团的。比如一组共三个成员变量，也许用到了它们的方法总共也就两三个。这种“抱团”的现象通常可以借助于方法名看出来。例如在RuleParser 类中就有一 个叫做variable 的Collection, 以及一个叫addVariable 的方法。这就显示出该方法和该变 量之间有明显联系。虽然它并没有告诉我们其他还有哪些方法使用了这个变量，但至少我们有了 一个寻找的起点。

还有另一项技术也可以用于寻找这种方法抱团的现象，那就是给一个类内部的关系画一张草 图。这种草图叫做特征草图(feature sketch')。特征草图展示了一个类里面的每个方法使用了哪 些成员变量以及其他方法。下面就是一个例子：
![[Pasted image 20240523150308.png]]第一步是为每一个成员变量画一个圈，如图20-4所示：

接着我们观察每个方法，也给它们各自都画一个圈。然后在任一方法与该方法用到的任何成 员变量或方法之间画一个带箭头的线。通常我们不用考虑构造函数，因为一般来说构造函数会修改每个成员变量。

图20-5 展示了初步的结果，其中，我们从extend() duration 上。
![[Pasted image 20240523150345.png]]如果你已经阅读过了介绍影响结构图的章节，你可能会注意到，这些特征草图跟影响结构 图十分相像。实际上的确是这样，它们本来就相当接近。主要区别在于图中箭头的方向恰恰相  反。在特征草图中箭头是指向被使用的变量或方法，而在影响结构图中箭头则是指向被影响的  变量或方法。

特征草图和影响结构图是两种不同但同样完全合法的、描绘系统内交互的方式。要想反映 类的内部结构，特征草图再合适不过了。而若是想从一个修改点开始推测影响传播的线路，则  影响结构图是得力工具。

那么,它们长得这么相似会不会混在一块搞不清谁是谁呢?其实不会。这些草图是属于那 种用完就丢的工具。也就是说在你进行修改之前，和你的同伴坐下来，花上十分钟描描画画，之后就可以把它们扔了。留着也没什么意思，所以基本不可能会混在一起分不清。
![[Pasted image 20240523150424.png]]那么,从这张草图中我们可以看出什么来呢?首先很明显的一点就是其中存在聚集的现象。 duration、dailyRate、data   以及customer 变量主要是被getPrincipalFee、extend    以及  extendForWeek    使用到的。这三个方法里面有公有的吗?有， extend    和extendForweek     就是， 但getPrincipalFee         不是。如果我们将这一块切出来，做成一个它们自己的类，系统会变成什么样子呢(见图20-7)?
![[Pasted image 20240523150502.png]]上图中的那个大圆圈可以做成一个新类。extend、extendForweek  以及getPrincipalFee

需要被设为公有方法，但其他所有方法都可以是私有的。我们可以将fees、addFee、getAdditionalFees以及getTotalFee 保留在原类Reservation       中，并将有关任务委托刚才 那个新类来完成，如图20-8所示：
![[Pasted image 20240523150553.png]]在试图这么做之前，有一个关键的问题要先弄清楚，那就是这个新类是否具有一个良好的、 清晰的职责。我们能否替它想出一个名字来?答案是这个新类似乎会做两件事情： 一是将一个预定 (reservation)    延 期 (extend、extendForWeek),      另 一 是计算所谓的主要费用(getPrincipalFee)。   所以似乎Reservation 是个不错的名字，但可惜这名字已经被原来那个类用掉了。
其实我们还有另一种选择。刚才我们是把大圈圈里面的所有元素提取出来，现在我们反过 来，把小圈里面的提取出来，如图20-9所示：
![[Pasted image 20240523150640.png]]我们可以把提取出来的类叫做FeeCalculator。   这种做法是可行的，但getTotalFee 方法 就需要调用Reservation上的getPrincipalFee         了——对吧?
!如果我们先调用getPrincipalFee,   然后将得到的值传递给FeeCalculator,   可不可以呢?代码大致如下：
![[Pasted image 20240523150728.png]]们甚至可以考虑将getPrincipalFee 移至FeeCalculator 类中，从而令该类的职责跟它

的类名更一致，然而考虑到getPrincipalFee 依赖于Reservation 类中的好几个成员变量，所以最好还是把它留在Reservation 里。 
特征草图在寻找类中的独立职责方面是个极好的工具。我们可以试着将一个类的特征(方法跟成员变量)进行分组，然后看看能基于这些名字提取出什么类来。但除了能够帮助我们找出职 责之外，特征草图还能帮助我们看清类中的依赖结构，在我们决定应该把哪些东西提取出来的时 候，它往往显得和职责一样重要。比如，本例中有两块比较“密集”的特征聚集。它们之间的唯 一联系就是getTotalFee    在内部对getPrincipalFee       的调用。在特征草图中，这类联系往往会 以大块特征聚集团之间的寥寥几根连线表现出来。我把这些点叫做汇点，第12章对此有详细讨论。 有时候你会发现一张特征草图上找不到任何汇点。是的，并非每张草图都有汇点。但至少草图仍然能够帮助你看清方法名以及类中各元素之间的依赖关系。
有了特征草图之后，就可以试用各种不同的方式来分解类了。首先可以将一组组的特征用圆 圈圈起来。在画圈的时候，被圈所“切断”的线即意味着新类的接口。你可以一边画圈一边为每 组特征想出一个类名来。坦白的说，撇开你在提取类时进行的那些抉择，这是个很好的提高命名 技术的方法，此外还是个不错的探索设计方案的途径。

**探索式方法#5:寻找主要职责
尝试仅用一句话来描述该类的职责。

[单一职责原则告诉我们， 一个类应该具有单一的职责。如果情况的确如此，那么应该很容易就用一句话把它概括出来]。
在你的系统内找出一个大类，试试看能否仅用一句话来描述其职责。 随着你不断发现该类的客户期望以及需要的东西，句子会变得越来越臃肿，“这个类会做‘这个’、 ‘这个’,还有‘这个’,‘那个’……。”你得问自己：所有这些事情里面，存在一个比其余事情  都要重要的吗?如果有，那么恭喜你，你或许已经发现了该类的关键职贵。其余职责或许应该被 分解到其他类当中去。

单一职责原则的违反有两种形式。 一是在接口层面违反，二是在实现层面违反。当一个类的接口呈现出负责多样事务的形态时，它就在接口层面违反了单一职责原则。例如，该类的接口(图 61    20-11)看上去就似乎能够被分解成三到四个类。

![[Pasted image 20240524083954.png]]
然而我们最为关心的SRP 违反还是实现层面的。简单地说就是，我们关心的是该类是否真的做了这些事情，还是仅仅将其委托给其他的类来完成。如果属于后者，那么该类并不能算是一个 巨大的单片类；而只不过是一大帮小类的“前端”,一个更容易掌控的facade(门面类)。

 图20-12就展示了这样一个类，scheduledJob       类将一系列的职责委托给另外几个类来完成
 ![[Pasted image 20240524084046.png]]
 这样一来虽说在接口层面仍然违反单一职责原则，但在实现层面情况就好一些了。

那么,如何在接口层面也解决这个问题呢?那就要困难一点了。 一般步骤是首先看看被委托 任务的那些类是否可以直接被客户使用。例如，假设只有某些客户对运行ScheduledJobs      感兴 趣 ， 则 可 以 像 这 样 进 行 重 构 ( 图 2 0 - 1 3 ) :
![[Pasted image 20240524084124.png]]
现在，那些只想对任务进行控制的客户就可以通过JobController接口来使用scheduled-Job 对象了。这种为一组特定用户量身定做一个接口的设计手法能够保持你的设计符合接口隔离原则 (ISP)。

**接口隔离原则** **(ISP)
如果一个类体积较大，那么很可能它的客户并不会使用其所有方法。通常我们会看到特定 用户使用特定的一组方法。如果我们给特定用户使用的那组方法创建一个接口，并让这个大类 实现该接口，那么用户便可以使用“属于它的”那个接口来访问我们的类了。这种做法有利于 信息隐藏，此外也减少了系统中存在的依赖。即当我们的大类发生改变的时候，其客户代码便 不再需要重新编译了。

一旦为客户量身定做了接口之后，往往就可以开始将代码朝更好的方向改进了:原本是
大类，现在我们可以新建一个类，让这个类使用原来的大类，如图20-14所示:
![[Pasted image 20240524084302.png]]这下我们不再是让ScheduledJob把任务委托给JobController. 而是反过来，让后者委
托前者。这样 来，不管什么时候，只要客户想要运行 ScheduledJob，它就可以创建
JobController ，并传递个ScheduledJob对象给它，然后便可以利用这 JobController
来控制任务的执行。

不过真正做起来时，这利'重构几乎总是比它听起来要更困难。通常，为了完成这 重构，你得在原类 CScheduledJob) 上暴露更多的公有方法，以便让新的"前端"类 CStandardJobController) 能够访问到足够多的功能来完成它的工作。这类修改往往需要相当大的工作量。
客户代码需要更改，这样它们才能从使用旧类转变为使用新类:而要想安全地完成这 更改，你又得先把有关 客户代码用测试护住。不过这 重构最大的好处就是它使得你能够 点点地对一个大类的接口进行削减 在我们的例子中可以到， 后的ScheduledJob具有JobController里的那些方法了

**探索式方法#6:当所有方法都行不通时，作一点草稿式重构
如果实在很难看清一个类内部的职责，那么可以对它作一点草稿式重构

草稿式重构 (174页)是个强大的手段。但是，你得记住，草稿式重构只能看作是一次“模 拟演习”。你在草稿式重构时看到的代码并不一定是后面真正重构时得到的。

**探索式方法#7;关注当前工作
注意你目前手头正在做的事情。如果发现你自己正在为某件事情提供另一条解决方案，那 么可能便意味着这里面存在一个应该被提取并允许替代的职责。

人们很容易就会被类里面数量庞大的职责吓住。别忘了，你正在进行的修改就等于是在告诉 你该软件可以按某种特定的方式改变。通常只要认识到这种改变的方式就足以将你编写的新代码 看作一个独立的职责了。

**20.2**  **其他技术**

上文介绍的探索式方法可以很好地帮助你深入了解并寻找出旧类里面的新抽象，但说到底它们只是小技巧。要想真正很好地认识你的代码内的职责，还是只有多读，包括读关于设计模式的书，更重要的还是读其他人编写的代码。花点时间来阅读开源项目的源代码，看看其他人是怎么做的。

[读的时候注意别人是如何命名系统里面的类的，此外还有类名与方法名之间的对应关系] 

渐渐地，你就会在识别出隐藏职责方面更加得心应手，并且在浏览不熟悉的代码的时候也能够发 现它们。

**20.3** **继续前进**

当你在一个大类中识别出了一系列不同的职责之后，就只剩下两个问题要解决了：战略和战术。先来看看战略。

**20.3.1**   **战略**

在识别出了所有独立的职责之后，我们该干些什么呢?应该花上一周的时间把这些大类都重 整一遍吗?应该把它们都化整为零吗?如果你有这个时间，那再好不过。但实际上这种可能性很小，而且这一过程也有一定风险。就我所见过的有关案例中，几乎毫无例外的，当一个团队进行 一番大规模重构时，系统稳定性就会有一段时间的下跌，即便他们干得再仔细， 一边编写测试一 边重构，还是如此。当然，如果你们仍处在发布周期的早期，愿意承担这样的风险，且有时间， 那么一次大规模重构也并非不可。只要记得别让那些bug搞得你不再想去做其他重构就是了。

  要分解大型的类，最佳步骤就是先确认出职责，并确保团队里的每个人都理解了这些职责， 然后在需要的时候再去对该类进行分解。这种做法其实就是把修改的风险给减小了，从而让你能 够在这个过程中同时完成其他事情。

**20.3.2**   **战术**

对于大多数遗留系统而言， 一开始你所能奢望的也就是能够在实现层面运用单一职责原则 了：本质上这意味着从大类中提取出新类，然后把一些任务委托给这些新类。另一方面，在接口层面引入SRP就要麻烦一些了。类的客户代码需要改动，所以你得先给它们编写测试。不过还算  好的是，实现层面SRP的引入有助于后面在接口层面的引入。让我们先来看一看实现层面的内容。

具体用什么技术来进行类提取取决于众多因素。其一就是要考虑给那些被影响到的方法编写 测试的难易程度。最好先看一看你的类，列出所有需要被移动的成员变量和方法。这么一来，对 于应该给哪些方法编写测试，你心里就应该有数了。就拿我们前面提到的那个RuleParser     类来 说，如果考虑分解出一个TermTokenizer     类，那么可能需要将string    类型的成员变量current、int  型的成员变量currentPosition 、     以及方法hasMoreTerms    和nextTerm   移动到新类中。然而，由于hasMoreTerms 和nextTerm 都是私有方法，因此我们无法直接为它们编写测试。当然， 我们可以先将它们改为公有的(反正它们要“搬家”了嘛)再进行测试的编写，但在测试用具里  头创建一个RuleParser 并通过它对一组字符串求值可能也同样容易。完成这些之后我们便有了 覆盖hasMoreTerms   和nextTerm   的测试，从而能够安全地将它们转移到新类当中去。

遗憾的是，许多大型的类都很难在测试用具中实例化。关于这个问题，参考第9章，里面有 一组可以用于解决这类问题的技术。如果你已经能够在测试用具中实例化你的类，则仍可能需要 利用第10章所讲的技术来帮助你将测试安置到位。

一旦将测试安置到位，你便可以用一种非常直观的方式来提取类了，即利用Martin Fowler在《重构：改善既有代码的设计》一书中提到的类提取重构。然而，如果无法将测试安置到位的话， 仍然还是有办法的，尽管可能就要危险一些了。下面就是在测试无法安置到位的情况下可以采取的步骤(注意，这是一个非常保守的策略，并且无论你手头是否有重构工具，该方案都可行)。 (1)确定出一个你想要分离到另一个类当中的职责。

(2)弄清是否有成员变量需要被转移到新类当中。有的话就将它们放到类体内的一个单独的 声明区段，跟其他成员变量区分开来。

(3)如果一个方法需要整个儿被移至新类中，则将其函数体提取出来，放入新方法，别忘了新方法的名字要跟旧方法一致，除了一点不同，即新方法的名字前加了个前缀，比如MOVING (全大写)。 如果你没有用重构工具，那么要记住在做方法提取的时候利用签名保持(249页)手法。最后，每提  取一个方法就把它放入前面所说的那个单独的声明区段，即跟待转移的那些成员变量放在一起。

(4)倘若一个方法只有一部分需要被转移，就将它们从“原住地”提取出来，同样利用MOVING 前缀来标识它们栖身的新方法，并将后者放至那个单独的区段。

(5)到此，类里面应该就有一个区段放的全是待转移的成员变量和方法了。在当前类和当前 类的所有派生类中作一次文本搜索，确保你要转移的成员变量里面不存在某个被要转移的方法集

  
之外的方法使用到的变量。这一步不应依靠编译器(251页),恪守这一点很重要，因为在许多面 向对象语言中， 一个派生类里面可以声明与基类里某个成员变量同名的成员变量。这通常被称为 名字隐藏。因此如果你的类里面有变量隐藏了其基类中的同名变量，同时(除了你要转移的方法 之外)还有一些方法是使用了该变量的，那么贸然将该变量转移走可能就会改变代码的行为'。 同样道理，如果你依靠编译器来试图发现那些使用了你即将移走的变量的方法，那么一旦你移走 的某个变量名字隐藏了基类中的某个变量，则你的编译器将不会帮你发现所有的这类方法——将 一个名字隐藏变量注释掉然后重编译只会让那些使用它的方法转而使用基类中同名的变量而已。

(6)到此，你已经可以将前面分离好的成员变量和方法一并转移到新类当中去了。然后在原 类中创建新类的对象，接着就依靠编译器来发现哪些地方应该调用新类上的那些方法吧。

(7)在完成“搬家”工作，并且代码也顺利编译了之后，便可以将新类上那些方法的MOVING 前缀去掉了。最后，还是依靠编译器帮你找到那些需要相应修改名字的地方²。

前面这番重构的步骤是相当复杂的，但如果你面对的本来就是一堆非常复杂的代码，则要想 不用测试就安全地将它们提取出来，这样复杂的步骤还是必要的。

在没有测试的情况下进行类提取可能会遇到一些不测。其中最难觉察的就是可能会引入与继 承有关的bug。将一个方法从一个类移至另一个类是相当安全的，你可以依靠编译器的帮助，但 对于大多数语言来说，倘若你试图移走一个重写了另一方法的方法，情况就不妙了，原类中对这 个被移走方法的调用将会变成对基类中同名方法的调用。对于成员变量也存在类似的现象。派生 类中的成员变量会隐藏基类中的同名变量。移走前者便会让后者暴露出来。

因此，为了解决这个问题，我们根本就不移走那个方法。而是通过提取原方法的函数体来创 建新的方法。其中给新方法加的前缀只是为了避免在移走它们之前与原方法产生名字冲突。另一 方面，成员变量的情况则要微妙一些：我们得在移走它们之前手动搜寻哪些方法使用了它们。这 一过程是有可能出错的，所以须得非常小心，建议跟你的伙伴一起完成这一工作。

**20.4**  **类提取之后**

对一个庞大的类进行类提取通常是个好的开始。在实践当中我们发现，团队在做这项工作时 面临的最大危险便是野心过大。你可能已经对这个类做了一些草稿式重构(174页),或是已经对 该系统应该成什么样子建立起了一些其他的看法。但是请记住，你目前的系统结构在应用当中能 够工作，它提供了软件的功能；它可能还没有准备好向前迈进。有时候，你所能做到的也就是建立起对一个大型类在重构之后的样子的“愿景”,然后再把这个愿景给放一边去。这么做只是为 了去发现什么是可能的。要想真正让代码向前推进，你得敏锐地关注代码中的现状，并小心地向 前改进(不一定要朝着你心目中理想的设计改进，但至少可以向更好的方向改进)。