假设我们现在需要作一些代码修改，并且需要编写特征测试(153页)来“固定”住己有的 行为，那么应当为哪些地方编写测试呢?最简单的答案就是为我们所要修改的每个方法都编写测试。但这就够了吗?如果代码较为简单且易于理解的话的确是够了，但对于遗留代码来说，往往 并非如此。 一个地方的改动可能会影响到其他地方的行为；除非有测试“坐镇”,否则我们可能永远也不知道自己的修改造成了什么影响。

当需要在特别错综复杂的遗留代码中作改动时，我通常会先花点时间考虑一下应当在哪儿编写测试。这一过程包括考察将要进行的改动，看看它会带来哪些影响，看看被影响的东西又进而 会对哪些东西造成影响，后者又会造成哪些影响……。这种推理方式并不新鲜，人们在计算机的 启蒙时代就这么做了。

程序员们可能会因为各种各样的原因而坐下来对他们的程序进行推理。有意思的是，对此我 们谈论得并不多。我们只是假设每个人都知道怎么做，以及假设这是程序员的“份内之事”。然 而当我们面对的是错综复杂的、不易理清的代码时，光是嘴上说说是无济于事的。我们知道应该 对代码作一点重构来让它更易于理解，但前面遇到过的测试困境又出现了：如果没有测试在手， 我们又如何能知道正在进行的重构是正确的呢?

本章描述的技术填补了这个空白。看来，对于遗留代码，通常我们的确得花点功夫来推测一 下代码修改会产生哪些影响，以便找到编写测试的最佳地点。

**11.1**  **推测代码修改所产生的影响**
虽说在业界我们就这个问题谈论得并不多，然而实际情况是，每对一个软件作一次功能上的 改动，都会带来一连串互相关联的影响。例如，假设我们将下面这段C#代码中的3改为4,就会影 响到该函数的返回值，并进而影响到调用该函数的函数的返回值……一路影响下去，直到遇到某 种系统边界为止。话虽如此，仍有许多代码的行为还是跟以前一样。由于并没有调用 getBalancePoint(),   所以它们给出的仍是原来的结果。
![[Pasted image 20240523111428.png]]

**IDE对代码影响分析的支持
有时候真希望有个IDE能帮我在遗留代码中“看到”代码修改所产生的影响。想象这样一 种情景：选中某块代码，敲下一个快捷键，于是IDE便给出了对该块代码作改动所可能影响到 的所有变量和方法的列表。
或许有一天人们会开发出这样的工具。但在那一天到来之前我们还是得学习如何在没有工具的情况下仅凭大脑去推测代码修改的影响。这个技能学起来不难，但我们很难知道何时才算 正确掌握了它。

要想了解影响推测是个什么概念，最佳途径就是从实例入手。下面就是一个Java类，该类所 属应用程序的功能是操纵C++ 代码。这听起来似乎太专业，但其实在推测代码修改的影响时，有 没有相关的领域知识并不重要。

让我们来做一个小练习。下面是一个名为Cppclass  的类，列出其中所有能够在CppClass 对象创建之后被改变，从而对其方法的返回值产生影响的东西。
![[Pasted image 20240523111738.png]]你的答案看起来应该像下面这样：

(1)可以在declarations  列表被传递给CppClass 的构造函数之后'再往它里面添加额外的 元素。由于该列表是按引用传递给cppclass 的构造函数并由CppClass 的declarations 成员变 量按引用持有的，因此对它的改动会影响到getInterface、getDeclaration以 及 getDeclarationCount 的结果。

(2)可以改动或替换declarations   列表内的元素，同样还是影响到那几个方法。
有些人看到getName()   可能会想，如果有人改动了成员变量name 的话，它的返回值便也 被改变了，然而实际上，在Java中 ，String 对象是常性的。也就是说它们一旦被创建，值就 无法改变了。所以，在CppClass   对象被创建出来之后，其getName()   使总会返回同样的 String 值。

下面的一幅图展示了对declarations  的改动是怎样影响到getdeclarationCount()   的
![[Pasted image 20240523111931.png]]

![[Pasted image 20240523111945.png]]
这种图的规则并不复杂。我把它们称为影响草图'。作图的关键是：为每个可能会被影响到 的变量以及每个返回值可能改变的方法画一个单独的椭圆。这些变量可能来自同一个对象，也可 能来自不同的对象。究竟属于何者并不重要，我们只需为每个会改变的东西画上一个椭圆，并从 它们出发画一个箭头指向那些因它们的改变而在运行期改变的东西 。

![](file:///C:\Users\TY\AppData\Local\Temp\ksohtml32088\wps77.png)

1.后文也有称“影响结构图”、“影响结构示意图”的，意思一样。 ——译者注

  

让我们把视野放远一点，看一下Cppclass   所处系统的影响结构图。Cppclass    对象是在一个 名为classReader 的类中被创建出来的。实际上，我们已经能够确定，它们仅在classReader  中被创建。
![[Pasted image 20240523112024.png]]记得我们之前对CppClass  有哪些了解吗?当时我们能否知道一个Cppclass   对象在被创建 出来之后，它所持有的declarations 列表会不会再改变呢?这个问题是没法在Cppclass 那儿 找到答案的，我们需要弄清楚declarations 列表是怎么被填充的。如果进一步考察上面这个类， 便能看出，ClassReader 中只有一处地方往declarations 列表中添加了Declaration 对象， 那就是在matchVirtualDeclaration         方法当中。具体过程为：parse()    中调用了matchBody(),    后者进而调用了下面这个matchvirtualDeclaration  方法：
![[Pasted image 20240523112058.png]]