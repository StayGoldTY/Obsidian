说实话这个标题可能存在一点争议性——当然并不是只有在面向对象语言中才能安全地修 改代码，所有语言中都可以，只不过有些语言要比其他语言容易些。尽管如今面向对象思想已经 在业界遍地开花，但这并不代表就不存在其他的语言，其他的编程方式了。比如我所知道的就有 基于规则的编程语言、函数式编程语言、基于约束的编程语言……等等。然而，所有这些语言 里面，没有哪一个能像古老的过程式语言(如C 、COBOL 、FORTRAN 、Pascal    以及BASIC)   那 样分布广泛。

遗留系统中的过程式代码尤其棘手。我们知道，修改代码前一个很重要的事情就是先要把代码置于测试之下，然而对于过程式代码来说，要想引入单元测试，可用的手段实在不多。通常最简单的做法就是冥思苦想，给系统打上补丁，然后祈祷你的修改是正确的。

只要是过程式的遗留代码，普遍都面临这个测试困境。过程式代码往往不具备面向对象(以及许多函数式)代码中的那些接缝。聪明的开发者可以通过小心掌控它们的依赖来解决这个问题 (比如就有许多优秀的代码是用C 写的),但同样只要一不小心，就会写出糟糕透顶，难以一步步 验证并修改的代码来。

由于解开过程式代码中的依赖是如此之难，因此最佳策略往往是在做任何事之前先将一大块代码置于测试之下，然后在修改的过程中利用这些测试来获得一些反馈。第12章所讲的技术可以给 你带来一些帮助。它们除了能用于面向对象代码之外，同样也能用于过程式代码。简而言之，找到汇点(149页)然后使用连接期接缝(32页)来适当对代码进行解依赖从而使其能被放进测试用具 中，这是个有价值的尝试。如果你使用的语言支持宏预处理，则还可以使用预处理期接缝(29页)。

以上只是标准流程，并非除此之外别无他法。本章接下来将要介绍一些用于在过程式代码中进行局部解依赖的技术，以及怎样才能更轻松地进行可验证的修改，此外还有一些技术是用来对 付代码可以往面向对象方式迁移时的情况。

**19.1** **一个简单的案例**

过程式代码也并非总是那么难以入手。这里就有一个例子， set_writetime  是Linux操作系统中的一个C 函数。如果我们得对它进行修改，给它编写测试是否会很难呢?
![[Pasted image 20240523142326.png]]要测试这个函数，只需设置jiffies变量的值；创建一个buffer_head并将其传给该函数， 然后在调用之后检查它的值。然而对于许多函数来说事情不是这么容易的。有时候一个函数会调 用另一个函数，后者又会调用第三个函数……最后调用了一个麻烦的函数：比如一个I/O函数， 或者一个来自某供应商的库函数。我们的目的是想测试一下这个代码干了什么,然而答案往往是： “它的确干了些很酷的事情，但这些事只有在程序之外的某处地方才能知道，你没法知道。”

**19.2** **一个棘手的案例**
假设我们想要修改下面这个C函数。首先想把它置于测试之下，再进行修改：
![[Pasted image 20240523143406.png]]
这段代码调用了一个叫做ksr_notify 的函数，后者具有一个很糟糕的副作用，它会把一个 通知写到一个第三方系统里，然而我们在测试的时候宁愿它没有这个副作用。

一个办法就是使用连接期接缝(32页)。如果我们想要使测试期间某个库里面的所有函数的副作 用都消失，可以自己做一个“伪库”来替代它，“伪库”里面的函数名字跟“真库”里的对应，不同的是伪函数什么也不做。比如在我们的这个例子中，可以写一个赝品的ksr_notify, 如下所示：
![[Pasted image 20240523143449.png]]我们可以把上面这个ksr_notify     放在一个库中，构建该库，然后把它连接到刚才那个程序。 这么一来，scan_packets     这个函数的行为基本完全没有改变，只是它不会发出通知了。但后者  其实并不要紧，因为我们本就想要在修改scan_packets     函数之前将它的其他行为“钉牢”。

那么,该使用上面的这个策略吗?不一定，要看具体情况。如果kst库中有许多函数，并且我们把这些函数看成系统主逻辑的“外围设施”,建立一个包含伪函数的库并连接到它是有意义 的做法。而另一方面，如果我们想要通过这些函数来进行感知，或者如果我们想要改变它们返回 的某些值的话，则使用连接期接缝并不是个好选择，甚至可以说是相当麻烦。由于函数的替换发 生在连接期，因此对于构建的每一个可执行文件，我们只能提供唯一一份函数定义。如果想要一 个伪造的ksr_notify     在测试中具有一种行为而在另一个测试中具有另一种行为，就得在测试中 设置一些条件，并在其函数体里面添加一些逻辑来判断该条件，从而调整函数的行为。总而言之挺麻烦。然而无奈的是，在许多过程式语言面前我们别无选择。

在C里面还有一个可行的方案。C支持宏，因此我们可以利用它来简化我们给scan_packets 函数编写的测试。比如在我们添加了测试代码之后，包含scan_packets     的文件如下：
![[Pasted image 20240523143552.png]]
在上面的代码中，我们引入了条件编译，它的作用是当TESTINC被定义的时候将ksr_notify 替换为空。此外里面还提供了一小段测试代码。

将测试和源代码像这样混在同一个文件中显得不是十分清晰，往往会令代码难以浏览。 一个替代方案就是使用文件包含，让测试和产品代码分别位于不同的文件中：
![[Pasted image 20240523143644.png]]这样修改了之后，代码看起来就跟没有测试时的样子差不多了。唯一的区别就是文件底部多 了一个#include   语句。如果我们前导声明了被测试函数，就可以进一步把这个testscanner.tst文件中的所有内容都放到顶上那个#include 的文件(scannertestdefs.h) 中去。
要运行该测试，只需定义TESTING宏，然后单独构建这个文件。当TESTING宏被定义时， testscanner.tst        中的main() 函数就会被编译并连接到最终的可执行文件中，从而负责运行起 测试来。testscanner.tst 中的main()函数只对scan_packets 的扫描例程进行测试。实际上 我们还可以定义多个单独的测试函数，每个对应一个测试，然后一起调用它们，如下所示：
![[Pasted image 20240523143742.png]]我们还可以进一步进行扩展，比如添加注册函数，使得测试的群组变得更容易。具体细节可 参考www.xprogramming.com    上的C单元测试框架。

尽管宏预处理很容易被误用，但在这儿的情况下它们倒是真的很有用的。文件包含和宏替换 可以帮助我们战胜哪怕最棘手的代码里面存在的依赖。实际上只要把这些丑陋的宏使用局限在测 试代码下，就无需过分担心我们对宏的误用会影响到产品代码。

C是主流编程语言里面为数不多的几个还支持宏预处理的。 一般来说，对于其他过程式语言， 要想进行解依赖，只能使用连接期接缝，并努力将更大块的代码纳入测试之下。

**19.3** **添加新行为**

对于过程式遗留代码而言，最好遵循一条原则，即宁可引入新的函数也不要把代码直接添加 到旧代码中。因为至少我们可以给我们引入的新函数编写测试。

那么,如何才能避免往过程式代码中引入依赖陷阱呢?一个办法(见第8章)就是使用测试 驱动开发 (TDD,74    页 ) 。TDD 方法不仅适用于面向对象代码，也同样适用于过程式代码。在考 虑编写一段代码前先试图写出其测试来，这样的做法往往会引发我们对代码的设计进行改良。我 们只管先编写能够完成某些计算任务的函数，然后再把写好的函数集成到系统中去。

但为此我们通常得换个角度来审视将要编写的代码。比如，我们需要编写一个叫做 send_command的函数。该函数会通过一个名叫mart_key_sena      的函数发送一个ID 、一个名字、 以及一个命令字符串给另一个系统。可想而知，这样一个函数的代码应该是比较简单的。我们可以想象得出，它的代码应该像这样：
![[Pasted image 20240523143831.png]]
然而，对这个函数，我们如何给它编写测试呢?尤其是，要想弄清这个函数做了什么,唯一 的办法就是从mart_key_send    入手。稍微换一换思路如何?

我们可以把这个函数里面位于mart_key_send 调用之前的逻辑取出来，作为另一个单独的 函数。为此我们编写测试如下：
![[Pasted image 20240523143914.png]]很多时候这种简单的“变形”恰恰是我们所需要的。我们将所有非依赖逻辑放到一组函数中， 从而使它们远离问题依赖。这番工作之后，我们往往会得到一些像send_command 这样的薄薄的  外覆函数，它们的作用就是将刚才取出来的逻辑与依赖混合到一起。当然，以上做法并非十全十 美，但在依赖并不到处泛滥的情况下还是挺可行的。

而另一些时候，我们需要编写的函数内到处都是外部调用。这类函数基本不做什么计算工作，

但它们对外部函数的调用顺序则非常关键。例如我们要编写一个计算贷款利息的函数，直观的方法可能看上去像这样；
![[Pasted image 20240523143959.png]]遇到这类情况该怎么办呢?对于许多过程式语言而言，最佳选择其实就是干脆别写测试，尽 量直接把函数写对。也许我们可以在更高的层面测试该函数是否正确。但在C里面我们还有一个 选择。C支持函数指针，我们可以利用该语言特性来设立另一个接缝，如下所示：

先创建一个包含一系列函数指针的结构体：
![[Pasted image 20240523144030.png]]然后我们将它里面的函数指针初始化为指向相应的数据库访问函数。于是，以后如果要编写 需要访问数据库的函数，只需把这个结构体传给它即可。在产品代码中，我们的结构体里面的函 数指针可以指向真正的数据库访问函数，而在测试的时候则可以将它们指向伪函数。

注意，对于比较老的编译器，我们可能需要采用旧的函数指针语法：
![[Pasted image 20240523144056.png]]

**19.4**  **利用面向对象的优势**

对于面向对象语言，我们可以利用对象接缝(object   seam,35页)。对象接缝有一些很好的特质：

+ 容易从代码中把它们认出来。

+ 可以用于将代码分解为更小、更易理解的块。

+ 提供了更好的灵活性。为了测试而引入的接缝在你需要扩展系统时或许还能起到帮助。

  

然而遗憾的是，并非所有的系统都可以容易地迁移到面向对象，但有些系统迁移起来的确要 比其他系统容易得多。许多过程式语言已经进化成了面向对象语言。如微软的VB 变成完全面向 对象语言只是最近的事，COBOL 和Fortran也有面向对象扩展，此外大多数C编译器也能够编译 C++  代码。

如果你的语言允许你把代码向面向对象迁移的话，你手头就有了更多的选择。第一步通常是 使用封装全局引用 (Encapsulate Global   Reference,268页)来将你打算修改的代码块置于测试之 下。还记得本章一开始的scan_packets     所处的糟糕的依赖情况吗?利用该技术，我们便可以从 中解脱出来。回想一下，当时问题的源头是ksr_notify     函数：我们希望在测试期间，该函数不会发送任何的通知消息。
![[Pasted image 20240523144243.png]]首先，我们要将代码在C++模式下编译。这个改动可大可小，具体取决于我们怎么做。我们 可以主动出击，试着将整个项目在C++ 下重新编译；或者也可以一块一块的来，只是这样做要花点时间。

一旦代码在C++下编译成功，我们便可以搜索ksr_notify 函数的声明并将它包装到一个类 当中：
![[Pasted image 20240523144322.png]]
注意，我们并没有修改函数的名字或签名。我们使用了签名保持 (249页)技术来将出错 的几率降到最低。

接下来声明一个全局的ResultNotifier      对象，并将其放入一个源文件中：

```
ResultNotifier      globalResultNotifier;
```

现在我们便可以重新编译代码，让编译错误告诉我们哪儿需要改动。由于已经把 ksr_nofity 的声明放入了一个类当中，所以编译器在全局作用域内就找不到它的声明了。

以下是原来的函数：
![[Pasted image 20240523144400.png]]要想让上面的代码再次通过编译，可以使用一个外部声明来让globalResultNotifier 对象对编译器可见，并给ksr_notify调用加上globalResultNotifier 前缀：
![[Pasted image 20240523144432.png]]这样修改了之后，代码的行为还像原来那样。ResultNotifier 上的ksr_notify 方法会将 任务转发给(全局的)::ksr_notify 来完成。那么,以上这番工作究竟能给我们带来什么好处 呢?嗯……目前还没有。下一步工作就是试图让我们能够在产品代码中使用这个Result- Notifier 对象，而同时能在测试代码中使用另一个对象。实现这个目的有多种方法，但从长远考虑的话，最好还是再一次运用封装全局引用(268页)来把scan_packets 也包进一个类之中，我们姑且把这个类叫做scanner 吧，如下所示：
![[Pasted image 20240523144512.png]]这番修改之后，我们便可以找到那些调用scan_packets 的地方，创建一个Scanner 实例， 然后调用它上面的scan_packets 方法。

以上这些修改都相当安全，也相当机械化。虽然它们并不是面向对象设计的良好案例，但作为解依赖技术它们已经表现得足够好了，使我们在后续的工作中得以进行测试。

**19.5** **一切都是面向对象**

有些过程式程序员喜欢抨击面向对象，他们认为面向对象是没必要的，或者认为它所带来的 复杂性并没换来什么实质性的好处。但如果你认真想一想的话，就会意识到，所有的过程式程序其实都是面向对象的，只不过可惜的是它们中很多都只包含一个对象。为什么这么说呢?我们考 虑一个包含了大约100个函数的程序，以下是这些函数的声明：
![[Pasted image 20240523144630.png]]那么,这些改变系统的行为了吗?没有。这些只不过是一些机械的改动，程序的意义和行为

根本没有受到任何影响。所以说，“老式”的C程序其实就是一个大对象。而我们在使用封装全局引用手法时，则是在创建新对象，将系统分成一个个的子部件，从而使其更容易对付。

如果一门过程式语言支持面向对象扩展，那么我们就可以像上面这样对系统进行迁移。这项技术并不是什么高深的面向对象技术，我们只不过是利用一点点面向对象的知识来将程序分解从 而使其易于测试罢了。

如果我们的语言支持面向对象，那么除了提取依赖性之外，还能用它来做些什么呢?其一就 是我们可以逐步将系统朝向更好的面向对象设计改进。 一般而言这就意味着你得将相关的函数群 组到一个个的类当中，提取出许许多多的函数以便将复杂的职责分解开来。更多这方面的建议可 以参考第20章。

对于过程式代码，我们手头的选择要比面向对象代码少，但还是可以在过程式遗留代码中取得进展的。不可否认的是过程式代码所特有的接缝形式严重地加大了我们工作的难度。因此如果 你的过程式语言支持面向对象扩展的话，我建议你对系统进行迁移。对象接缝(35页)除了将测试安置到位之外还有其他很多好处。连接期接缝和预处理期接缝虽说也是很好的选择，但除了能 将代码置于测试之下之外，它们在改善设计方面并无多大贡献。