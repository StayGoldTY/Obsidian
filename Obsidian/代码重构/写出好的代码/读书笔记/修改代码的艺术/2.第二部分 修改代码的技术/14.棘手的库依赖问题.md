给开发带来实际帮助的技术之一就是代码复用。如果购买到一个能够替我们解决某些问题的 库(并了解如何使用它),项目的耗时往往会大大缩短。这种做法唯一的问题就是，很容易就会 变得对某个库过分依赖。如果在代码中不分青红皂白到处乱用一气的话，结果差不多铁定就是陷 进泥潭了。 一些我接触过的团队的确曾被库依赖问题弄得焦头烂额。比如有这么一种情况，库供 应商把版权税提得太高，以致于使用它的软件都无法盈利了。而另一方面，软件的团队又无法使用 其他供应商的库，因为要把代码中的所有那些对当前库的调用都分离出来还不如整个儿重写。

![](file:///C:\Users\TY\AppData\Local\Temp\ksohtml32088\wps81.png)

在我写这本书的时候，开发者们的阵营呈Java/.NET两极分化之势。微软和Sun都试图把它们  的平台尽量做大做宽，他们创建了数不清的库来吸引人们继续留在他们的平台上。从某种程度上  来说对于许多项目这都不是件坏事，但你仍旧可能会过分依赖于特定的库。每一处以硬编码方式  来直接使用类库的地方其实都可以以接缝的形式来实现。有些库在给其中的具体类定义接口方面  做得较好，而有些库则不仅做不到这点，还把具体类做成final或sealed的，又或者是具有一些非  虚的关键函数，让你没法在测试中“伪造”它们。遇到这类情况，你也只能给这种类写一个对应  的外覆类了。而且别忘了发邮件给你的库供应商，抱怨他们的库给你们的开发带来了多大的麻烦。

借助于语言特性来施加设计约束的库设计者们往往是犯了一个错误。他们忘记了根本的一 条，那就是好的代码除了要能在产品环境中运行之外，还要能在测试环境中运行。然而针对产 品环境而施加在代码上的约束则常常会导致代码在测试环境中寸步难行。

实际上，在意图实现良好设计的语言特性与代码的易测试性之间有一条鸿沟。其中最普遍的一 个问题就是所谓的“一次性困境”:如果一个库假定某个类在系统中只会出现一个实例，则后面就 难对这个类使用伪对象手法了。像引入静态设置方法(292页)或其他许多原本可用来对付单件的解 依赖技术或许也派不上用场了。于是把那个单件用一个外覆类包装起来可能就成了你唯一的选择。

另一个有关的问题就是“重写限制困境”。在有些面向对象语言当中，所有的类方法都是虚  方法。还有一些语言则让类方法在默认情况下是虚的，但同时也提供途径让你可以把一个方法设  置为非虚的。其余那些语言，则是要求你必须显式指定某方法是虚的(否则它们就会默认为非虚)。


从设计的角度来说，有时将一个方法做成非虚方法是有意义的。比如我们就不时会听到来自业界 的一些声音，建议最好尽可能把方法设成非虚的。有时候他们给出的理由也的确不错，但我们同 样也得承认，这么做使得往代码中引入感知和分离变得困难了，另外不可否认的是，使用Smalltalk 的程序员也写出了很多很好的代码，而我们知道Smalltalk中是没有非虚方法的。同样，Java虽然  提供了阻止重写的语言手段，但Java程序员通常不用它，可Java程序员也写出了很多很好的代码。 就连在C++里面也是，大量代码并没有遵循这个原则，但也都很好。事实上，你完全可以在产品 代码中把那些公有方法都“当成”是非虚的',这么一来，你就可以有选择地在测试中重写它们， 实现测试和产品两不误。

有时候使用编码惯例并不比使用某种限制性的语言特性差。你得为自己的测试考虑考虑。