实施一次修改要花多少时间?答案不一定，不同的情况下差异可能相当大。对于那些代码极度不清晰的项目，大部分修改可能都需要花上很长时间。首先我们得阅读并认识代码，明白修改会带来的所有影响，然后才能动手去修改。对于比较清晰的部分，修改起来可能很快，而对于那些“盘根错节”的部分，则可能要花上很长时间。此外，团队与团队之间的情况也有所不同，有些团队情况很糟糕，即便是最简单的修改也要花上大量时间。他们知道需要添加的是哪些特性，能够想像出应当在哪儿进行修改并在5分钟内完成，然而几小时后仍无法发布他们的修改。

让我们来看一看其背后的原因以及一些可能的解决方案。

### 7.1理解代码

随着代码量的增加，项目就会变得越来越难理解。于是人们也就需要花费越来越多的时间才能弄清应当修改什么。

某种程度上这是不可避免的。当往一个系统中添加代码时，可以将代码添加到现有的类/方法/函数中，也可以创建新的类/方法/函数。不管采取哪种做法，只要我们尚不熟悉相关的上下文，就没法很快知道如何进行修改。

然而，一个维护良好的系统和一个遗留系统之间有一个显著的区别：
对于前者，你可能要花上一点时间来想想该如何修改，一旦想清楚了，改起来往往很容易，改完后的系统也感觉舒服多了。
而在一个遗留系统中，可能得花上很长一段时间来搞清楚应该怎么做，同时修改起来往往也不容易。此外你可能还会觉得，除了因为修改而必须去理解的那一小块代码之外，并没有了解到多少其他东西。最糟的情况是，需要预先理解的代码好像不管花上多少时间都理解不完似的，最后你不得不闭着眼睛冲进代码，心里默默祈祷自己能够搞定所有将要遇到的问题。

那些由小块的、命名良好的、可理解的部件组成的系统对付起来更为容易。如果在你的项目中，“代码理解”是一个大问题的话，请阅读第16章和第17章寻找应对之策。

### 7.2时滞（延迟）

还有一个非常普遍的因素会导致修改耗时的延长，这个因素就是时滞(lag time),是指从做出修改到得到反馈所经历的时间。打个比方，在我写下这些时，火星漫步者Spint正在火星表面缓慢爬行，拍摄照片。信号从地球传到火星大约要花上7分钟。幸运的是，Spirit车载的导航软件能够帮助它自行在地面上移动。不过你可以设想一下，若是在地球上手动驾驶这个远在火星的探测器会是什么样的情形。每一个操作都要等上14分钟才能看到结果。然后根据结果再决定下一步干什么,完了之后再等14分钟……效率如此之低简直荒唐。然而，如果仔细想想，你会发现这正是大多数人目前在软件开发中使用的方式。我们通常作一些改动，编译并构建，看看会发生什么。然而遗憾的是，并没有一个软件知道如何躲避构建过程中的暗礁，所谓暗礁就是指像测试失败这类东西。取而代之的是，我们试图一次性进行一系列的修改，以免构建活动太过频繁。如果修改没问题，则一切平安无事，我们继续，行动速度就如Spirit一样慢。而如果触礁了的话，则会慢上加慢。

这种工作方式的悲哀之处就在于，在大多数语言中完全没必要这样做，这完全是浪费时间。实际上，在大多数主流语言中，都可以通过解依赖在10秒钟内实现对代码的重编译并运行测试。在大多数情况下，如果一个团队真的鼓起劲来干的话，这个时间甚至可以缩短到5秒以内。最终的情况就像这样：对于系统中的每个类或模块，你应当能够独立地在它们各自的测试用具中编译它们。只要做到了这一点，就能得到快速反馈，从而提升开发效率。

人类大脑有一些有趣的地方。比如说，假设我们要执行一个短任务(5~10秒),然而每分钟却只能执行该任务的一个步骤。那么我们会怎么做呢?通常我们会完成一步，然后停下来等着。如果这期间需要做一些工作来决定下一步该干什么的话，我们就开始计划。计划完之后，大脑便无事可做，等着下一步开始时刻的到来。然而，如果将步与步之间的间隔从一分钟缩短到几秒钟，情况就不同了。我们可以利用反馈来快速尝试不同的方案。于是我们的工作更像是在驾驶汽车，而不是在车站等公交车了。此外，我们也更能集中注意力，因为不再老是等着走下一步了。然而最重要的还是，花在发现并改正错误上的时间大大缩短了。

那么,究竟是什么使我们一直以来都无法以这种快捷的方式工作呢?事实上，有些人是可以的。那些用解释型语言编程的程序员在工作当中通常可以获得几乎实时的反馈。而对于我们这些使用编译型语言的程序员，阻碍我们获得快速反馈的主要拦路石则是依赖，具体地说就是为了编译我们想要编译的代码而不得不连带编译那些我们并不关心的代码。

### 7.3解依赖

依赖可能会带来一些问题，不过所幸我们可以解开它们。对于面向对象的代码，通常第一步就是试图在测试用具中实例化我们所需的类。在最简单的情况下，我们只需导入或者包含我们所依赖的那些类即可。如果情况麻烦一些，可以试试第9章所描述的技术。此外，就算能够将某个类放入测试用具中，但为了测试该类的个别方法，或许还得去解开其他某些依赖。对于这些情况，请参考第10章。

如果需要在测试用具中修改某个类，通常可以利用耗时较短的“编辑一编译一连接一测试”过程。一般来说，大多数方法的执行开销跟它们所调用的方法的开销相比都是相对较低的，尤其是当被调用方是像数据库、硬件或通信设施之类的外部资源的情况下。而其他方法大都是计算密集型的。对此第22章描述的技术会有所帮助。

许多时候我们所作的修改都是比较直观的，但面对遗留代码，人们往往在第一步就被卡死了：就是指将一个类放入测试用具中。对于某些系统来说这可能需要花很多工夫。比如，可能有些类非常大，而有些类当中的依赖是如此之多，以至于贯穿了你想要修改的功能。这种情况下建议你考虑从中切出一大块代码放入测试。第12章中包含的一组技术可以用于寻找到汇点(149页),在这些地方编写测试比较容易。

本章余下的部分将介绍如何着手修改代码的组织方式，以使其编译构建更为容易。

构建依赖

在一个面向对象系统中，如果想要让一簇类的构建更快，所要弄清的第一件事就是哪些依赖会成为拦路石。通常这很简单：你只需试着在测试用具中使用该类，所遇到的几乎所有问题都会源于某个依赖。在成功在测试用具中运行该类之后，别忘了还有一些依赖也可能会影响编译时间。一个有益的做法就是看看有哪些代码是依赖于你已经能够在测试用具中实例化的那些类的。这些代码在你重新构建系统时也需要被重新编译。那么如何将它们减到最少呢?

解决这一问题的途径，是看看这簇类里面有哪些类是被簇外面的其他类使用到的，对这些类进行接口提取。许多IDE都提供了接口提取的功能，你只需选定一个类，然后选择某个菜单来列出该类的所有方法，然后就可以从中选择某些方法来构成一个新的接口。完了之后IDE会让你为新的接口起一个名字，同样，它还会让你选择是否将代码基中所有对该类的引用尽可能替换为对该接口的引用。这是个极其有用的特性。不过在C++中，实现提取(281页)要比接口提取(285页)容易一些，因为对于前者你无需到处修改引用的名字，不过还是得修改那些创建旧类的对象的地方，将它们改为创建新类的对象(具体细节请参考关于实现提取的描述)。

一旦将这簇类置于测试之下，我们便可以修改项目的物理结构从而使其构建更快了。具体做法是将这簇类移到一个新的包或者库中去。之后我们的构建过程的确变得更复杂了，但这并不要紧，关键在于随着我们解依赖并将这些类选出来放入新的包或库中，虽然重新构建整个系统的代价增加了，但每次构建的平均时间却会降低。

让我们来看一个例子。图7-1展示了一组互相合作的类，它们位于同一个包中
![[Pasted image 20240522144916.png]]我们想要对AddopportunityFormHandler作一些改动，但若是顺便能让我们的构建过程更快的话就更好了。第一步是尝试实例化AddopportunityFormHandler。然而遗憾的是，它所依赖的类皆是具体类。AddopportunityFormHandler需要一个ConsultantSchedulerD8以及一个AddopportunityXMLCenerator。而很可能这两个类又依赖于其他不在这幅图中的类。

在目前的情况下，如果我们试图实例化AddopportunityFormHandler,天知道最终会波及到哪些类。要想解决这个问题，可以开始进行解依赖。我们遇到的第一处依赖就是ConsultantSchedulerDB。需要创建一个ConsultantSchedulerDE对象并将它传递给Add-OpportunityFormHandler的构造函数，而由于ConsultantSchedulerDE需要连接到数据库，所以创建起来会不大方便，我们可不想在测试时惹上这个麻烦。然而，我们可以运用实现提取技术，像图7-2所示那样进行解依赖。
![[Pasted image 20240522144952.png]]图7-2对ConsultantSchedulerD8进行实现提取

在ConsultantSchedulerDB变成了一个接口之后，我们便可以用一个实现了ConsultantSchedulerDB接口的伪对象作为AddopportunityFormHandler的构造函数的参数来创建AddopportunityFormHandler对象了。有趣的是，这个依赖被解开之后，构建过程在某些情况下也变得更快了。比如说，下次我们对ConsultantSchedulerDBImpl作修改时，AddopportunityFormHandler就无需重编译了。为什么呢?因为AddopportunityFormHandler已不再直接依赖于ConsultantSchedulerDBImpl中的代码了。无论对Consultant-SchedulerDBImpl所在文件作多少修改，只要这些修改不至于迫使我们去改动Consultant-SchedulerDB接口，就无需重编译AddopportunityFormHandler类。

如果我们愿意的话，甚至还可以进一步避免连带性重编译，如图7-3所示。其中显示了另一个设计，这是通过对OpportunityItem类使用实现提取技术达到的。
![[Pasted image 20240522145030.png]]图7-3对opportunityItem进行实现提取

现在，AddopportunityFormHandler不再依赖于原先opportunityItem中的代码了。从某种意义上来说，我们在代码中插入了一面编译期的防火墙。这么一来无论对Consultant-SchedulerDBImpl和OpportunityItemImpl作多少改动都不会导致Addopportunity-FormHandler被重编译，也不会迫使任何使用了AddopportunityFormHandler的代码进行重编译。如果我们想让应用程序的包结构也明确反映这些，可以将设计分解成下面这几个分离的包，如图7-4所示：
![[Pasted image 20240522145101.png]]
这么一来，我们的OpportunityProcessing包实质上便不依赖于数据库实现了。那么任何我们编写并放在该包中的测试都应该能够快速完成编译，而且当我们修改数据库实现类的代码时，OpportunityProcessing包本身则不必重新编译。
***

**依赖倒置原则

**如果你的代码依赖于一个接口，那么这个依赖一般来说是很次要的。除非这个接口发生改变，否则你的代码是无需改变的，而接口的改动频率通常情况下要远远低于接口背后的那些代码。在接口不变的前提下，不管是修改实现了该接口的类，还是添加实现了该接口的新类，接口的客户代码都不会受到影响。

**因为这个原因，较好的做法是让代码依赖于接口或抽象类，而不是依赖于具体类。当代码依赖的是较为稳定的东西时，因特定改动而导致大规模重编译的可能性也就被降到了最低

***

到目前为止我们已经做了一些工作来防止当AddopportunityFormHandler依赖的类改变时引起AddopportunityFormHandler被重编译。这的确会令编译变得更快，但这还只是问题的一半。剩下的一半是我们还可以令那些依赖于AddopportunityFornHandler的代码的编译更快。让我们再来看一下包的设计，如图7-5所示：
![[Pasted image 20240522145157.png]]
AddopportunityFormHandler是OpportunityProcessing包中唯一公共的产品(非测试)类。当我们对其进行修改时，其他包中任何依赖于它的类都得重编译。我们同样可以通过接口提取或实现提取技术来解开其他代码对它的依赖。之后其他包中的代码便可以依赖于提取出的接口。如此一来大部分时候我们对该包的修改都不再会引起其客户代码的重编译了。

我们可以通过解依赖并将类分配给不同的包来加快编译过程，这么做是非常值得的。当你可以快速编泽并运行测试时，在开发过程中便能够获得更佳的反馈。大多数时候，这就意味着更少的错误，另外情况也没那么令人恼火了。但这也并非免费的午餐，增加接口和包的数量也会增加一些概念的复杂性。值得这么做吗?答案是肯定的。的确，有时候，包和接口的数量多了以后，找起东西来要多花点工夫，但找到之后用它们工作会非常容易。

当为了解依赖而往设计中引入了额外的接口和包之后，重新构建整个系统的时间就会稍微变长一点。因为有更多的文件要去编译。但基于需要被重编译的文件而进行的局部重建的平均时耗反而大大缩短了。

当开始优化平均构建时间时，最终将会得到一块块非常易于工作的代码。是的，使一小组类能够单独编译和测试这件工作做起来可能有点痛苦，但重点是，这是一劳永逸的。一旦完成这件工作，后面就能永远享受它带来的好处。

### 7.4小结

本章展示的技术可以用于使小簇类的构建变得更快，但这还只是一小部分，事实上，借助于接口和包来管理依赖，我们还能做其他很多事情。Robert C.Martin的书《敏捷软件开发：原则、模式与实践》'展示了更多这方面的技术，每个开发者都应当知道这些技术。


***
依赖倒置原则（Dependency Inversion Principle, DIP）是面向对象设计中的SOLID原则之一，它旨在减少模块之间的耦合，使得系统更加灵活和可维护。DIP的核心思想是：

1. 高层模块不应该依赖于低层模块，二者都应该依赖于抽象。
2. 抽象不应该依赖于具体实现，具体实现应该依赖于抽象。

### 详细解释

- **高层模块**：通常是应用程序的业务逻辑部分，依赖于低层模块提供的功能。
- **低层模块**：通常是底层的细节实现部分，如数据库访问、文件操作等。
- **抽象**：通常是接口或抽象类，用于定义高层模块和低层模块之间的契约。

通过DIP，高层模块只需要依赖于抽象，不需要关心具体的实现细节，从而使得系统更容易扩展和维护。

### 实例讲解

假设我们有一个简单的应用程序，它需要从数据库中读取数据，然后进行处理。我们首先看一下不遵循DIP的设计：

#### 不遵循DIP的设计（错误示例）

1. **定义数据访问类**

```csharp
public class Database
{
    public string GetData()
    {
        // 从数据库获取数据
        return "Data from database";
    }
}
```

2. **定义业务逻辑类**

```csharp
public class BusinessLogic
{
    private Database _database;

    public BusinessLogic()
    {
        _database = new Database();
    }

    public void ProcessData()
    {
        string data = _database.GetData();
        Console.WriteLine($"Processing: {data}");
    }
}
```

3. **使用业务逻辑类**

```csharp
class Program
{
    static void Main(string[] args)
    {
        BusinessLogic businessLogic = new BusinessLogic();
        businessLogic.ProcessData();
    }
}
```

在这个设计中，`BusinessLogic` 类直接依赖于 `Database` 类。如果将来需要更换数据源，比如从文件系统获取数据，则需要修改 `BusinessLogic` 类，这违反了DIP。

#### 遵循DIP的设计

1. **定义抽象**

```csharp
public interface IDataAccess
{
    string GetData();
}
```

2. **实现具体的数据访问类**

```csharp
public class Database : IDataAccess
{
    public string GetData()
    {
        // 从数据库获取数据
        return "Data from database";
    }
}

public class FileDataAccess : IDataAccess
{
    public string GetData()
    {
        // 从文件系统获取数据
        return "Data from file";
    }
}
```

3. **修改业务逻辑类**

```csharp
public class BusinessLogic
{
    private readonly IDataAccess _dataAccess;

    public BusinessLogic(IDataAccess dataAccess)
    {
        _dataAccess = dataAccess;
    }

    public void ProcessData()
    {
        string data = _dataAccess.GetData();
        Console.WriteLine($"Processing: {data}");
    }
}
```

4. **使用依赖注入**

```csharp
class Program
{
    static void Main(string[] args)
    {
        IDataAccess dataAccess = new Database(); // 或者 new FileDataAccess();
        BusinessLogic businessLogic = new BusinessLogic(dataAccess);
        businessLogic.ProcessData();
    }
}
```

在这个设计中，`BusinessLogic` 类依赖于 `IDataAccess` 抽象，而不依赖于具体的 `Database` 或 `FileDataAccess` 实现。这样，如果将来需要更换数据源，只需要提供一个新的实现类，而不需要修改 `BusinessLogic` 类。这种设计使得代码更加灵活和易于维护。

### 依赖倒置原则的优点

1. **降低耦合**：高层模块和低层模块通过抽象进行交互，降低了模块之间的耦合。
2. **提高灵活性**：可以轻松更换具体实现而不影响高层模块。
3. **提高可测试性**：通过依赖注入，可以轻松地用模拟对象（Mock）替换具体实现，进行单元测试。

通过遵循依赖倒置原则，我们可以创建一个更加灵活、可扩展和易于维护的系统架构。

总结就算应该依赖接口，这样有变动的时候不必去修改之前的代码，而是直接新建一个新的实现了对应接口的类。