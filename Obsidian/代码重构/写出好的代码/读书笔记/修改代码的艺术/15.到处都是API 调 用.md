要么买，要么借，要么就自己开发一个。这是每个软件开发者都需要面对的选择。很多时候 我们在做一个应用时会认为从其他地方买来一些库，或者利用开源库，或者甚至只使用平台 (J2EE,.NET    等)自帶库里面的代码，会节省一些时间和精力。而事实上，如果想去整合那些你 无权去更改的代码的话，有很多东西是需要加以考虑的。比如我们得知道它有多稳定，它是否能 满足我们的要求以及易用性如何，等等。最终当我们确定了要使用其他人编写的代码时，还将面 临一个问題，那就是我们的应用看起来就好像除了到处调用其他人写的库之外自己就没幹什么事 情。这样的代码我们该怎么修改?

你可能立即会想到，我们不需要什么测试。毕竟我们自己写的代码几乎没幹什么重活，所有 的重要工作都丢给库去做了，我们的代码非常简單。这么简單的代码里面能有什么错误呢?

然而事实上，很多遗留项目正是从这样一种微不足道的阶段开始的。随着项目的修改，代码 也会不断增长，然后事情就会逐渐變得不那么简单了。 一段时间之后，我们也许还能看到某些没 有调用库API的代码块，但它们就算存在，也是被包夹在重重根本不可测试的代码之间。于是每 次我们改点东西都不得不重新运行程序来确认它仍然还能运行，这也就意味着我们又回到了遗留 系统程序员所面对的主要困境：在不能确定是否会破坏什么行为的情况下修改；我们并没有编写 所有的代码，但却得维护它。

从许多方面来讲，到处都是库调用的系统比完全自己编写的系统还难对付。其首要的原因就 是，对于这种系统你很难看出如何才能让代码的结构變得好起来，因为一眼望过去，到处都是 API 调用。看不到任何可以从中引出设计的东西。API 密集的系统之所以难以对付的另一个原因

就是我们并不拥有那些API 。如果那些APT归我们管的话，就可以通过重命名接口、类以及方法 199    来让系统更清楚一些，还可以给类里面增加方法从而让它们在代码中的不同部分都可用。
下面就是一个例子。这是一段写得非常糟糕的代码，我们甚至根本就不清楚它是否能运行：
![[Pasted image 20240523113343.png]]![[Pasted image 20240523113357.png]]
![[Pasted image 20240523113408.png]]
![[Pasted image 20240523113424.png]]这段代码算是相当短的了，然而非常不清晰。几乎没有一行代码没有调用API。这段代码的 结构可以改善吗?其结构可以改善到能够令修改变得更容易吗?

是的，我可以做到。

第一步就是找出代码的计算核心：这段代码到底做了什么?

对于以上这个问题，最好给出一个简洁的答案：

**这段代码从命令行读进配置信息，并从一个文件中读进一组电子邮件地址。然后它会周期性 地检查邮件。如果收到新邮件就会把该邮件转发给刚才的那组电子邮件地址(即转发给其中的每 一个邮件地址)。

这么看来这个程序似乎主要就是在输入和输出，但实际上除此之外还有一点遗漏掉了：代码 中启动了一个线程，这个线程会进入休眠并周期性地醒来检查邮件。此外这段代码并不仅仅是把 邮件收进发出就算了，它会基于收到的邮件生成新的邮件，它得设置新邮件的所有字段；检查并修改邮件的标题，从而让它能够反映这封邮件是来自邮件列表这一事实。所以说这段代码并不是 个空壳子。

现在，如果我们想要把代码内的职责进行分离，就可能会得到这样的结果：
(1)一个模块负责收邮件，并转给我们的系统。
(2)一个模块负责发送邮件。
(3)一个模块负责基于收到的邮件来生成发给邮件列表中的每个成员的邮件。 
(4)一个模块负责周期性地醒来看有没有新邮件。

好，我们来看看上面这几个职责。
里面有哪些职责跟Java Mail API结合得比较紧呢?职责1 和2很显然跟mail  API是分不开的了。职责3有点微妙：我们所需的邮件消息类是mail  API的一部 分，但我们应该可以通过简单的邮件消息来单独测试该职责。职责4跟mail一点关系也没有：只需要一个被设置好的周期性醒来的线程就可以了。

 图15-1展示了根据上面的职责分离进行的一点设计。
 ![[Pasted image 20240523113541.png]]
 其中ListDriver 负责驱动系统。它有一个会周期性醒来检查新邮件的线程，它把实际接收 邮件的任务交给MailReceiver来完成。MailReceiver收到邮件后会把邮件一封封的交给 MessagePorwarder。   而MessageForwarder  则会为邮件列表中的每一个成员创建邮件消息并 逐一交给MailSender 发送。
这个设计已经相当不错了。MessageProcessor  和MailService 接口很方便，因为可以借助 于它们来单独测试我们的类。尤其漂亮的就是我们可以在测试用具里面使用MessageForwarder同时又不用实际发出任何邮件。这可以通过一个实现了MailService 接口的FakeMailSender类来轻易完成。

几乎每个系统当中都有一些核心逻辑是可以与AP1调用分离开来的。尽管本章给出的这个程 序规模不大，但它的糟糕程度其实要比大多数程序更甚。MessageForwarder      就是一个与接收和 发送邮件机制几乎完全没关系的部件，但它还是使用了Java Mail API中的邮件消息类。这儿似乎 并没有太多的空间留给旧式的Java类。无论如何，把系统分解成上图所示的四个类和两个接口的 确给了我们一些层次分离。邮件列表的主要逻辑位于MessageForwarder  类当中，而且我们可以 把这个类置于测试之下。而原先它却是被埋在一堆乱糟糟的API调用间够都够不着的。所以说， 不弄出一些抽象层次来，系统是基本无法被分解成小块的。

如果我们面对的是一个看上去除了API调用什么也没有的系统， 一个好的做法就是将它看成 一个大大的对象，然后采用第20章所讲的启发式方法来对它进行职责分离。或许我们没法一步就 得到更好的设计，但光是找出系统内的职责就已经能够帮助我们在后面的过程中做出更好的决 策了。

刚才我们看到了一个更好的设计，但别忘了回到现实；后面该怎么办?从根本上来说有两个 办法：
(1)剥离并外覆API(Skin  and  Wrap  the  API);
(2)基于职责的提取。

所谓的剥离并外覆API, 其实就是先编写能够尽量准确对应API 的接口，然后再为库类创建 外覆类。为了把犯错的可能性降到最低，建议你在这个过程中运用签名保持(249页)手法。剥 离并外覆API的另一个好处就是我们最终可能会完全不依赖于底层的API代码。在产品类当中， 我们的外覆类会负责把调用转发至实际的API,   而在测试中，则可以使用伪对象手法。

那么,对于前面讲的那个邮件列表的例子，可以利用这个技术吗?
我们先来回顾一下那个邮件列表服务器的代码中负责实际发送邮件的部分：
![[Pasted image 20240523113718.png]]如果想要解开代码对Transport 类的依赖，可以给Transport 编写一个外覆类，但在这段代码中，我们并没有创建transport 对象，而是从Session 类那儿获取它。那么我们可以为 Session 类创建一个外覆类吗?不能，因为Session 是一个final 的类，在Java中 ，final 类是 没法被子类化(继承)的(抓狂……抓狂……)。
虽说这个邮件列表系统的代码实在是不好“剥”,因为API相对比较复杂。但如果我们手头 没有任何重构工具的话，这可能已经算是最安全的做法了。

不过幸运的是Java有重构工具，因此我们可以采用所谓的基于职责的提取。

<span style="color: #3CB371;">这种提取手法就是说我们先找出代码中蕴含的职责，然后针对这些职责来提取方法。</span>


上面给出的那一小段代码有哪些职责呢?总体上来说它的职责就是发送邮件消息，它需要建 立一个SMTP会话以及一个已连接的传输对象。于是，在下面的代码中我们将发送邮件消息这一 职责提取到它自己的方法中，并将该方法放入一个新类MailSender 当中：
![[Pasted image 20240523113859.png]]问题是我们如何在剥离并外覆API与基于职责的提取这两种手法之间进行抉择呢?下面就是 你在选择之前需要进行的权衡：

剥离并外覆API在以下场合表现良好：

+ API规模相对较小。

+ 你想要完全分离出对第三方库的依赖。

+ 没有现有测试，而且你也没法去编写，因为你没法通过API来进行测试。

使用剥离并外覆API,  我们便有机会将所有的代码一举置于测试之下(除了负责把调用转发 给实际的API的那层薄薄的外覆/分离层)。

基干职责的提取则在以下场合比较适合：

+ API较为复杂。

+ 你手头有支持安全的方法提取的重构工具，或者你觉得不用工具也能安全地完成提取。

在这些技术之间权衡优缺点是件很微妙的事情。剥离并外覆API工作量较大，但如果我们想

  
要把代码跟第三方库完全隔离开来的话这是个非常有用的手段，而且说实话我们常常会遇到这样 的需求，详见第14章。另一方面，使用基于职责的提取时，我们可能会将自己的代码连同使用 APl的代码一齐提取出来以便得到一个更高层抽象的名字。之后我们的代码或许便能够依赖于高 层接口而不是低层API调用了，但这同时也就意味着我们可能无法把提取的代码置于测试之下了。

事实上，许多团队两种技术都用：他们为测试编写一层薄薄的外覆，同时也编写高层的外覆 (从而给他们的应用提供一个更好的接口)。