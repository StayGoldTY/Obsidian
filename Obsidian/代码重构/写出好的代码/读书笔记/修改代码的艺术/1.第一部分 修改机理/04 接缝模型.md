几乎每个尝试过为既有代码编写测试的人都会发现既有代码对测试是多么的不友好。这并非 一种局限于特定程序或语言的现象，而是普遍存在的。 

一般而言编程语言对测试的支持不太好。 要想最终得到易于测试的程序似乎只有两条路： 一条路是边开发边编写测试，另一条路则是在先 期花点时间试着将易测试性纳入整体的设计考量。人们对第一种方案的期望甚高，若是以业界的大量代码为证的话，第二种方法在过去并没有取得多大的成功。

在一次次试图将代码纳入测试中去的过程中，我发觉自己逐渐开始用一种相当独特的方式来 思考代码。我完全可以把这归为个人的怪癖而不去管它，但是后来发现这样一种看待代码的方式 在我遇到新的不熟悉的编程语言时给了我帮助。因为在本书中我无法涵盖所有的编程语言，所以 我决定把这种思考代码的方式简单介绍一下，希望也能对你有所帮助。

### **4.1** 一大段文本

由于我开始接触编程比较晚，所以幸运地拥有了自己的电脑，以及运行于其上的编译器，而 我的许多朋友则早在纸带打孔的年代就开始编程了。我在学校里学习编程后，得到了实验室里的 一台终端作为工作平台，而代码的编译则是在一台DEC  VAX机器上远程进行的。当时那里还配 有一台账目记录机，每次请求编译都会在我们的账户上扣掉一点钱，而且每学期的上机时间也是 有限的。

那时候，程序对我来说就是一张清单。每过一两个小时我都要从实验室走到打印室，将程序 打印出来并仔细检查，试图找出哪些地方对了哪些地方错了。当时我知道的还不够多，不足以让我对模块产生多少关注。但我们又必须得编写模块化的代码以表明我们能够做到这一点，而实际上那时我更为关心的却是代码是否最终会给出正确的结果。当我接触到面向对象的概念之后，模块性就显得有些学院派了。在完成学校布置的作业时我并没有打算使用面向对象的概念。

再后来我投身工业界，便开始大量关注起这些概念。但是在学校里面，程序对我来说就是一张张清单：我得写一长串的函数，并一个个地理解。

这种将程序看作清单的视角似乎是正确的，至少我们看一看人们在编写程序时的行为就知道了。假设我们对编程一无所知并看到一间屋子里面全是程序员，我们可能会认为他们是一群正在检查和修改庞大且重要文档的专家。程序看起来可能像是一段长文本，牵一发而动全身，哪怕改动其中很小的一个地方都可能会导致整个文档发生改变，所以人们得小心改动以免带来错误。

看起来这些都没错，但模块性呢?我们经常说最好将程序编写成由一个个小的可复用组件构成的整体，但问题是这些组件被单独复用的情况到底有多少呢?答案是，并不算很多。复用可不是件好差事。就算一个软件的各个部分看起来是独立的，它们也会常常以一些微妙的、不易觉察 的方式互相依赖着。

**4.2**  **接缝**

当你开始试图将单个的类从系统中剥离出来以便能够将它纳入单元测试中去时，你会发现你得常常先进行一系列的解依赖工作。

有趣的是，不管系统原本的设计有多么良好，你还是要常常做上许多工作。将类从现有项目中剥离出来以便能够对其进行测试，凡做过这个工作的人对“什 么是好的设计”这个问题都会有一番与原先不同的理解，并开始以一种全新的角度去审视软件。

这时简单地将程序看作一长串文本的做法就不能再帮上什么忙了。那么,究竟该如何看待软件系 统呢?让我们先来看如下一个C++函数的例子：
![[Pasted image 20241017163751.png]]
这看上去的确跟一段文本没什么区别，对不对?现在假设，我们想要运行除了以下这行之外 的所有代码：
PostReceiveError(SOCKETCALLBACK,SSL_FAILURE);
如何才能做到这一点呢?很简单对不对?我们只需将上面这行代码从这个函数中删掉即可。

接下来让我们给问题再加点限制。我们想要避免执行这行代码，因为PostReceiveError
是一个会跟另一个子系统进行交互的全局函数，如果在测试中牵扯到那个子系统的话就太麻烦 了。这样一来问题就变为：如何才能做到在测试中既执行了这个方法又避免了调用到 PostReceiveError   呢?这里的关键在于既要在测试中避免调用到PostReceiveError   又不能 让最终的产品代码调用不到它!。

对我来说这个问题有多个解，这就引入了接缝这一概念。

我们先看一下接缝的定义，然后再看一些例子。

>**接缝**
接缝 (seam),    顾名思义，就是指程序中的一些特殊的点，在这些点上你无需作任何修       改就可以达到改动程序行为的目的。

>`这里有些我想要说明的，这里面的无需任何修改是指你正在处理的对象，具体的修改其实转嫁到和这个对象接缝的那些对象上面去了，修改了接缝对象以达到改变程序行为的目的。其实就类似于DI里面注入的不同对象。

那么,回过头来考虑前面给出的示例代码，在PostReceiveError  的调用点存在接缝吗?答 案是肯定的。我们可以有多种方式来修改该处的行为。以下是最直接的一种：PostReceiveError是一个全局函数，并非CAsyncSslRec 类的一部分。

所以，如果我们往CasyncSslRec 类中添加 一个签名一样的PostReceiveError   (不同之处在于后者是成员函数),会导致什么结果?
![[Pasted image 20241017164515.png]]
以上这一更动不会改变程序行为。CAsyncSslRec::PostReceiveError              只是简单地将任务 转发给了全局的：PostReceiveError        来完成。这里虽说引入了一个小小的间接层，但最终调用 到的还是同样的函数，即全局的：PostReceiveError。

好的，现在如果我们把CAsyncSs1Rec  给子类化(subclass)   了，并覆盖PostReceiveError, 将会怎么样：
```
class    TestingAsyncSs1Rec     :public    CAsyncSslRec
{
	virtual void PostReceiveError(UINT type, UINT errorcode)
	{
	}
};
```

如果像上面这样做了，并回到测试代码中创建CAsyncSslRec对象的地方，改为创建 TestingAsyncsslRec,            就能够有效地将下面代码中的调用PostReceiveError          的行为屏蔽掉：
![[Pasted image 20241017164923.png]]现在我们在为以上代码编写测试的时候就可以避开那些肮脏的副作用了'。

上面讨论的这类接缝我把它们称之为对象接缝 (object   seam)。遇到此类接缝时，我们可以 在无需修改调用函数?的情况下改变被调用的函数'。对象接缝存在于面向对象语言中，它们只不过是许许多多不同种类的接缝中的一种。

那么,为什么要关心接缝这个概念?它有什么好处呢?
在为遗留代码编写测试时， 一个最大的挑战就是解依赖。运气好的话这些依赖可能较小、较局部化，然而碰到极端情况时，你可能得对付大量的、在代码基中分布得到处都是的依赖。而`接缝的概念则帮助我们去发现代码基中既有的可利因素。倘若能够将接缝处的行为取代掉，我们就等于有选择性地排除了某些依赖。我们还可以将被依赖方替换为其他代码，以此来感知被测试代码对被依赖方的要求或影响，并针对这些要求或影响来编写测试。往往这么做了以后我们就能够获得足够的测试以便采取更进一步的举动。`

### **4.3**  接缝类型

对于不同的编程语言，可用的接缝类型也不同。考察它们的最佳途径是观察该语言的程序代 码被转换至机器代码的过程的各个阶段，其中每个显著的阶段都蕴涵着不同种类的接缝。

#### **4.3.1**  预处理期接缝
对于大多数编程环境来说，都是由编译器读进代码然后生成目标代码或字节码。取决于编程 语言的不同，有可能后面还会添上一个或多个处理步骤。然而在编译器编译代码之前，有没有什 么更早期的步骤?

事实上，只有寥寥几门语言在编译前会有另一个处理阶段(预处理),C 与C++ 就是这其中最 常见的代表。

在C和C++中，程序代码被编译之前会先由宏预处理器进行预处理。这么多年来宏预处理饱 受着人们的诅咒和讥讽。借助于它我们可以编写出外表看起来无可厚非的代码：
![[Pasted image 20241017165226.png]]

我们也可以像下面这样用条件编译语句将代码包围起来，从而达到支持调试模式以及不同平 台的目的：
![[Pasted image 20241017165257.png]]在产品代码中过度使用预处理并不是个好主意，因为它会降低代码的清晰性。条件编译指令(如 #ifdef、#ifndef      和#if 等)几乎等于是在强迫你在同一份源代码中维护多个不同的程序。宏(使 用#define 来定义)若是使用得当固然可以被用来做一些很好的事情，但是别忘了它们的运作机 制只不过是文本替换，因此很容易就可以制造出隐藏了极度隐晦的bug的宏。

姑且先把这些考虑搁在一边，我对C和C++中具有预处理功能还是感到高兴的，因为它给程 序中带来了更多的接缝。下面就是一个具体的例子。这是一个C程序，其中的问题在于对 db_update   这个库函数的依赖。db_update    会直接跟数据库进行沟通。因此，除非能用另一个 实现来将db_update    原先的实现给替换掉，否则就无法感知该函数的行为：
![[Pasted image 20241017165339.png]]
我们可以使用预处理接缝来替换掉程序中对db_update    的调用。为此，我们可以引入一个头 文件，称作localdefs.h:
![[Pasted image 20241017165401.png]]在该头文件中我们可以提供另一个db_update   的定义，以及一些有用的变量：
![[Pasted image 20241017165417.png]]有了这个实现来替换db_update   原先的实现，我们就可以编写测试来验证db_update   被调 用的时候接收到的是否是正确的参数了。我们之所以能够这么做是全靠C 预处理指令#include 提供的一个接缝，利用这个接缝我们得以在(代码)文本被编译之前将它替换掉。

预处理期接缝是个非常强大的手段。我不认为我会真的希望像Java以及其他更现代的语言中有这个功能，然而对于C和C++ 来说则不同，因为它起到了弥补这两门语言中的一些其他测试障碍的作用，所以还是有好处的。

关于接缝，还有一个重要的地方，即每个接缝都有一个所谓的激活点 (enabling  point)。 为此我们先来回顾一下接缝的定义：
![[Pasted image 20241017165457.png]]

当遇到一个接缝时，即意味着我们可以改变其所在处的行为。

当然，我们不能仅仅为了测试  就真的去修改其所在之处的代码，源代码在产品阶段和测试阶段应当是完全一样的。

在前面的例  子中我们曾尝试改变db_update 调用点处的行为，为了利用起该处的接缝，我们得在其他某个地 方进行改动。而对于db_update 这个例子来说，其激活点就是TESTING 这个预处理符号的定义。 当定义了TESTING时， localdefs.h      文件中就会包含一些宏',而这些宏将会把源文件中对  db_update  的调用替换(展开)为localdefs.h    中的db_update    定义。
![[Pasted image 20241017165555.png]]


**4.3.2**  **连接期接缝**

在许多语言系统中，编译并非构建过程的最后一步。编译器产生的只不过是代码的中间表示， 其中包含了对其他文件中的代码的调用。然后，连接器负责将这些中间表示'连接起来。连接器 会对每个调用进行决议以便最终能得到一个可运行的完整程序。

对于C 和C++ 这类语言来说的确存在着一个单独的连接器，其作用如上所述。而在Java以及 类似的语言中则是编译器在幕后负责进行连接过程。当一个Java源文件包含了import 语句时， 编译器就会检查import  的类是否已被编译，如果没有，就先对其编译，然后再检查它的所有调

36     用是否都能够在运行期正确决议。

不过，不管你的语言的编译系统是用哪种方式来进行符号引用决议的，你一般都可以利用它 来替换一个程序的某些部分。以Java为例，下面是一个名为FitFilter       的类：
![[Pasted image 20241017170028.png]]
![[Pasted image 20241017170038.png]]![](file:///C:\Users\14042\AppData\Local\Temp\ksohtml16208\wps8.png)该文件import 了fit.Parse 和fit.Fixture。  那么,编译器和JVM 究竟是如何找到这些类 的呢?在Java中你可以使用一个名为classpath的环境变量来告诉Java系统到哪里去寻找这些类。 因此，你可以创建同名类，将它们置于另一个目录中，并令classpath指向该目录，从而诱使编译 器去发现从而连接到你写的另一个版本的fit.Parse  和fit.Fixture 来。

虽说这种技巧用在产 品代码中可能会带来混乱，但用在测试中却是个相当实用的解依赖手段。

![[Pasted image 20241017170143.png]]

许多语言中都有这种动态连接功能。对于其中大部分来说，我们都有办法来利用其连接期接 缝。但并非所有的连接都是动态连接。对于许多较为古老的语言来说，几乎所有的连接都是跟在 编译之后静态连接。

C和C++ 的许多编译构建系统都使用静态连接来产生可执行文件。通常来说利用这种连接的 接缝的最简单的途径是为你想要替换其实现的所有类和函数创建另一个单独的库文件，然后，当你进行测试时，就可以通过修改构建脚本文件'来引导你的构建系统去连接到供测试之用的库文件了，而另一方面，在产品阶段的构建中，则可以修改构建脚本使得程序连接到产品代码的库。 

这种做法可能要花点工夫，但倘若你的代码基中到处散布着对某个第三方库的调用的话，这样做 是值得的了。例如，设想这么一个CAD 应用，其代码里面嵌有很多对某个图形库的调用。下面 就是其中一种典型的代码：
![[Pasted image 20241017170304.png]]
![[Pasted image 20241017170314.png]]![](file:///C:\Users\14042\AppData\Local\Temp\ksohtml16208\wps9.png)以上代码中对一个图形库进行了许多直接调用。遗憾的是，想要验证这些代码是否做了你想 要它们做的事情，唯一的途径就是运行它们并观察计算机屏幕上画出来的图形。然而当这种做法 遇到复杂的代码时便会非常容易出错。 一个替代方案就是使用连接期接缝。具体来说，如果其中 所有的画图函数都是来自某个特定的库，那么你就可以创建该库的一个stub',  用它来替代原先的 库去连接到这个应用程序。如果你只想解开依赖的话，这个stub库里面就可以全放上相应的空函 数，如下：
![[Pasted image 20241017170406.png]]这里举图形 (graphic)  库的例子有点儿不那么典型。但为什么又说它是适合使用该技术的一 个很好的例子呢?原因之一就是它几乎是个纯粹的命令型接口。

换句话说， 一般是你去调用其库函数来命令它们做某些事情，而并不请求它们反馈什么信息。遇到后一种情况会比较难对付，因为当试图测试你的代码时，为这种函数编写的stub版本一般来说不能简单地返回默认值。

使用连接期接缝的目的之一是分离。当然你也可以实现感知，只不过后者需要多花点工夫。 例如，在刚才举的那个假想的图形库的例子中，可以引入某种额外的数据结构来记录对这些库函数的调用：
![[Pasted image 20241017170748.png]]
![[Pasted image 20241017170719.png]]
虽说可用来进行感知的方案一般都会逐渐变得复杂，但一开始最好还是选一个比较简单的方案，并尽量控制它的复杂度只在绝对需要的情况下进行必要的增长。

连接期接缝的激活点从来都是位于程序代码之外的，比如有时是在构建或部署脚本中。这就 使得连接期接缝的使用显得不那么醒目。
![[Pasted image 20241017170828.png]]

**4.3.3** **对象接缝**

对象接缝几乎可算是面向对象语言中最为有用的一种接缝了。对于这种接缝来说，值得注意 的根本一点是，面向对象程序中的一处函数调用并没有指出到底哪个方法会被实际上调用起来。 以Java为例：
cell.Recalculate();
上面的代码看上去会有一个名为Recalculate 的方法被调用。当该程序运行起来时，得存
在这么一个方法，然而实际上，这样的方法不止一个：
![[Pasted image 20241017171755.png]]那么,这里到底会调用哪个方法呢?

cell.Recalculate();

在不知道cell  实际指向哪个对象的情况下，我们无法作出判断。可能是ValueCell 类中的 Recalculate 方法，也可能是FormulaCell的，甚至还可能是某个其他并非继承自Cell 的类的 Recalculate 方法(要真是这样的话，将这个变量起名cell就太失败了!)。如果可以在不用修 改这行以及周围代码的情况下就让它调用到另一个Recalculate 方法，这行调用就是一个接缝。

在面向对象语言中，并非所有的方法调用都是接缝。下面就是一个反例：
![[Pasted image 20241017171912.png]]以上代码创建了一个ce11, 并紧接着在同一个方法中使用了它。那么,其中对Recalculate  的调用是一个对象接缝吗?不是。因为它并没有对应的激活点。我们无法控制哪个Recalculate  方法被调用，因为这取决于cel1 所指向对象的实际类型，而这在那行new   FormulaCell的地方 就已经确定了，除非去修改buildMartsheet 方法，否则我们无法改变cell的实际类型。

然而，如果代码像下面这样呢?
![[Pasted image 20241017172006.png]]现在，buildMartSheet      中对cell.Recalculate  的调用是不是一个接缝呢?是的。我们可 以在测试用例中创建一个CustomSpreadsheet,  并使用我们愿意的任何种类的Cell 对象为参来 调用这个buildMartSheet 方法。换句话说，我们无需修改cell.Recalculate 这行调用所在的方法就可以达到改变这行调用所实际于的事情的目的。

那么,既然这是一个接缝，它的激活点又在哪里呢?

答案是buildMartSheet的参数列表。通过给出不同类型的对象作为其参数，我们可以根据 测试需要任意改变buildMartSheet   里调用的Recalculate  的行为，

到目前为止我们看到的大部分对象接缝都还算是比较简单的。而下面我们就来看一个微妙的 对象接缝。在下面的代码中，在Recalculate     的调用处存在一个对象接缝吗?
![[Pasted image 20241017172138.png]]这里的Recalculate 方法是个静态方法。那么,buildMartSheet 中对Recalculate 的调 用处存在一个接缝吗?答案是肯定的。我们无需修改buildMartSheet 就可以改变该调用处的行 为。

具体做法是删掉Recalculate 方法定义前的static 关键字，并将其访问权限从私有改为受 保护的，这么一来我们就可以在测试中对Customspreadsheet 进行子类化并重写其 Recalculate了，如下：
![[Pasted image 20241017172258.png]]
![[Pasted image 20241017172306.png]]

以上做法看起来是不是显得有点过于迂回了?如果我们不喜欢某处依赖，干嘛不直接进到代码中去修改一通把它改掉呢?没错，有时候这的确可行，然而当你为那些特别脏乱的遗留代码安放测试时，往往最好的途径是尽量少去修改其代码。

如果知道你的语言所支持的接缝类型，并知道怎样去使用它们，则通常可以更安全地将测试安置妥当。

到目前为止我们所展示的接缝类型都是一些主要的。你可以在许多编程语言中见到它们的身影。现在就让我们来回顾一下本章开头给出的例子，看看里面能看到哪些接缝：
![[Pasted image 20241017172452.png]]

在对PostReceiveError 的调用处存在哪些接缝呢?如下所示：

(1)PostReceiveError 是个全局函数，因此很容易就可以使用连接期接缝。具体做法可以 是创建一个库，其中包含PostReceiveError 的一个stub版本(一般是一个空函数),并将原先的程序连接到这个库，从而消除那个调用处的行为。这一接缝的激活点应该是项目的makefile文 件，或者IDE里的某些设置(如果你用了IDE的话)。需要更改项目的构建设置，以便在测试的时 候连接到测试用库，而在构建真正系统的时候连接到产品库。

(2)可以在代码中添加一个#include   语句，并定义一个名为PostReceiveError       的宏，当 我们进行测试时就激活这个宏。也就是说这里有一个预处理期接缝。那么,其激活点又在哪呢?  答案是可以使用一个预处理宏定义来控制这个PostReceiveError      宏是否被定义。

(3)还可以定义一个名为PostReceiveError       的虚函数，就像本章的开始所做的那样。也就 是说这里还存在一个对象接缝。激活点则在对象的创建处。可以创建一个CAsyncSslRec 对象， 也可以创建CAsyncSslRec 的某个为测试而写的并重写了PostReceiveError 的子类化版本。

很令人惊讶，居然有这么多途径能达到这一目的，不用修改下面这个方法，就可以替换掉 PostReceiveError  调用处的行为。


当想要将某段代码置入测试中时，选择正确类型的接缝很重要。 一般来说，`如果你用的是面向对象语言，则对象接缝是最佳选择。预处理期接缝以及连接期接缝某些时候是有用的，但它们没有对象接缝那么清楚明显。此外依赖于这两种接缝的测试可能会难以维护。我个人倾向于将预 处理期接缝和连接期接缝这两种接缝保留到代码中到处浸透着依赖并且没有其他更好的方案可选的情况下。

**当习惯了以“接缝之眼”来看待代码时，就能更容易看出如何测试某段代码以及如何组织新
代码的结构以令其更具“测试友好性”。**
