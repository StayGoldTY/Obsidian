对系统进行改动有两种主要方式。我喜欢将它们分别称为编辑并祈祷 (edit  and  pray) 和 覆 盖并修改 (coverand  modify) 。 

遗憾的是，前一种方式几乎可算是业界的标准做法。使用这种方 式来进行改动时，先是仔细地计划你所要进行的改动，并确保自己理解了将要修改的代码，然后 再开始改动。结束之后，运行修改后的系统，看看所做的改动是否已经生效，再然后就是对系统 整体的修复，以确保改动没有破坏什么东西。这最后一个步骤是必不可少的，且非常重要。在进 行改动时，你希望并祈祷能把事情做对，在完成改动后，你要用额外的时间来验证是否真的把事 情做对了。

从表面上来看， .“编辑并祈祷”这种方式似乎意味着“小心下手”,这是一件需要专业水平 的工作。在事情的一开始就需要小心，而当改动变得非常具有侵入性的时候，你还需分外小心， 因为这时出错的可能性就更大了。

然而可惜的是安全性并不取决于你的细心程度。我想谁都不会 仅仅因为一位外科医生会非常细心地进行手术就允许他拿着切黄油的刀来切你吧。精湛的软件改动就像精湛的外科手术一样，除了细心之外还要有深厚的技术。如果没有辅以正确的工具和技术， 即便“小心下手”也起不到多大作用。



而“覆盖并修改”则是另一种方式。它背后的理念在于，在我们改动软件的时候张开一张安全网。这里所谓的“安全网”并不是指放在桌子底下，当我们从椅子上跌下去时能够托住我们的 那种，而是`像张斗篷一样“盖”在我们进行修改的代码上面，以确保糟糕的改动不会泄漏出去并 感染到软件的其他部分`。

覆盖软件即意味着用测试来覆盖它。当对一段代码有一组良好的测试时， 我们就可以放心对它进行修改，并快速检验出修改是好是坏。我们仍然会辅以同样的细心，但有了测试的反馈结果，我们就得以进行更为细致的修改。

如果对这种使用测试的方式不熟悉的话，上面这些话听起来或许就有点儿令人不解了。传统 上，测试总是在开发之后编写并执行的。 一组程序员编写代码，另一组测试员在代码写好之后对 其进行测试，看看它们是否满足特定的要求。

一些非常传统的开发团队正是以这种方式来开发软 件的。这类团队也能得到反馈，但整个反馈周期非常长，往往是在几个星期乃至几个月后，另一 个小组的人才会告诉你是否已经把事情做对了。

以这种方式进行的测试实际上可以表述为“通过测试来检验正确性”。虽说这是一个很好的 目标，但测试还可以用来做其他事情，我们可以“通过测试来检测变化”。

**用传统的术语来说，这叫做回归测试** **(regression   testing)****。我们周期性地运行测试来检验己知的良好行为，以便确诊软件是否还像它以前那样工作。

当要动手进行改动的区域由测试包围着时，这些测试的作用就好比一把“软件夹钳(vise)”。 你可以用这把“软件夹钳”来固定住目标软件的大部分行为，只改动那些你真正想要改动的地方。

单元测试是用于对付遗留代码的极其重要的组件之一。系统层面的回归测试的确很棒，然而相比之下，小巧而局部性的测试才是无价之宝，它们能够在进行改动的过程中不断给你反馈，使重构工作的安全性大大增强。



**遗留代码的困境**
>我们在修改代码时，应当有测试在周围“护”着。而为了将这些测试安置妥当，我们往往 又得先去修改代码。

在解依赖时，我们通常可以采用编写测试的手段来让较具侵入性的修改更为安全。`诀窍就在于要非常保守地进行上述最初的重构。`

当我们的改动可能会引入错误的时候，保守地进行改动就成了不二之选，然而有时候(为 了让测试覆盖代码而解依赖)结果代码却并不像前面的例子中那样光鲜漂亮，例如我们可能只是为了能够将测试安置到位而为某个方法引入了某个在产品代码中并不严格需要的形参，或者以古怪的方式将某个类分裂开了。

当这么做的时候，我们可能最终会令代码看上去稍微糟糕一 些。另一方面，如果不那么保守，则我们可以立即解决这个问题。但话虽如此，具体还要看这么做会带来多大的风险。如果错误是(它们的确通常是)个重要的考虑因素的话，保守改动常常是有好处的。

当在遗留代码中解依赖时，你常常不得不暂时将自己的审美感放在一旁。有些依赖能够干净利落地解除，而有些从设计的角度来看最终还是解决得不那么完满。这就好像做手术总要有 一个刀口—样，刀口在缝合之后可能会变成一道疤痕，你的改动也可能会在代码中留下“疤痕”, 然而“疤痕”之下的东西则已得到了治愈。

而且，如果以后能够用测试覆盖“疤痕”四周(即你当初解依赖的点)的话，你就可以将 “疤痕”也抹掉了。
>这里其实是说再最初为了保证代码可以测试，可能会导致代码比较丑陋，但是这没有关系，只要有了测试我们就可以通过测试来安全的重构代码，来保证安全的一步一步去掉代码中的坏味道。

### 修改遗留代码的圣经
1.确定修改点
2.找出测试点
3.解依赖
4.编写测试
5.修改重构

每日对付遗留代码的工作其实就是改改改，不过并不是随意地改。我们想要在做出能够带来价值的功能性改动的同时使系统中的更多部分进入测试的笼罩之下。

`在每次编完程之后，我们应当不仅能够指出那些提供了某些新特性的代码，还要能够指出其测试。`

随着时间的推移，代码受测试部分将会变得越来越大，就好像在海里不断生长的岛屿一样。在这些“岛屿”之上工作 会容易得多。渐渐地，岛屿变成更大的陆地。最终你将能够在一块全面由测试覆盖的代码大陆板块上工作。

这就是原子习惯的力量