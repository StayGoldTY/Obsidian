代码是一种奇怪的建筑材料。大多数能够用来做出东西的材料都会磨损或疲劳，如金属、木 材、塑料等，用久了便会坏掉。然而代码不同。你把一块代码丢在那儿，它怎么也不会坏，除非 有人去修改它(或者你的硬盘让宇宙射线给破坏了)。如果你使用一台机器，那么用久了总会坏 的。但一次一次地运行一段代码却完全不会破坏它。
代码的这种性质给我们开发者帶来了很大的负担。因为我门不仅是往软件(代码)里面引入错误的人，而且实际上一不小心就会这么做。那么,修改代码的难易程度又如何呢?如果是指机械地修改的话，答案是相当容易。每个人都可以打开编辑器，然后敲上一堆奇形怪状的代码。敲 首诗进去或许都能编译(见www.ioccc.org上的模糊C代码大赛作品)。话说回来，在写代码时捅 出娄子实在是太容易了。你有没有过这样的经历：在费尽周折抓住了一个bug之后，却发现只是 因为当时不小心敲错了一个键而导致的。比如在把书递给同事的时候书皮掉下来砸到了键盘。代 码真是相当脆弱的东西。

本章将会讨论一些帮助我們降低编码过程中的危险的方法。它们有些只是一些机械的方法， 有些则是心理方法，但关注它们是很重要的，尤其是当我们在遗留代码中解依赖时。

**23.1** **超感编辑**

你在编辑代码的时候都做些什么?我们的目标是什么?通常会有一个大的目标。我们想要添 加一个特性或修正一个bug。 知道目标是什么当然是件好事，但如何付诸行动呢?

这么想，我们现在坐在键盘前，每敲一次键盘会有两种可能， 一种可能是我们的动作改變了 软件(代码)的行为，另一种可能则是不改变。比如，往一段注释里面添加文字?不会改變行为。 往一段字符串里面添加文字?大多数时候会。除非该字符串位于一段不被调用到的代码中。但如 果之后我们又添加代码完成对包含该字符串的方法的调用呢，那是会改变行为的。所以严格来说， 就算只是敲敲空格键对代码做点格式化也算是某种意义上的重构。有时敲代码也是重构。不过， 修改一个表达式里面的数值不是重构，而是功能改变，分清这一点很重要。

这便是编程的有趣之处了，精确地了解我们的每一次敲击会帶来什么影响。当然，这并非意 味着我们必须是万能的，而是说任何能够帮助我们了解(真正了解)我们敲入的字符会如何影响 系统行为的方法都能够帮助我们减少bug。从这个意义上说，测试驱动开发 (74页)是一门强大的技术。只要你能将代码塞进测试用具并在一秒内运行完其测试，你就可以在任何必要的时候只 花上极短时间就了解到你的修改给系统带来了什么影响。

***
**我相信不久(就算本书出版时还没有，我相信也不会太远)便会有人开发出这样一个IDE: 它能够允许你指定一组测试在每次按键时都运行。这样一来反馈周期就几近于瞬时了，
我相信这样的IDE迟早会有人开发出来的。因为这一需求看上去是如此的不可避免。目前 已经有IDE能够在每次敲击时进行语法检查，并在发现代码中的错误时用加亮或下划线之类的 手段来提醒程序员。所以，很自然的，“编辑时测试”就是下一步了，
***

和结对编程一样，测试也能够带来所谓的“超感”编程。但“超感”编程听起来是不是挺费 神的?'没错，但任何事情过度了都是不行的。关键的一点是，这种“超感”编程并不令人沮丧， 它是一种流动状态，在这种状态下你能够隔绝外界一切影响，进入代码的世界，时刻感知它。实际上，“超感”编程是非常“提神”的。
<span style="color: #3CB371;">我个人的感觉是，如果我在编程的时候得不到任何反馈， 我就会感到非常疲劳；总是害怕自己是不是不小心犯下了什么破坏代码的错误。我需要在脑子里记录和维护所有的状态，记住修改了什么和没有修改什么,并想着待会怎么才能说服自己所作的改动的确是当初计划的那些。（所以测试太他妈的重要了）</span>


**23.2**  **单一目标的编辑**

我不清楚每个人对计算机行业的第一印象是否都一样，但就我个人来说，我第一次想要当一 个程序员时，实在是被那些超级聪明的程序员的故事所迷住了。那些家伙能够将整个系统的状态 放在脑子里，在谈笑间就能写出漂亮的代码，并立即知晓某些修改是正确的还是错误的。我承认， 并非每个人都能像他们那样在脑子里记住那么多古怪的细节。我个人也只是在一定程度上能做到。以前我曾经掌握了C++  语言里的许多晦涩的部分，而且有一阵子我脑子里还记了许多关于 UML元模型的细节。直到有一天我发觉，作为一个程序员，记得关于UML的那么多细节其实根本没用，而且简直有点可悲。

事实上，聪明也分很多种。在脑子里记住很多东西的这种聪明有时候是很有用的，但它并不 能帮助我们作出更好的决策。
<span style="color: #3CB371;">比如我自己吧，虽然现在的我对于所用语言的细节的掌握比以前要 少，但我觉得作为程序员我比以前要强了。判断力是一项关键的编程技能，如果我们非要试图表现得像那些超级聪明的程序员那样的话，结果只会给自己带来麻烦。</span>

以下场景曾经在你身上出现过吗：你在写代码，写着写着突然意识到，“嗯……或许应该把 这块代码清理一下。”于是停下来开始重构，然而，你不由开始设想这块代码实际应该是什么样 子的，然后你就停住了。无论如何你正在做的这个特性还是要完成啊，所以你就回到刚才你编辑 代码的地方。你认为需要调用一个方法，于是跳转到那个方法的所在地，却发现你需要该方法做 一些其他事情；于是你又开始修改这个方法，把刚才的修改晾在那儿，这时你旁边的编程伙伴开始冲你叫了“嘿!老兄!先把刚才的工作做完再来改这个吧。”于是你感觉自己像个拉磨的骡子 一样，而旁边的家伙偏偏还来添乱。

以上的确就是某些团队的现状。比如两个人结对编程，有了一段有趣的编程体验，但其中有 四分之三的时间花在了修正前四分之一时间内破坏的代码上了。听起来很可怕是吗?没错，但有 时候这也是挺有趣的，你和你的伙伴得以从容不迫地枪下逃生。你们遇到了代码中的魔鬼并将其 杀死。你们是胜利者。

问题是，是否值得?让我们来看一看另一种方式。

你需要修改一个方法，并且已经将你的类弄进测试用具了，于是开始修改。但你不由开始想了：“我还需要修改一下那边一个方法”。于是你停下手头的修改，跳转到那个方法去了，后者看起来一团糟，所以你开始对它进行一点格式化，以便弄清楚它到底干了些什么。这时你的结对编 程伙伴发话了：“你在于什么?”你回答道：“哦，只是看看是否需要修改方法X。”于是他说：“别， 还是同一时间做一件事吧。”他拿出一张纸写下方法X的名字，放在电脑旁边，于是你回到原来  的代码继续未完的修改。完成之后你运行了一遍测试，发现全部通过。于是你再次跳到那个方法， 毫无疑问，你得对它作一些修改。首先你开始编写另一个测试。编了一会程序之后，你运行编好 的测试，然后开始做集成。这时你和你的伙伴注意到桌子对面的另外两个程序员。其中一个正在  对着另一个喊：“嘿!老兄!先把刚才的工作做完再来改这个吧。”他们已经在那个任务上耗了好几个小时了，看起来筋疲力尽。如果时间可以倒流的话，他们会选择集成，并节省好几个小时。

<span style="color: #3CB371;">我在工作的时候时常用一句话来提醒自己：“编程是关于同一时间只做一件事的艺术。”</span>

如果  我是在和另一个人结对编程，那么我会让我的伙伴监督我，在适当的时候提醒我：“你在干嘛?” 如果我的答案包含了两件事情，那么我们就会在其中选出一件。同样，对我的伙伴我也会这么做。  坦白的说，这种编程方式快多了。编程的时候一不小心就会掉入“贪心不足蛇吞象”的局面，结果是不仅受到打击，而且落到只能通过尝试来让代码工作的境地，而不是胸有成竹。

**23.3**  **签名保持**

在编辑代码的时候有众多原因可能造成错误。比如打错字、用错数据类型、用错变量……可能性太多了。尤其是重构，重构通常意味着极具侵入性的编辑。我们将代码复制来复制去，并建 立新类和新方法；从尺度上说这可比单单添加一两行代码大多了。

一般来说对付这种情形的手段是测试。 一旦测试在手，我们便能够捕获在修改代码的过程中 引入的许多错误。然而可惜的是，对于许多系统而言，要想让它足够可测试，以便能够对其进一 步重构，就必须首先对它作一点重构。这种初始的重构(第25章列出的解依赖技术)注定要在没 有测试的情况下完成，而且它们必须得是很保守的重构。

在一开始使用这些技术的时候，我总是忍不住太贪心了。当需要提取某个方法的整个方法体时，除了复制粘贴之外我还做了其他清理工作。例如，假设我要提取一个方法的方法体，并让该 方法成为静态的 ( 暴露静态方法，273页),如下所示：
![[Pasted image 20240524113940.png]]动机是好的。我是想在解依赖的过程中顺带改善设计，但事实并不像我想象的那样美好。我在修改的过程中犯了一些愚蠢的错误，而同时又没有任何测试能够帮我捕获它们，于是这些错误常常过了很久才被发现。

在为了代码的可测试性而进行解依赖的过程中，你得格外小心。我的做法之一是尽可能地采用签名保持手法。如果完全避免了签名的改动，就能够将方法的整个签名从一处剪切复制到另一 处，并最小化引入错误的风险。

在上面的例子中，我本该这么做：
![[Pasted image 20240524114030.png]]
![[Pasted image 20240524114134.png]]

一旦熟练了之后，这个过程就变得机械化，你也就对自己的修改越来越有信心了，从而在解 依赖时能够把精力集中在那些可能导致错误的顽固问题上。例如你的新方法是否隐藏住了基类中 某个同名方法，等等。

![](file:///C:\Users\TY\AppData\Local\Temp\ksohtml85600\wps12.png)关于签名保持，还有另外一些场景。如，你可以利用该技术来声明新方法，也可以用它来建 立一组成员变量(具体细节见分解出方法对象手法)。

**23.4** **依靠编译器**

编译器的主要目的是将源代码转换成另外一种形式，不过在静态类型的语言中，编译器还能 担当更多的职责。你可以利用它的类型检查机制来找出需要修改的地方。我把这种做法叫做依靠 编译器 (Lean on the Compiler)。以下是一个例子：

假设在一个C++程序中，我们有一些全局变量：

```
double   domestic_exchange_rate;
double    foreign_exchange_rate;
 ```
与它们位于同一文件中的还有一些函数，后者使用了这些全局变量。我想将这些函数纳入测 试，于是使用了目录中列出的封装全局引用(268页)技术。

为此我编写了一个类来包住这两个变量，并声明了该类的一个对象：
![[Pasted image 20240524134619.png]]

该技术的最关键的一点就是让编译器帮助你找到需要修改的地点。注意，这并不代表你就不需要思考该修改什么;而只是说在某些情况下可以让编译器帮你做搜集信息的工作。非常重要的一点是要弄清什么是编译器能够帮你找到的，什么是它所不能的，这样才不至于陷入盲目的自信。

依靠编译器手法包含两步：

(1)修改一处声明从而引发编译错误；

(2)转到编译出错的地点，修改。

在对代码结构进行修改时，可以采用依靠编译器手法，就像我们在封装全局引用例子中做的 那样。此外你还可以用它来发起类型修改。 一个常见情形是将某个变量的类型从一个类改为一个 接口，并利用编译错误来发现哪些方法需要放在该接口上。

不过，这一手法也并非总是可行的。如果你的项目构建耗时很长，那么更实际的做法往往是自己搜索那些需要修改的地方。第7章介绍了对付这一问题的方法。不过话说回来，能依靠编译 器还是得依靠编译器，这是个有用的手法。只是要注意，盲目采用这一手法可能会引入一些微小 的错误。

比如当涉及到继承时，就得小心依靠编译器了，继承在这种场合下最容易带来问题，下面就 是一个例子。
![[Pasted image 20240524134826.png]]
怎么着?什么编译错误也没有。那这是不是就意味着getx() 根本没有被任何地方调用呢?不一定。如果同样有一个getX() 被声明在了基类中，那么将现在这个(派生)类中的getx() 注释掉只会让基类的那个暴露出来而已。成员变量也存在这个问题。

依靠编译器是一门强大的技术，但你得了解它的局限性在哪里；不了解的话就可能会遇到一 些严重的问题。

**结对编程**

很可能你已经听说过结对编程 (Pair Programming)这一概念了。如果在开发过程中运用了 极限编程 (XP)   的话，你很可能已经这么做了。很好，因为结对编程对于提高质量以及在团队 中传递知识都是很有好处的。

如果你现在还未使用结对编程，我建议你试试。尤其建议当你在使用本书中描述的解依赖技术时进行结对编程。

我们在编辑代码时很容易犯错误，并且自己还根本不知道已经破坏了代码。而多一双眼睛看着当然是有好处的。现实是，对付遗留代码就好比是动手术，而医生是从来不会一个人做手术的。

更多关于结对编程的介绍可参考Laurie   Williams和Robert   Kessler的 Pair   Programming Iluminated(Addison-Wesley       2002), 并访问www.pairprogramming.com 。

***
在软件重构（Refactoring）中，"签名保持"（Signature Preservation）是指在重构过程中保持函数或方法的签名不变。签名包括函数或方法的名称、参数列表（包括参数的类型和顺序）、返回类型以及访问修饰符（如public、private等）。通过保持签名不变，确保现有的调用代码不需要修改，从而减少重构带来的风险和影响。

### 为什么要保持签名

保持签名的主要原因有：

1. **兼容性**：确保现有代码在调用被重构的函数或方法时不需要做任何修改，从而保证系统的兼容性。
2. **安全性**：减少重构过程中引入新错误的可能性，确保现有功能的正确性。
3. **简化测试**：由于签名不变，调用方不需要修改，因此减少了测试范围和复杂性。

### 常见的签名保持重构手法

尽管保持签名不变，有许多有效的重构手法可以优化和改进代码。以下是一些常见的签名保持重构手法：

1. **提炼函数（Extract Method）**：
   - 将一段代码提炼到一个新函数中，以提高代码的可读性和复用性。
   - **示例**：
     ```csharp
     public void PrintOwing()
     {
         PrintBanner();
         // 计算欠款
         double outstanding = CalculateOutstanding();
         PrintDetails(outstanding);
     }

     private double CalculateOutstanding()
     {
         double outstanding = 0.0;
         foreach (Order order in _orders)
         {
             outstanding += order.Amount;
         }
         return outstanding;
     }
     ```

2. **内联函数（Inline Method）**：
   - 将函数体直接放回到调用处，以简化代码结构。
   - **示例**：
     ```csharp
     public double GetDiscount(double amount)
     {
         return amount * 0.1;
     }

     // 内联之后
     public void PrintOwing(double amount)
     {
         double discount = amount * 0.1;
         Console.WriteLine(discount);
     }
     ```

3. **移动函数（Move Method）**：
   - 将函数从一个类移动到另一个更合适的类中，以提高代码的内聚性。
   - **示例**：
     ```csharp
     // 在类Order中
     public class Order
     {
         public double GetAmount() { /* ... */ }
     }

     // 移动到类Customer中
     public class Customer
     {
         public double GetOrderAmount(Order order)
         {
             return order.GetAmount();
         }
     }
     ```

4. **替换算法（Replace Algorithm）**：
   - 用更好的算法替换现有算法，以提高效率或可读性。
   - **示例**：
     ```csharp
     public int Sum(int[] numbers)
     {
         int sum = 0;
         foreach (int number in numbers)
         {
             sum += number;
         }
         return sum;
     }

     // 使用更高效的算法替换
     public int Sum(int[] numbers)
     {
         return numbers.Sum();
     }
     ```

### 实践中的签名保持

保持签名的重构方法在实践中非常有用，因为它们确保了系统的稳定性和兼容性。以下是一些常见的场景：

- **优化和重构已有代码**：改进代码的可读性、性能或维护性，而不改变其外部接口。
- **分解复杂函数**：将长而复杂的函数分解为多个较小的函数，以提高代码的可维护性。
- **迁移代码到更合适的位置**：将函数或方法移动到更合适的类或模块中，以提高代码的内聚性和可复用性。

通过应用这些签名保持的重构手法，可以在不影响现有系统功能的前提下，逐步改进和优化代码，使系统更加健壮和易于维护。