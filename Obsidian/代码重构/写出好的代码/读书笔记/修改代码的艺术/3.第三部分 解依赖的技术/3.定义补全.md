有些语言允许你在一个地方声明类型然后在另一个地方定义它。这一点体现得最明显的就是 在C/C+  中。在C/C+   中我们可以在一处地方声明一个函数/方法，然后在另一处地方(通常是实 现文件中)定义它。这一能力可以用来帮助我们解依赖。
![[Pasted image 20240524142331.png]]以上是 一 个C++ 类。用户创建CLateBindingDispatchDrivers             的对象，然后调用其 BindName 方法来将名字绑定到ID。 然而，我们希望在测试该类时能够以另一种方式来进行名字 绑定(而不是采用原来的BindName 方法)。在C++中这可以通过定义补全( Definition  Completion) 技术来实现。BindName 方法是被声明在该类的头文件中的，我们怎样才能在测试的时候替换掉 它的定义呢?这样，我们在测试文件中包含其头文件，然后给目标方法提供另一个定义，如下：
![[Pasted image 20240524142419.png]]只需在测试中直接定义有关方法，我们便可以提供只用于测试的方法定义。我们可以给那些 我们在测试时并不关心的方法定义一个空的方法体，也可以定义可用于所有测试的感知方法。

在C/C++中使用定义补全技术，这就意味着我们得为使用了定义补全的测试创建单独的可执 行文件了。因为如果不这么做的话，替换的定义就会跟原有的定义在连接期产生冲突。另一个缺， 点就是目标类中的方法现在有了两组定义， 一组位于测试源文件中，另一组位于产品代码源文件  中。这可能会给代码维护带来很大负担。而且如果你的调试环境没有设置妥当的话，甚至可能会  使调试器加载了错误的调试数据。因此，并不推荐使用该技术，除非你遇上了最糟糕的依赖情况。 而且即便如此，我也建议你只把该技术用在解开初始依赖上。 一旦解除了初始依赖，你应该就能快速地将类置入测试之下，这时重复的定义便可以删除了。

**步 骤
在C++中使用定义补全技术的步骤如下：
(1)找出你想要对其成员函数实施定义替换的类。
(2)确认该类的成员函数定义是在源文件而非头文件中。
(3)将该头文件包含到待测试类的测试源文件中。
(4)确保该类的源文件并不参与构建。
(5)构建，找出没替换定义的成员函数。
 (6)往测试源文件中添加相应的成员函数定义，直到构建成功。