**25.8** **提取并重写获取方法**

提取并重写工厂方法(276页)在分离对于类型的依赖方面是个强大的手法，但它并不是万 能的。其最大的问题就是不适用于C++ 。在C++ 里面你无法在基类构造函数中调用派生类的虚函 数。但所幸还是有解决办法的，如果你只在构造函数中创建新对象，并且并不用这个新对象做其 他任何事情的话，本节的手法是适用的。

该手法的关键在于为你想要替换的成员变量引入一个获取方法，以便可以通过该获取方法来  换入伪对象。引入了获取方法之后，将该类中所有使用该对象的地方改为通过获取方法来获取。 这么一来，你就可以在派生类中通过子类化并重写该获取方法来换入测试用的对象了。

本例中， WorkflowEngine  的构造函数中创建的是一个TransactionManager。    我们修改 的最终目标是要让该类能在产品环境下使用真正的TransactionManager,   而在测试环境下使 用测试用的TransactionManager         (比如一个只作感知用途的伪TransactionManager)。
![[Pasted image 20240524145826.png]]最终的代码如下所示：
![[Pasted image 20240524145846.png]]我们所做的第一件事情就是引入一个迟求值的获取方法，该方法会在第一次被调用的时候创 建TransactionManager  对象。然后我们将该类里面所有用到该对象的地方都改为通过调用这 个获取方法来获得它。

***
一个迟求值的获取方法在调用方看来跟其他获取方法并没什么两样。但有一点关键的区 别，就是迟求值的获取方法在第一次被调用的时候才去创建被返回的对象。为此它们经常会包 含如下的逻辑(注意thing 是怎样被初始化的):

```
Thing     getThing(){

if(thing           ==null){

thing   =new   Thing();

)

return     thing;

}

```
迟求值的获取方法也用在单件模式中。
***

一旦有了这个获取方法，我们便可以对WorkflowEngine 进行子类化，并重写该获取方法， 以换入我们自己的测试用对象：
![[Pasted image 20240524150027.png]]
**使用提取并重写获取方法 (Extract and Override Getter) 手法时，你须得对对象的生命周 期格外小心，尤其是对于像C+* 这样的没有内建垃圾收集的语言。确保你释放测试用对象的方式跟产品代码释放产品用对象的方式是一致的。

在测试中，只要我们需要，就可以很容易地访问伪的TransactionManager      对象：
![[Pasted image 20240524150113.png]]
提取并重写获取方法手法的缺点之一便是问题成员变量可能在未被初始化之前就被不小心访问到。所以最好确保类里面的所有用到该成员变量的地方都是通过我们的获取方法来访问的。

其实我并不常用这一手法。如果我发现问题对象上只有唯一一个方法的话，使用提取并重写调用(275页)会容易得多。但如果同一对象上有多个问题方法的话，提取并重写获取方法就是 更好的选择了。想想看，只需提取出一个获取方法然后重写它，问题就都解决了。这样的结局当 然是最好的。

**步骤
提取并重写获取方法手法的步骤如下：
(1)找出需要为其引入获取方法的对象。
(2)将创建该对象所需的所有逻辑都提取到一个获取方法中。
(3)将所有对该对象的使用都替换为通过该获取方法来获取，并在所有构造函数中将该对象 的引用初始化为null(C++   中则是指针初始化为0)。
(4)在获取方法里面加入“首次调用时创建”功能，这样当成员引用为null时该获取方法就 会负责创建新对象。
(5)子类化该类，重写这个获取方法并在其中提供你自己的测试用对象。