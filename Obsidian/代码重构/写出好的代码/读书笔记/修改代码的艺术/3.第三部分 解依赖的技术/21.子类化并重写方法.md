**25.21**  **子类化并重写方法**

子类化并重写方法 (Subclass and Override Method)是面向对象程序中解依赖的核心技术。 实际上本章所讲的许多其他的解依赖手法都是该手法的变种。

该手法的核心理念就是你可以在测试环境下利用继承来将并不关心的行为架空或访问到你 所关心的行为。

让我们来看一看一个小型应用里面的一个方法：
![[Pasted image 20240524164243.png]]MessageForwarder 类上还有其他一些方法没有显示出来。其中某个公有的方法调用了上面给出的这个私有方法createForwardMessage 来创建一条新的消息。现在，假设我们不想在测试的时候依赖于MimeMessage 类。因为MimeMessage用到了一个叫做session     (会话)的变量， 而在测试的时候是没法构造出一个真正的session 出来的。如果我们想要将对MimeMessage 的依赖分离出来，便可以将createForwardMessage 设为受保护的，并在一个测试用子类中重写 它，如下：
![[Pasted image 20240524164445.png]]在这个新建的测试子类中，我们可以做想做的事情，得到想要的分离和感知。在这个特定的 例子中，我们可以完全架空createForwardMessage   的大部分行为，但由于在测试的时候并不 需要用到createForwardMessage 原来的那些行为，所以一切都没问题。

在产品代码中，我们实例化的是MessageForwarders;  而在测试代码中，实例化的则是 TestingMessageForwarders。   你看，我们以最少的修改换来了所需要的分离。实际上只不过 是将createForwardMessage 的访问权限从私有换成了受保护的。

通常， 一个类当中的功能分解的好坏决定了你使用该手法来分离依赖时的难易程度。好的情 况下，你想要分离出的依赖会被隔离在一个小小的方法当中。而在糟糕的情况下，你可能就需要 重写一个较大的方法才能分离出依赖了。

子类化并重写方法是个强大的手段，但用的时候也需小心。比如在前面的例子中我可以返回 一个没有主题、发件人地址等信息的空消息对象，但这么做是有特定前提的，比如我正在测试的 是能否将一个消息从系统中的一个地方传到另一个地方，而并不关心消息的具体内容和地址，这 时候这么做才是安全的。

对我来说编程活动大多数时候是可视化的。我在工作的时候脑袋里会设想各种各样的情景， 这有助于我在不同的方案之间进行取舍。可惜的是我设想的这些图景没有一个是UML 图，不过 它们还是帮了我不少忙。

比如我经常设想的一种场景就是我所谓的“叠纸视图”。我看着一个方法，然后在脑海里设 想所有可用于将其语句和表达式分组的方式。对于一个方法中我可以确定出来的几乎任何细小的 代码片段，我猜想能否将其提取到一个方法中，进而在测试中将其替换为另一个方法。这就好像 我将一层半透明的纸放在代码之上，在这层半透明的纸上我可以放置用于替换目标代码片段的代码。这叠纸就是我的测试对象，而从上往下看到的方法便是会在测试中被执行到的方法。图25-6  展示了我所设想的场景。
![[Pasted image 20240524164645.png]]叠纸视图法能够帮助我看到什么是可能的，但当我真正开始使用子类化并重写方法手法时， 仍然还是尽量去重写既有的方法。毕竟我们的目的是将测试安置到位，而在没有测试的情况下提 取方法常常是危险的。

**步** **骤
子类化并重写方法的步骤如下：
(1)找出你想要分离出来的依赖，或者想要进行感知的地点。找出尽量少的一组方法来完成 你的目标。
(2)确定了重写哪些方法之后，还得确保它们都是可重写的。这一步根据语言的不同有所不 同。 C++   中首先要将它们设为虚函数。Java中它们必须是非final方法。而在许多.NET语言中，你 还得明确地将这些方法设为可重写的。
(3)在某些语言中，你需要调整这些方法的访问权限才能在子类中重写它们。比如在Java和C#中，必须至少是受保护的方法才能被子类中的方法重写。而在C++中私有虚函数仍然是可以在 子类中重写的。
(4)创建一个子类并在其中重写这些方法。确保你的确能够在测试用例中构建该类。