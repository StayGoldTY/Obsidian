构造函数中的对象创建可能会带来依赖问题，尤其是当测试很难依赖这些对象的时候。大多 数情况下我们可以使用提取并重写工厂方法 (276页)手法来对付这个问题。但对于那些不支持 在构造函数中调用虚函数的语言，则必须另觅他法。而办法之一便是本节所要讲的替换实例变量 (Supersede Instance Variable)。

下面这个例子演示了C++中的虚函数调用问题：
![[Pasted image 20240524164824.png]]
我们发现Pager 的构造函数中调用到了formConnection    方法。本来，把工作委托给其他函 数来完成是无可非议的，但这儿的代码有点令人误解。由于formConnection 是个虚函数，所以 人们可能会想当然的以为只要对它进行子类化并重写方法(314页)就够了。但是别着急，没有 调查就没有发言权，我们来简单地验证一下：
![[Pasted image 20240524164846.png]]在C+  中重写虚函数时，基类相应的行为会被派生类中的行为替换，这一点跟我们预期的一 样，然而有一点例外，就是当你在构造函数中调用一个虚函数时，调用并不会被分发到派生类中 的相应虚函数上去。在本例中，当sendMessage   被调用时，TestingPager::formconnection

固然会被调用起来，这很好，因为我们并不想发送这条搞怪的消息给信息操作员，然而遗憾的是 结果并不如你所想。这个TestingPager     对象在被构造起来的时候，基类Pager  的构造函数被调 用，后者调用了formConnection, 而又由于在构造函数中虚函数机制是被禁止的，因此那一次 的formConnection    调用被决议到了Pager::formConnection         上!

C++ 之所以有这个规则是因为在构造函数中允许虚函数调用可能会导致危险。设想下面这种 情况：
![[Pasted image 20240524164904.png]]B::someMethod 重写了A::someMethod。  当一个B 对象被构造的时候，先是A 的构造函数 被调用起来(这时B的构造函数还没有进入),而A的构造函数调用了someMethod,   如果这时允 许虚函数转发机制，也就是说让这个someMethod 调用转发到B中去的话，“c.doSomething();”

语句就会被试图执行，然而问题是，既然还没轮到B 的构造函数，那么就是说c根本就还没被初  始化，结果可想而知。:

这便是C++在构造函数中禁止虚函数转发机制的原因。 一些其他语言在这个问题上则要放松 一些，比如Java中允许这么做，但我不建议你在产品代码中这么干。

然而， C++ 的这个保护机制却阻碍了我们替换构造函数中的行为。所幸的是还有一些替代方案。如果你想要替换的对象并没有在构造函数中被使用(而只是创建的话),就可以采用提取并 重写获取方法来解开依赖。而如果构造函数中使用了该对象并且你需要确保在另一个方法被调用 之前将该对象替换掉的话，就可以采用替换实例变量手法了。例如：
![[Pasted image 20240524164936.png]]BlendingPen   的构造函数通过一个工厂来创建Par ameter  对象。我们可以使用引入静态设 置方法(202页)手法来控制该工厂产出的对象，但这么改动的话就太具侵入性了。如果不介意 往BlendingPen   上添加一个方法的话，我们便可以替换掉构造函数中创建出来的那个 Parameter 对象，为此引入一个supersedeParameter 方法：
![[Pasted image 20240524164954.png]]在测试时，我们可以根据需要创建BlendingPen 对象，并在需要放入感知对象的时候调用 它的supersedeParameter方法。

从表面上来说， 替换实例变量看起来是个挺糟糕的放置感知变量的手法，但在C++中， 当参数化构造函数(297页)手法由于构造函数中纠缠的逻辑而变得难以使用时，替换实例变 量就成了最好的选择。不过，在允许构造函数中调用虚函数的语言中，提取并重写工厂方法 (276页)通常是更好的选择。

**一般而言，提供设置方法来允许外界修改被用到的子对象属于不良实践。这些设置方法允 许客户代码彻底改变一个对象在其生命周期当中的行为。在旁人可以调用这些设置方法时，你就必须得了解目标对象的历史状态方能知道对它的方法调用会带来什么后果。而当没有设置方法时，代码便更易于理解。

使用“supersede”作为这类方法的方法名前缀的一个好处就是这个单词比较奇异且不常见， 于是如果你担心别人会在产品代码中使用这个方法的话，只需搜索一下“supersede”  就能知道结 果了。

**步骤
替换实例变量的步骤如下：
(1)找出你想要替换的实例变量。
(2)创建一个名为supersedexxx 的方法，其中xxx 是你想要替换的变量的名字。
(3)在该方法中销毁原先被创建出来的那个对象，换入你新建出来的对象。如果持有该对象 的实例成员是一个引用，则需要确保该类中没有其他成员引用了原先创建出来的那个对象。如果有的话，你可能就需要在supersedeXxx   方法里面多做一点工作，来确保能够安全地换入你的新 对象并且确保达到正确的效果。