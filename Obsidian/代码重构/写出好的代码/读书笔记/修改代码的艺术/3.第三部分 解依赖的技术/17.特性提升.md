有时候，比如说，你要对付一个类上面的一簇方法，而阻止你在测试用具中实例化这个类的依赖却又是跟这簇方法毫无瓜葛的。这里所谓“毫无瓜葛”是指这些方法既没有直接也没有间接 引用或触碰到那些问题依赖。当然 ，这时你可以通过重复采用暴露静态方法(275页)或分解出 方法对象(261页)来“解决”问题，但那样做未必就是解决这个问题的最直接办法。

面对这种情况，你可以将这簇方法(即所说的“特性”)提取出来，提升到一个抽象基类中。 然后再对这个抽象基类进行子类化，并在测试中创建这个子类的实例。例如：
![[Pasted image 20240524162308.png]]假设我们要修改getDeadTime,    但并不关心updatescheduleItem 。    如果不用应付对数据 库的依赖的话，情况会好很多。为此我们可以尝试使用暴露静态方法，但getDeadTime  里面用 到了scheduler 上的许多实例变量。也可以试试分解出方法对象，但这又是个很小很小的方法， 似乎不值得这么做，况且它对于其他实例变量和方法的依赖会使得我们被许多根本不想看到的麻 烦缠住——毕竟我们只是想把这么个小小的方法放入测试而已。

另一个做法就是将问题方法提升到一个基类中。我们可以将问题依赖留在原来的类中，免得 它们阻挠测试。特性提升之后的scheduler    类大致像这样：
![[Pasted image 20240524162450.png]]我们已经将getDeadtime  (我们想要测试的特性)以及它所用到的所有特性都提升到了一 个抽象类schedulingServices 中了：
![[Pasted image 20240524162518.png]]于是现在便可以从SchedulingServices派生出一个测试子类来，这样我们便可以从容地 在测试用具中访问这些方法了：
![[Pasted image 20240524162543.png]]
!回顾一下，我们做了什么呢?首先将想要测试的方法提升到一个抽象基类中，然后创建该抽 象基类的一个具体派生类，后者便是我们可以用在测试中的类。那么,这么做是不是件好事呢?从设计的角度来说，这种做法还不算理想。我们令一组特性跨越了两个类，这么做的原因只不过是为了容易测试。如果这两个类的特性之间的关系并不密切的话，这种特性跨越就可能会带来混乱。
而这儿的情况正是如此：我们有一个类叫scheduler,  其职责是更新计划项目，还有一个类叫 schedulingServices,   但这个类的职责就广了，包括获取计划项目的默认时间、计算死时间等。 另一种好一点的重构方式是让scheduler 委托某个validator 对象，将访问数据库的任务放在后 者身上，但如果这一步目前看上去还太危险，或者说还有其他糟糕的依赖存在的话，那么特性提升 是个不错的开始。使用特性提升手法时，你如果实施签名保持(249页),并且依靠编译器(251页) 的话，风险就会小得多。而当测试安置到位之后，我们可以再去考虑是否转向委托的模式。

**步** **骤
特性提升 (Pull up  Feature) 手法的步骤如下：
(1)找出你想要提升到抽象基类中去的方法。
(2)为它们创建一个抽象基类。
(3)将这些方法转移到该抽象基类中，再编译。
(4)编译错误会告诉你这些方法引用到的其他实例成员，将它们也转移到基类中。记住这么 做的时候要保持签名，以尽量减少出错的机会。
(5)当两个类都成功编译之后，为那个抽象基类创建一个测试子类，并往其中添加你觉得需要用于设置测试环境的方法。

**你可能会想：“干嘛非要让那个基类成为抽象的呢?”实际上，是为了让代码更易理解。 设想你看到一块代码基，那么肯定会期望看到每个具体类都被用到了，如果有一个具体类没有被任何代码直接用到(实例化)的话，你肯定会感到困惑，因为在你看来它们无异于“死 代码”。