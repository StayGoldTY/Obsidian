**25.5**  **暴露静态方法**

对付那些没法在测试用具中实例化的类是件麻烦事。下面我就为你介绍一项我有时候会使用的技术。假设你有一个方法，该方法不使用实例变量或其他方法，就可以将它设成静态的。而一 旦它成了静态的，你便无需实例化其类就可以将它置于测试之下了。下面是一个Java的例子。

RSCWorkflow 有一个叫做validate 的方法，现在我们需要添加一个新的验证条件。然而遗 憾的是，该方法所在的类很难实例化。这里就不把整个类列出来了，免得你头疼。仅列出需要修 改的方法：
![[Pasted image 20240524144424.png]]怎么才能将这个方法置于测试之下呢?仔细一看我们就会发现，validate     方法用到了Packet   上的许多方法。实际上，把validate     整个移到Packet   类上面倒的确是个不错的主意，但就目前来 说这么做的风险还是大了点，比如首先我们就没法实施签名保持(249页)。所以如果你没有方法转 移的自动化支持的话，通常最好还是先把测试安置到位再说。暴露静态方法(Expose Static Method) 手法可以帮你做到这一点。 一旦测试到位，就可以放心做所需的改动，并大胆改进代码了。

<span style="color: #3CB371;">在没有测试的情况下解依赖时，尽可能对方法进行签名保持。对整个方法进行剪切/复制 可以降低引入错误的可能性。</span>

validate     的代码并没有依赖于任何的实例变量或方法。所以，如果把validate      设成公有静 态的会怎样呢?那样就可以在任何地方这样调用它：

```
RScworkflow.validate(packet);
```

很可能当初RSCWorkflow 的创建者根本没有想到会有这么一天，它的validate 方法被做成 静态的，更不用说公有了。但这是不是说这么做就不对了呢?非也。封装对于类来说固然是件好事，但类的静态部分其实并不属于该类。实际上，在某些语言中，它隶属于另一个类，有时候也叫做元类。

静态方法不会访问类的任何私有数据，它只是一个实用方法。如果把它设成公有的，就可以编写测试了。之后如果你想要将该方法转移到另一个类中去，这些测试就会是你的强大后盾。

**实际上，静态方法和数据表现得就好像它们是属于另一个类的一样。比如静态数据的生命 周期是整个程序，而不是随着特定的实例生灭。此外静态成员无需实例便可以访问。
一个类的静态区段可以看作是“临时场地”,用于存放不是十分隶属于该类的东西。如果 你看到某个方法没有使用任何实例数据，那么把它设成静态的是个好主意，这样可以让它变得 醒目，直到你弄清它应该属于哪个类。
![[Pasted image 20240524144645.png]]

不过在有些语言中这么做会招来编译警告。而如果没有编译警告当然是最好不过的了。

如果你担心之后又会有人来使用这个静态方法从而带来依赖问题，可以考虑使用非公有的访 问限制。比如在Java和C#中有包内可见性或内部可见性，你可以用它们来限制别人对你的静态方 法的访问，或把它做成受保护的并通过一个测试基类来访问它。在C++中也可以做类似的事情： 可以把你的静态方法设为受保护的，或引入一个名字空间。
**步** **骤
暴露静态方法手法的步骤如下：
(1)编写一个测试，访问你打算设为公有静态的那个方法。
(2)将目标方法的方法体提取到一个静态方法中。记住实施签名保持(249页)。给这个方法 起一个新的名字，看一看它的参数名，或许会有所启发。例如一个名叫validate 的方法接受一 个Packet  参数，那么就可以提取出一个叫做validatePacket        的静态方法。
(3)编译。
(4)如果收到关于访问实例变量或方法的编译错误，看一下那些被访问到的变量或方法，看 它们能否也能被设为静态的。如果可以，就将它们也一并设为静态的并通过编译。

