当你想单独对付某块代码时，可能常常会发现全局变量挡在你的路上。关于全局变量的害处 这里就不再次说了，因为我曾经在引入静态设置方法 (292页)一节作了相当完整的叙述。

要想解开一个类里面对全局变量的依赖，方法之一是在该类中为每个相应的全局变量引入一 个获取方法。有了这些获取方法，便可以通过子类化并重写方法(314页)来令它们返回测试用 对象了。不过也有些情况下你可能会需要动用接口提取(285页)。

下面是一个Java的例子：
![[Pasted image 20240524163529.png]]在上面的代码中， Inventory     类是被作为一个全局变量来访问的。“什么?”你可能会嚷起 来，“这不明明是个静态方法调用吗?”没错。但从我们的意图(测试)来说，它其实就相当于  一个全局变量。在Java中，该类本身就是一个全局对象，而且似乎它还需要引用一些状态才能完  成它的工作(基于给定的barcode(条形码)返回相应的item(商品))。那么,我们能否利用以获  取方法替换全局引用(Replace Global Reference with Getter)手法来对付这个问题呢?试试看吧。

首先编写获取方法。注意，我们将该方法设为受保护的，这样才能在测试子类中重写它：
![[Pasted image 20240524163606.png]]接着我们创建Inventory    的测试用伪类。由于Inventory    是个单件类，因此需要先降低其 构造函数的访问权限为受保护的，然后再像下面这样从它派生出一个FakeInventory,   并在里 面放置我们需要的逻辑：
![[Pasted image 20240524163645.png]]**步** **骤
以获取方法替换全局引用的步骤如下：
(1)找出你想要替换的全局引用。
(2)给它编写一个相应的获取方法。确保该获取方法的访问权限允许你在派生类中重写它。 
(3)将对全局对象的引用替换为对该获取方法的调用。
(4)创建测试子类并重写获取方法。