在对付遗留代码时最麻烦的事情莫过于遇到庞大的方法了。许多时候可以通过新生方法(52 页)和新生类(54页)手法来避免对长方法进行重构。但就算你逃掉了，也应该为不得不如此感 到羞愧。长方法就像是代码基中的沼泽。不管什么时候，只要你试图去改变它，就得退一步先努 力把情况弄清楚，然后再去进行修改。通常，如果代码比较干净的话修改起来要省时省事得多。

代码基里有长方法是件痛苦的事，但巨型方法就更恐怖了。所谓“巨型”方法就是指那些庞大复杂到你碰都不想去碰一下的方法。巨型方法可能包含成百上千行代码，其中还到处都是缩进， 搞得你几乎无法浏览。所以，碰到这样的方法，你很可能会把它打印在一张长长的纸上，把纸摊 在走廊里以便和你的同事们一起把它读懂。

有一次，我去参加一个会议，在跟朋友走回旅馆的时候，他们其中有一个说： “嗨，你一定 得来看看这个。”他跑进房间拿出笔记本，给我看一个方法，这个方法长达千行以上。朋友知道 我当时在研究重构，于是就说：“遇到这种方法你怎么办?”于是我们就开始想办法。我们知道测试是关键，但遇到这么巨型的方法，从哪里下手却成了问题。

本章所讲的就是从那以后我在这个问题上积累的经验。

**22.1**  **巨型方法的种类**

巨型方法不止一种。而且巨型方法的种类也并不都是能截然区分开来的。 一般来说，我们看 到的巨型方法都是几种不同特征的混合体(就像鸭嘴兽那样)。

**22.1.1** **项目列表式方法**

项目列表式方法就是指那种几乎毫无缩进的方法，你只能看到罗列下来的一串仿佛项目列表  似的代码块。其中也许有个别代码块中含有一定的缩进，但就整个函数范围来说是没什么缩进的。 一般来说这种方法一眼扫过去是这样的(如图22-1所示)。

图22-1是最常见的一种项目列表式方法。如果运气好，可能会碰到写方法的人在各个代码区 段之间加上几个回车或者加点注释说明一下各部分是做什么的。理想情况下，你应该可以将每个代码区段提取为一个单独的方法，但通常代码并没有这么容易重构。看起来代码段之间是被一些 空行隔开了，然而这个表象实际上是有欺骗性的，往往在一个区段声明的局部变量会在另一个区 段被用到。这就导致方法分解往往并不像你想象的那样只需把代码拷贝粘贴出来就可以了。话虽如此，项目列表式方法跟巨型方法的其他“品种”比起来还算是稍微好一点的，这主要是因为代码中没有那种疯狂的缩进，后者往往会使阅读者找不着北。
![[Pasted image 20240524092604.png]]

**22.1.2** **锯齿状方法**

锯齿状方法就是指那些具有单个庞大的缩进块的方法。最简单的例子就是下面这样的， 一个 具有一个庞大的if 块的方法(如图22-2所示)。
![[Pasted image 20240524092826.png]]
但以上这个还算好的，至少跟上面的项目列表式方法差不多。下面展示的这个(见图22-3) 才是真正令人头大的。
要想判断你手头的方法是否属于这一类，最好的办法就是试图把方法内的代码块都按照缩进 格式格式化好。如果结果代码让你感到晕头转向，那么就是了。
大多数方法其实并不能严格归为上面所讲的两类，而更多的是属于两者的混合体。许多锯齿状方法在它们的深层的缩进区块中也会含有大段的项目列表式代码，但由于这些代码被层层嵌套 在了里面，因此很难给它们编写测试。对付锯齿状方法很具有挑战性。

在对长方法进行重构时，有没有重构工具会带来很大的区别。几乎每个重构工具都支持方法 提取，因为有很多地方都可以利用这一支持。如果一个工具能够为你安全地提取方法，你就不需 要自己编写测试去验证提取是否正确。工具代替了你的手工劳动，于是你可以专心致志地考虑如 何使用方法提取来将一个方法重构成体面的样子，从而让后续工作更容易。

如果不幸没有自动提取方法的重构工具支持，则整理巨型方法可就更具挑战性了。通常这时 候你的改动就得更保守一点，因为只有测试设置妥当了，相应的改动才能进行。![[Pasted image 20240524092940.png]]

**22.2**  **利用自动重构支持来对付巨型方法**

如果你的工具能进行方法提取，那么得首先弄清楚什么是它能替你做的，什么是它不能替你 做的。如今的大多数重构工具都能做简单的方法提取以及一些其他的重构，但人们在分解大型方法的时候往往需要更多的辅助重构，这时候就不是随便某个重构工具能胜任的了。举个例子，我 们常常喜欢对语句进行重排，分组，以便将它们提取出来。对于这一需求，目前就没有任何工具 能够进行必要的分析来判断给定的重排是否安全。这是件很可惜的事情，因为它可能成为bug的 来源。

要想针对大型方法有效地运用重构工具，最好仅用工具进行一系列的修改，并避免对代码进行其他任何改动。这听起来似乎是用一根小指头就能完成的事情，但它的确带来了好处，就是能 把那些已知为安全的修改和可能不安全的修改完全分离开来。在做这一阶段的重构时，你应当避 免像语句重排和表达式分解这类修改，就算它们很简单也不行。此外，如果你的工具支持变量重 命名，那固然很好，但如果它不支持，则你应该把这一工作推迟到后面再做。

***
[在没有测试的情况下进行自动重构时， 一定要只用工具进行(其中不要参杂手工修改)。 而在一系列的自动重构完成之后，往往就可以将测试安置到位，并用这些测试来验证你所进行 的任何手动修改了。]
这段话的意思就是开始重构巨型方法的时候，也许根本不可能测试，当用了一系列工具来重构后大概率可以安装一下测试了。有了测试只会我们再用手动修改，这样可以方便严重手动修改。而在没有测试的情况下，尽量只用工具本身的重构操作
***
在做提取的时候，以下是你的主要目标：

(1)将代码中的逻辑部分从尴尬的依赖中分离出来。
(2)引入接缝，以后在重构时才能更容易地将测试安置到位。
下面是一个例子：
![[Pasted image 20240524093510.png]]以上方法中有很多地方都是可以清理一下的。其中最怪异的事情之一就是该方法所做的“过滤”工作是发生在一个面板 (Panel) 类上，按理说一个叫做面板的类应该只管显示才对。要想  解开这段代码肯定是困难的。照现在的情况，要想编写测试的话，可以针对listbox    的状态来写， 但那样的话比原来的设计也好不了很多。

然而，如果有重构支持，情况就不一样了，我们可以在提升抽象层次的同时达到解开依赖的 目的。比如，下面就是代码经过了一系列提取之后的样子：
![[Pasted image 20240524093552.png]]
坦白的说，重构之后的代码从结构上看并没多大区别；仍然只不过是一个内含一些语句的if 块。但不同的是，现在if 块内的工作被委托给其他方法来完成了。现在我们的update  方法就像 是原来的update  方法的骨架。但是，你会说，工具给自动起的那些方法名怎么办呢?它们看起 来总有点古怪。别介意，你可以把它们当成一个好的开始，至少它们让你的代码能够从一个更高的层面来传达语意了不是吗?而且它们还引入了接缝，这样的话后面我们就可以利用这些接缝来 进行解依赖了。例如，我们可以运用子类化并重写方法手法来通过displaycommodity      和 clearDisplay      进行感知。完成这些之后，我们可以考虑利用这些测试作后盾，创建一个新的显 示类并将这些方法移到该类中。不过在本例中更妥当的办法是看看能否将update   和 updateCommodities      转移到另一个类中；而将clearDisplay       和displayCommodity      留下，因 为这样该类才能算是一个面板类，显示类。至于方法的重命名，则可以等到各个类都安放到位之 后再进行。再加上一些重构，最终我们的设计看起来可能就像图22-4所示的这样。
![[Pasted image 20240524093647.png]]在使用自动工具进行方法提取时，有一点认识很重要，那就是藉此你可以完成许多粗糙的工 作，之后，等其他测试安置到位了再去做那些细节的工作。在这个过程中，别太在意那些看上去跟 当前类格格不入的方法，因为这样通常意味着之后还要进行类提取。具体怎么做可参考第20章。

**22.3**  **手动重构的挑战**

自动重构工具的支持可以让你无需做任何特殊准备就可以开始对大方法进行分解。好的重构工具能够帮你检查试图进行的重构是否安全，如果不安全的话就不予执行。但如果没有重构工具， 就得靠自己来确保重构的正确性了，这时测试便成了最强的工具。

巨型方法使得测试、重构以及特性添加变得非常困难。
**但如果你能够在测试用具中实例化该方法所在的类，那就可以试着写出一组测试用例来保证你在分解该方法的过程中的安全。**
当然， 如果该方法中的逻辑特别复杂，编写测试用例也可能会变成噩梦。但幸运的是，这种情况下我们 可以求助于一系列的技术。在学习这组技术之前，让我们先来看看在方法提取时可能会犯的一些 错误。

下面是一个简单的列表，虽然并不全面，但己经包含了最常见的错误。

(1)**我们可能会忘记向提取出来的方法传递变量。通常编译器会提醒我们这一错误(除非该 变量跟某个成员变量重名),但我们还是可能会错误地认为该变量应当是一个局部变量，于是将 其声明在了新方法的方法体中。

(2)**我们可能会给提取出来的方法起了一个会覆盖或重写基类中某个同名方法的名字。

(3)**我们可能会在传参或接受返回值的时候犯错。愚蠢的错误如返回了错误的值。更小一点 的错误如返回或接受了错误的类型。

      总之有很多地方可能会出错。本节的技术可以帮助你在没有测试的情况下更安全地进行方法 提取。
      
**22.3.1** **引入感知变量**

我们可能不希望在对产品代码进行重构的时候往里面加入特性，但这并不意味着不能往里面 添加任何代码。比如，可能会想要往一个类里面添加一个变量并使用它来感知待重构方法内的条件，而在完成了重构之后则可以将该变量删除，于是我们的代码就又回到了干净的状态。这一手 法叫做引入感知变量。下面就是一个例子。我们想要重构Java类 DOMBuilder  上的一个方法。我 们想要将这个方法清理一下，但不幸的是手头没有重构工具。
![[Pasted image 20240524094007.png]]
本例中，似乎该方法中的许多工作都是围绕一个XDOMNSnippet  对象来进行的。这意味着我 们可以通过传递不同的值给该方法来编写想要的测试。而实际上在背后发生了许多无关的事情， 这些事情只可以通过非常间接的方式来感知。比如说本例，我们可以引入感知变量来辅助我们的 工作；可以引入一个实例变量来发现当一个变量具有恰当的结点类型时即会被添加进paraList。
![[Pasted image 20240524111439.png]]有了这个感知变量，我们仍需要设计一个能够产生这一条件的输入。然后便可以将这块逻辑 提取出来，同时我们的测试仍能通过。

在下面这个测试中，我们添加一个类型为TF_G的节点。
![[Pasted image 20240524111520.png]]有了这些测试的保护，我们在提取processNode() 中决定一个节点是否被添加的条件的时我们将整个条件表达式复制出来 ， 测试表明当条件满足的时候节点被添加了 。
![[Pasted image 20240524111740.png]]
以后不需要这个感知变量时，我们便可以将它删除。

本例中我们使用的是一个布尔变量。使用该变量的目的是为了确定在提取条件表达式之后节 点是否仍被添加了。我相当确信自己能够毫不出错地将整个条件表达式提取出来，因此没有对其内 部的各个分式进行测试。以上测试简单地确保了在代码提取之后我们所关心的条件表达式仍然是代

码路径的一部分。关于在方法提取时到底要做多少测试，可以参见第13章提到的目标测试(157页)。使用感知变量时最好将变量放在被重构的类中，直到一系列的重构完成之后再将它们删除。 我常常是这么做的，因为这样做有一个好处，就是能够看到自己为了一系列提取所写的所有测试， 万一想要更换提取方式的话就可以轻松地撤销这些测试。完成提取之后，我往往会删除这些测试， 或者将它们重构一下用来测试提取出来的新方法。

<span style="color: #3CB371;">感知变量是分解巨型方法的利器。你可以用它们来对锯齿状方法中内嵌层次很深的代码进行重构，但你同样也可以用它们来逐步将一个锯齿状方法“反锯齿”。例如，如果一个方法内的大 部分代码都被深深地嵌在了一组条件语句内的话，便可以利用感知变量来提取其中的条件语句或 块。而对于提取出来的新方法，同样也可以使用感知变量。直到整个代码被成功“反锯齿”。</span>

**22.3.2**  **只提取你所了解的**

另一个可以用来对付巨型方法的策略就是一开始迈小步，寻找那些我们可以不用测试也能放 心提取出来的小块代码，然后添加测试来覆盖它们。但是，等等，我得换个方式来表达，因为每 个人对“小”的定义是不一样的。当我说“小块代码”时，我指的是两到三行，最多五行的代码， 一块你能够容易地给它想出名字的代码。在进行这些小步提取时需要关心的关键的一个因素是耦  合数。耦合数就是指传进传出你所提取的方法的值的总数。例如，如果我们从下面这段代码中提取出一个max方法的话，它的耦合数就会是3。
![[Pasted image 20240524111928.png]]
该方法的耦合数就是3:两个传进的值(参数),一个传出的值(返回值)。 一般来说最好提 取那些耦合数小的方法，因为这样犯错的概率较小。因此，当你在选择提取哪些代码时，可以寻找一段行数较小的代码，然后数一数进入这块代码以及从这块代码出去的变量一共有多少。对成 员变量的访问不算，因为我们只是简单地将这块代码剪切复制出来而已；因此成员变量并不“穿 过”我们所提取出来的方法的接口。

方法提取过程中的一个主要危险是类型转换错误。因而如果我们只提取那些低耦合数的方 法，就能够更好地避免这类情况。在确定了一个可能的提取之后，应该回头看看那些传进这块代 码的变量是在哪儿定义的，这么做是为了避免弄错方法的签名。

如果说低耦合数的提取是安全的，那么是不是就意味着0耦合数的提取是最安全的呢?是的。 实际上，通过将一个巨型方法中的那些不接受任何参数也不返回任何值的代码块提取成方法，我  们就可以获得许多活动空间。这类方法实际上就是所谓的“命令式”方法——比如你命令一个对  象对它的状态做某些事情，或者更恶劣地对全局状态做某些事情。不管怎样，对于这类代码，当  你试图给它们起名字时，通常能够对该块代码获得更深刻的认识，比如关于它是做什么的，它会  怎样影响特定的对象等。而这种认识又进而能导致更多的认识，最终你将能够换一种更有效率的  视角来看待你的设计。

当使用只提取你所了解的(Extract What You Know) 手法时，记住别去选太大的代码块，如果耦合数大于0,那么通常使用一个感知变量是有好处的。提取完之后，别忘了给你的新方法写几个测试。

然而，当把这一技术用在小块小块的代码上时，你可能会觉得这对整个庞然大物的方法来说 有点杯水车薪的感觉。然而，实际上正如俗语所云：积跬步以至千里。每次当你回过头去提取出 又一小块代码时，就不知不觉间又迈进了一步，同时你的方法也更清晰了一分。渐渐地，你会发 现对该方法有了更好的认识，同时也更清楚如何修改它了。

**当手头没有重构工具时，我通常一开始会提取0耦合数的方法，这一步只是为了能够对代码 的整体结构有一个认识。对后面进行测试以及其他工作是一个很好的准备。

如果你有一个项目列表式方法，那么可能会觉得你将能够提取出许多0耦合数的方法，而且 每个都不错。是的，有些代码块的确如你所想，但通常许多代码块都会用到前面声明了的局部变量。 所以，有时候你必须得抛开所看到的代码块结构，而是从块内或者块间去寻找低耦合数的方法。

**22.3.3**  **依** **赖** **收** **集**

有时候一个巨型方法里面会出现一些看起来跟该方法的主要意图不怎么有联系的代码。这些方法也许是必要的，但并不十分复杂，而且如果你不小心破坏了它，很明显就能看出来。但尽管 这些都是实话，你仍然还是没法冒这个险。那么在这类情况下该怎么办呢?你可以使用一种叫做 依赖收集(gleaning dependencies)的手法。首先你编写测试来保护你要保护的逻辑。然后，你提 取出你的测试所没有覆盖到的部分。这么一来，你至少可以确信你保护住了重要的行为。下面就 是一个简单的例子：
![[Pasted image 20240524112229.png]]
如果我们把负责显示的代码搞糟了，则很快就能看到后果。然而，在添加entry 的代码部分， 如果引入了一个错误的话，就不是那么容易能找出来的了。在像这样的例子中，我们可以编写测试来确保entry 的添加总是在正确前提下发生的。然而， 一旦确信这些重要行为已经被保护起来  了，我们便可以将负责显示部分的代码提取出来，并同时确信我们的提取不会影响到entry   的添加。

某种意义上，这一手法就像鸵鸟战术。你保护了一组行为，而同时在无保护的情况下修改其 他代码。但在一个应用当中，并非所有的行为都是平等的。有些行为更重要，我们在修改代码时 能够将它们识别出来。

依赖收集是一种强大的策略，尤其是当重要行为与其他行为纠缠在一起的时候。 一旦对重要 行为建立起了坚固的测试，便可以做许多编辑修改，虽然从技术上讲这些修改并没有全被测试覆 盖，但测试至少护住了那些关键的行为。

**22.3.4**  **分解出方法对象**

感知变量是非常强大的工具，但有时候我们会注意到，方法里面本就已经有了可以直接被 用作感知变量的变量了，只不过它们也许是局部变量。要是成员变量的话，我们便可以在一个 方法被调用之后通过它们来进行感知了。而实际上，我们的确可以将一个局部变量变成成员变 量，只不过许多情况下这么做可能会带来一些混乱——所提取出来的成员变量只对你的巨型方法以及从该方法中提取出来的方法有意义。尽管每次你的巨型方法被调用起来的时候该变量都 会被重新初始化，但如果想要单独调用所提取出来的那些方法的话，就难以弄清这些变量到底 持有什么值了。

一个替代方案是使用分解出方法对象 (Break  Out  Method Object)手法。该手法是由Ward  Cunningham首先引入的，它是一种典型的人为抽象。当你分解出一个方法对象时，实际上就是创 建了一个类，其唯一职责是做原来的巨型方法所做的工作。原巨型方法的参数变成了该类的构造  函数的参数，原巨型方法中的代码则可以放到该类中的一个名叫zun()  或execute()     的方法中。 一旦代码被移到了新类中，重构起来就方便多了。我们可以将方法中的局部变量做成该类的成员 变量，并让它们充当我们的感知变量。

分解出方法对象是相当激烈的改动，但与引入感知变量(239页)手法不同的是，前者的“感 知变量”同样也是产品代码要用到的变量。这就意味着你写出来的测试会一直可用。具体例子可 参见后面专门介绍这一手法的章节。

**22.4**   **策** **略**

本章介绍的技术能够帮助你将巨型方法分解，从而利于后面的重构或特性添加。本节介绍的 一些原则会帮助你在做这项工作的时候在代码结构上作出权衡。

**22.4.1**  **主干提取**

如果摆在你面前的是一个条件语句，而你的任务是找出哪儿可以提取出一个方法来，那么你有两个选择： 一是将条件和分支一同提取出来，二是分别提取。例如：
![[Pasted image 20240524112624.png]]
我将这一手法叫做主干提取(Skeletonize),因为你实质上是将代码的主干提取出来：即控制 结构以及对其他方法的委托(调用)。

**22.4.2**  **序列发现**

假设你手里有一个条件语句，而你想要找到提取方法的地点。那么你有两个选择： 一，将条 件和分支体一同提取出来；二，分开来提取。下面是另一个例子：
![[Pasted image 20240524112714.png]]之所以这么说，是因为在这个长方法内的其他(除我们提取出来的这部分之外)代码可能只 是一系列的操作， 一个接一个；于是只要将这块条件代码也提取为单一的操作(方法调用);就 能够对整个方法有一个更清晰的认识。

等一下，我是不是自相矛盾了。没错。实际上，我常常在主干提取跟序列发现这两者之间来来回回。而且我打赌你也会。当我觉得某个控制结构在被澄清之后还需要被重构的话，就会采用 主干提取。而另一方面，当我觉得呈现出代码中的序列结构能让代码变得更清晰的话，就会使用 序列发现。

面对项目列表式方法，我往往会使用序列发现，而锯齿状方法则是主干提取。然而到底选用 哪种策略其实还是取决于你在提取的时候对设计的洞察。

**22.4.3**  **优先提取到当前类中**

在从一个巨型方法中提取代码时，你可能会注意到其中有些代码块其实是应该属于其他类 的。对此一个很强的暗示就是你想给新方法起的名字。比如说你看到一块将要提取出来的代码， 然后很想用它用到的某个变量的名字来给这块代码命名，那么很可能这就意味着你提取出来的代 码应属于那个变量的类。比如下面这段代码：
![[Pasted image 20240524112819.png]]看起来我们可以将这块代码叫做recalculateOrder。 这是个不错的名字，但如果我们在名 字中用到了“order”这个单词，那么或许这块代码应当转移到order 类当中去，并起名叫做 recalculate 。Order        已经有了一个名叫recalculate       的方法，所以我们或许应该想想现在的  这个recalculate 跟order 上原有的那个到底有何区别，并将这一信息用在方法名上；或者我们  也可以重命名原来的那个recalculate。  但不管怎样，看起来这块代码确实应该属于order 类。
尽管将代码直接提取到另一个类中听起来很诱人，但实际上，别这么做。笨拙的名字可以先 用着。比如recalculateOrder  这个名字，笨重是笨重，但它让我们得以进行一些能够轻易撤销 的提取，从而试探我们的提取是否正确，是否能够继续往下提取。之后，当好的修改自然而然浮 现出来的时候，我们再将这些方法转移到别的类中去也不迟。而就目前来说，提取到当前类中能 够确保我们继续手头的工作，而且更不容易出错。

**22.4.4**   **小** **块** **提** **取**

我曾在上文提到这一手法，但这里我想再强调一遍：优先提取小块代码。虽说对于庞然大物 般的方法来说，提取一小块代码看起来是蝼蚁撼树，但假以时间，随着小块小块的代码不断被提 取出来，你便会发现自己对该方法有了新的认识。比如，你可能会发现一个操作序列从代码结构 中清晰地浮现出来(原本被埋在一堆分支结构中),比如，你可能会发现一个更好的组织该方法 的方式。于是你可以朝着你所看到的方向前进。这样一种渐进式的方法比起一开始就想将巨型方 法大卸八块的做法要好得多。后者常常并不像它看上去那么容易；而且也不安全， 一不小心就会 忘记一些细节，而细节却是代码中必不可少的成分。

**22.4.5**   **时** **刻** **准** **备** **重** **新** **提** **取**

切一块蛋糕有很多种切法，同样，分解一个巨型方法也有很多办法。往往在做了一些提取之 后，你会发现还有能更容易地适应新特性的提取方式。对于这种情况，最佳做法有时便是撤销一两个提取，并重新提取。这么做并不是说前面的提取都白做了，事实上它们带给了你一些非常重要的认识：对原有设计以及更佳的改进方式的认识。

***
在软件工程中，耦合（Coupling）指的是模块或组件之间依赖关系的强弱。耦合度是衡量这些依赖关系强弱的一个度量指标。耦合度越高，意味着一个模块对另一个模块的依赖越大，修改一个模块可能会影响到另一个模块，降低了系统的灵活性和可维护性。

### 耦合度的分类

耦合度可以按照强弱程度进行分类，从高耦合到低耦合，通常分为以下几类：

1. **内容耦合（Content Coupling）**：
   - 最强的耦合。一个模块直接访问或修改另一个模块的数据或控制流。
   - 例如，一个模块直接修改另一个模块的局部数据。

2. **公共耦合（Common Coupling）**：
   - 多个模块共享全局数据。
   - 例如，多个模块访问同一个全局变量。

3. **外部耦合（External Coupling）**：
   - 模块依赖于外部环境，如文件格式、通信协议等。
   - 例如，一个模块依赖于特定的文件格式来读取数据。

4. **控制耦合（Control Coupling）**：
   - 一个模块控制另一个模块的行为，通过参数传递控制信息。
   - 例如，一个模块通过参数告诉另一个模块该如何执行。

5. **标记耦合（Stamp Coupling）**：
   - 模块间通过复合数据结构（如对象、结构体）传递数据。
   - 例如，一个模块将一个对象作为参数传递给另一个模块。

6. **数据耦合（Data Coupling）**：
   - 模块间通过简单数据类型（如整数、字符）传递数据。
   - 例如，一个模块将一个整数作为参数传递给另一个模块。

7. **无耦合（No Coupling）**：
   - 最低的耦合。模块之间没有任何依赖关系。

### 如何降低耦合度

为了提高系统的灵活性和可维护性，通常需要尽量降低模块之间的耦合度。以下是一些常用的方法：

1. **使用接口和抽象**：
   - 通过定义接口或抽象类，将模块之间的依赖关系限定在接口层，而不是具体实现层。
   - 例如，使用依赖注入（Dependency Injection）来提供模块的依赖对象。

2. **减少全局变量的使用**：
   - 尽量避免使用全局变量，使用参数传递来共享数据。
   - 例如，将全局变量替换为函数参数或类的属性。

3. **模块职责单一**：
   - 设计时确保每个模块只负责特定的功能，避免模块间的复杂依赖。
   - 例如，遵循单一职责原则（Single Responsibility Principle）。

4. **松耦合设计**：
   - 使用设计模式（如观察者模式、策略模式等）来降低模块之间的耦合。
   - 例如，使用观察者模式来通知多个模块状态的变化，而不是直接调用它们。

5. **模块间通信规范化**：
   - 通过标准的接口或协议进行模块间的通信，避免依赖具体的实现细节。
   - 例如，使用REST API或消息队列来实现模块间的通信。

### 耦合度的度量

耦合度通常通过静态代码分析工具来度量，这些工具可以分析代码中模块之间的依赖关系，生成耦合度报告。这些报告可以帮助开发者识别高耦合的模块，从而采取措施降低耦合。

通过降低耦合度，可以提高系统的模块化程度，使系统更容易理解、维护和扩展。