
## 从过程到事件
异步编程和我们熟悉的同步编程最大的区别，就是它要我们从事件的角度来编写和理解代码。

就像我举的生活中的一些例子，说的做的多是“事情”。

由于我们一般先学习的是对象、方法和过程这些模型，已经建立了一定的思考模式，对于事件驱动的编程模型可能会有点不习惯。事实上，熟悉了异步编程的思路，你会发现异步编程很贴近我们的生活模式。

在下面的例子，我使用了 JDK 11 新添加的 HttpClient 接口。最后一个语句，就是一个异步模式。这个语句的意思，就是交代一件事情：“访问 www.example.com “并且把响应数据打印到标准输出上。”需要注意的是，这个语句就是发布了这条指令。指令发布完，这个语句的任务就完成了，就可以执行下一个语句了，不需要等待指令交代的任务完成。
```
// Create an HTTP client that prefers HTTP/2.
HttpClient httpClient = HttpClient.newBuilder()
               .version(Version.HTTP_2)
               .build();

// Create a HTTP request.
HttpRequest httpRequest = HttpRequest.newBuilder()
               .uri(URI.create("https://www.example.com/"))
               .build();

// Send the request and set the HTTP response handler
httpClient.sendAsync(httpRequest, BodyHandlers.ofString())
               .thenApply(HttpResponse::body)
               .thenAccept(System.out::println);  

// next action
```

我们可以对比一下传统的代码。下面的代码使用了 JDK 10 以前的 HttpURLConnection 接口。完成的是同样的任务。不同的是，下一件事情的代码需要等待上一件事情的完成，才能执行。也就是说，建立网络连接之后，才能执行读取响应数据的代码。
```
// Open the connection
URL url = new URL("https://www.example.com/");
HttpsURLConnection urlc = (HttpsURLConnection)url.openConnection();

// Read the response
try (InputStream is = urlc.getInputStream()) {
    while (is.read() != -1) {    // read to EOF
        // dump the response
        // snipped
    }
}

// next action
```
使用 HttpURLConnection 接口的代码，无论是连接过程，还是响应数据的读取过程，都依赖于网络环境，而不仅仅是计算机的环境。如果网络环境的响应时间是三秒，那么上面的代码就要阻塞三秒，无法执行下一步操作。而 HttpClient 接口的代码，指令发布完，就可以执行下一步操作了。这个指令的执行时间，一般是毫秒以下的数量级别。如果我们不考虑其他因素的影响，那么上面的两个例子中，异步模式在网络阻塞期间，能够更好地利用其他的计算资源，从而提高整体的效率。

### 异步是怎么实现的？
你是不是有个疑问，指令交代的任务是怎么完成的？

异步的实现，依赖于底层的硬件和操作系统；

如果操作系统不支持，异步也可以通过线程来模拟。即便是只能通过线程来模拟，异步编程也简化了线程管理的难度。甚至能够把线程管理变透明，隐藏起来。

比如我们上面使用的 HttpClient 接口的代码，就没有线程的影子，看起来像一个单线程程序。

异步编程对性能的爆炸性的提升来自于硬件和操作系统对异步的支持。比如说，早期传统的套接字编程，应用程序需要等待下一个连接的到来，然后等待连接数据的传输……这些等待，都需要耗费很多资源。这些被占用的资源，在连接和数据到来之前，都是没有被充分利用的资源。

如果操作系统能够主动告诉应用程序，什么时候有一个连接请求，这个连接里什么时候有数据。应用程序就可以在连接和数据到来之后，再分配资源进行处理。操作系统在合适的时间，遇到触发事件，主动调用设置的应用程序，执行相关的操作。这就是操作系统对异步 I/O 的支持。

比如说，如果一个简单的服务就返回一个"Hello, World!"，它能够同时接受多少用户访问呢？如果使用传统的一个线程一个用户的模式，这个用户数量完全取决于线程的效率和容量。随着用户数的增加，线程数量也线性增加，线程管理也越来越复杂，线程的效率也加速下降，线程处理能力决定了系统最大可承载的用户数。

如果使用异步 I/O，每一个 CPU 分派一个线程就足以应付所有的连接。这时候，连接的效率就主要取决于硬件和操作系统的能力了。根据常见的数据，这种效率的提升通常可以达到几百倍。

***

# C# await 关键字工作原理详解

当遇到 `await` 关键字时，确实会发生一种"返回"到调用方的行为，但这个过程比简单的返回更复杂。以下是详细的步骤解释：

1. **遇到 await**：
   当执行到 `await` 关键字时，编译器会检查被等待的任务（Task）是否已经完成。

2. **任务已完成**：
   如果任务已经完成，程序会继续执行 `await` 之后的代码，就像普通的同步代码一样。

3. **任务未完成**：
   如果任务未完成，会发生以下行为：

   a. **方法暂停**：当前方法的执行被暂停。
   
   b. **返回控制权**：控制权立即返回给调用者。这就是您所说的"立即返回到上层方法"。
   
   c. **状态保存**：当前方法的状态（包括局部变量和执行位置）被保存。
   
   d. **注册续做**：系统会注册一个续做（continuation），以便在任务完成时恢复执行。

4. **任务完成后**：
   当被等待的任务最终完成时：

   a. **触发续做**：之前注册的续做被触发。
   
   b. **恢复执行**：方法从 `await` 的下一行继续执行，使用之前保存的状态。

5. **线程考虑**：
   - 恢复执行可能发生在不同的线程上，除非有特定的同步上下文（如 UI 线程）。
   - 在 ASP.NET Core 等环境中，可能会使用线程池中的任何可用线程来继续执行。

6. **异常处理**：
   - 如果被等待的任务抛出异常，该异常会在 `await` 表达式处被重新抛出。
   - 这允许使用正常的 try-catch 语句来处理异步操作中的异常。

7. **编译器转换**：
   编译器将整个异步方法转换为一个状态机，管理这个复杂的暂停和恢复过程。

## 关键点

- `await` 不会阻塞线程，而是允许当前方法暂停执行，释放线程去处理其他工作。
- 当被等待的任务完成时，方法会从 `await` 之后的点继续执行。
- 这个机制使得异步代码可以像同步代码一样直观地编写和阅读，同时保持非阻塞的特性。

通过这种方式，C# 的 async/await 模式在保持代码可读性的同时，实现了高效的异步编程模型。