## 安全代码的检查清单
### 安全管理
+ 有没有安全更新的策略和落实计划？
+ 有没有安全漏洞的保密共识和规范？
+ 有没有安全缺陷的评估和管理办法？
+ 软件是不是使用最新的安全修复版？
+ 有没有定义、归类和保护敏感信息？
+ 有没有部署多层次的安全防御体系？
+ 安全防御能不能运转良好、及时反应？
+ 不同的安全防御机制能不能独立运转？
+ 系统管理、运营人员的授权是否恰当？
+ 有没有风险管理的预案和长短期措施？
### 代码评审
+ 数值运算会不会溢出？
+ 有没有检查数值的合理范围？
+ 类、接口的设计，能不能不使用可变量？
+ 一个类支持的是深拷贝还是浅拷贝？
+ 一个接口的实现，有没有拷贝可变的传入参数？
+ 一个接口的实现，可变的返回值有没有竞态危害？
+ 接口的使用有没有严格遵守接口规范？
+ 哪些信息是敏感信息？谁有权限获取相应的敏感信息？
+ 有没有定义敏感信息的授权方案？
+ 授予的权限还能不能更少？
+ 特权代码能不能更短小、更简单？
+ 异常信息里有没有敏感信息？
+ 应用日志里有没有敏感信息？
+ 对象序列化有没有排除敏感信息？
+ 高度敏感信息的存储有没有特殊处理？
+ 敏感信息的使用有没有及时清零？
+ 一个类，有没有真实的可扩展需求，能不能使用 final 修饰符？
+ 一个变量，能不能对象构造时就完成赋值，能不能使用 final 修饰符？
+ 一个方法，子类有没有重写的必要性，能不能使用 final 修饰符？
+ 一个集合形式的变量，是不是可以使用不可修改的集合？
+ 一个方法的返回值，能不能使用不可修改的变量？
+ 类、方法、变量能不能使用 private 修饰符？
+ 类库有没有使用模块化技术？
### 模块设计
+ 能不能分割内部实现和外部接口？
+ 有没有定义清楚内部数据、外部数据的边界？
+ 外部数据，有没有尽早地完成校验？
+ 有没有标示清楚外部数据的校验点？
+ 能不能跟踪未校验外部数据的传送路径？
+ 有没有遗漏的未校验外部数据？
+ 公开接口的输入，有没有考虑数据的有效性？
+ 公开接口的可变化输出，接口内部行为有没有影响？
+ 有没有完成无法识别来源的数据的校验？
+ 能不能不使用序列化技术？
+ 序列化的使用场景，有没有足够的安全保障？
+ 软件还存在什么样风险？
+ 有没有记录潜在的风险问题？
+ 有没有消除潜在风险的长期预案？
+ 有没有消除潜在风险的短期措施？
+ 潜在的风险问题如果出现，能不能快速地诊断、定位、修复？

## 小结
学会编写安全的代码，是一个优秀的、专业的软件工程师的核心竞争力之一。

与规范、经济的代码相比，安全的代码有很多不同的特点。

代码不规范和效率不高，业务也可以运转，然后慢慢优化，逐渐演进。但代码一旦出现安全问题，遭受攻击，损失立即就会反映出来，而且破坏性极大。

代码不规范，看的人立刻就会觉得很难受。

代码的效率不高，业务运转不通畅，同样会有及时的反馈。

就代码的安全层面来说，一般情况下直到攻击发生之前，我们可能都不知道代码是否存在安全问题。等到攻击真实发生的时候，损失已经成为事实了。

代码的规范原则，是一个相对容易掌握的内容。
高效的代码，也有很多成熟的经验可以学习。
可是，代码的安全，却是一个攻易守难的问题。

哪怕我们今天知道了所有的攻击和防护方法（这当然不可能），如果明天出现了一种新的攻击手段，而且全世界只有一个人知道，我们的系统都存在潜在的安全威胁。

编写安全的代码，需要掌握复杂的知识，而且需要大规模的合作。

我们之前提到过三道槛，具体展开来是这样的：我们要想掌握安全编码的技术，熟练修复软件漏洞的实践，需要先过三道关。

第一道关，是意识（Conscious）。也就是说，要意识到安全问题的重要性，以及意识到有哪些潜在的安全威胁。

第二道关，是知晓（Awareness）。要知道软件有没有安全问题，安全问题有多严重。

第三道关，是看到（Visible）。要了解是什么样的问题导致了安全漏洞，该怎么修复安全漏洞。

在意识、知晓、看到这三道关面前，我们要打开自己的视野，保持强烈的好奇心，从全世界范围内学习成熟的经验、先进的技术以及最新的进展。

其中，最重要的资源是 NIST 提供的安全漏洞数据库。这个数据库的使用方式有两种：第一种是了解自己的系统有没有最新的安全漏洞；第二种是学习最新的安全威胁的攻击方法和防范技术。