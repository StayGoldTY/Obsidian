问：借Google Guava学习发现和开发通用功能模块,能以c#代码为例，如何更好的开发通用功能模块吗？比如要遵循那些原则，以及如何具体实践

## Grok
通过借鉴 Google Guava 的设计理念，我们可以学习如何用 C# 开发高质量的通用功能模块。Guava 是一个 Java 工具库，强调模块化、可复用性和清晰的 API 设计。以下是结合 C# 开发通用功能模块时应遵循的原则，以及具体的实践方法和示例代码。

---

### 一、通用功能模块开发的核心原则

1. **单一职责原则 (SRP)**  
   - 每个模块或类应该只负责单一功能，职责明确，避免功能膨胀。
   - 例如，Guava 的 `Preconditions` 只处理前置条件检查，职责清晰。

2. **高内聚低耦合**  
   - 模块内部逻辑紧密相关（高内聚），与其他模块的依赖尽量减少（低耦合）。
   - 使用接口或抽象类定义模块的契约，降低实现细节的暴露。

3. **API 设计的简洁性和一致性**  
   - 提供直观、易用的 API，避免用户需要阅读大量文档才能使用。
   - 方法命名应遵循一致的命名规范，例如动词优先（如 `checkNotNull`）。

4. **不可变性和线程安全性**  
   - 优先设计不可变对象，减少副作用和线程安全问题。
   - 如果模块涉及并发，需提供线程安全的实现或明确文档说明。

5. **扩展性和灵活性**  
   - 模块应支持扩展（如通过接口或委托），但不强迫用户使用复杂的设计。
   - 例如，Guava 的 `Cache` 提供灵活的配置选项，但默认配置也足够简单。

6. **异常处理规范化**  
   - 使用明确的异常类型，尽量避免抛出模糊的异常（如 `Exception`）。
   - 提供友好的错误信息，帮助用户快速定位问题。

7. **文档化与测试**  
   - 每个公共 API 都需要清晰的文档，说明用途、参数和可能的异常。
   - 编写全面的单元测试，确保模块的稳定性和可靠性。

---

### 二、C# 中开发通用功能模块的具体实践

以下通过几个常见场景，结合 C# 代码，展示如何实践上述原则，设计类似 Guava 的通用功能模块。

#### 1. 前置条件检查模块（类似 Guava 的 `Preconditions`）

**场景**：提供一个工具类，用于检查方法的输入参数，抛出明确的异常。

**实践**：
- 使用静态方法，保持 API 简洁。
- 提供清晰的异常类型和错误信息。
- 支持自定义异常消息。

```csharp
using System;

public static class Preconditions
{
    /// <summary>
    /// 检查对象是否为 null，如果为 null 则抛出 ArgumentNullException。
    /// </summary>
    /// <param name="argument">要检查的对象</param>
    /// <param name="paramName">参数名称</param>
    /// <exception cref="ArgumentNullException">当 argument 为 null 时抛出</exception>
    public static void CheckNotNull<T>(T argument, string paramName)
        where T : class
    {
        if (argument == null)
        {
            throw new ArgumentNullException(paramName, $"{paramName} cannot be null.");
        }
    }

    /// <summary>
    /// 检查条件是否为真，如果为假则抛出 ArgumentException。
    /// </summary>
    /// <param name="condition">要检查的条件</param>
    /// <param name="message">异常消息</param>
    /// <exception cref="ArgumentException">当 condition 为 false 时抛出</exception>
    public static void CheckArgument(bool condition, string message)
    {
        if (!condition)
        {
            throw new ArgumentException(message);
        }
    }
}

// 使用示例
public class Example
{
    public void Process(string input)
    {
        Preconditions.CheckNotNull(input, nameof(input));
        Preconditions.CheckArgument(input.Length > 0, "Input cannot be empty.");
        // 继续处理
        Console.WriteLine($"Processing: {input}");
    }
}
```

**设计亮点**：
- 方法名直观（`CheckNotNull`、`CheckArgument`），符合 Guava 风格。
- 使用泛型支持类型安全。
- 异常信息包含参数名，便于调试。
- 静态方法无需实例化，降低使用成本。

---

#### 2. 集合操作工具模块（类似 Guava 的 `Collections`）

**场景**：提供集合操作的工具方法，例如过滤、分组或合并。

**实践**：
- 扩展 LINQ，提供更简洁的语义。
- 确保方法是纯函数（无副作用）。
- 支持延迟执行（使用 `IEnumerable`）。

```csharp
using System;
using System.Collections.Generic;
using System.Linq;

public static class CollectionUtils
{
    /// <summary>
    /// 从集合中过滤出满足条件的元素，并返回新的列表。
    /// </summary>
    /// <param name="source">源集合</param>
    /// <param name="predicate">过滤条件</param>
    /// <returns>过滤后的新列表</returns>
    public static List<T> Filter<T>(IEnumerable<T> source, Func<T, bool> predicate)
    {
        Preconditions.CheckNotNull(source, nameof(source));
        Preconditions.CheckNotNull(predicate, nameof(predicate));
        return source.Where(predicate).ToList();
    }

    /// <summary>
    /// 将集合按指定键分组，返回不可变的字典。
    /// </summary>
    /// <param name="source">源集合</param>
    /// <param name="keySelector">键选择器</param>
    /// <returns>分组后的只读字典</returns>
    public static IReadOnlyDictionary<TKey, List<T>> GroupBy<TKey, T>(
        IEnumerable<T> source, 
        Func<T, TKey> keySelector)
    {
        Preconditions.CheckNotNull(source, nameof(source));
        Preconditions.CheckNotNull(keySelector, nameof(keySelector));
        return source.GroupBy(keySelector)
                     .ToDictionary(g => g.Key, g => g.ToList())
                     .AsReadOnly();
    }
}

// 使用示例
public class Example
{
    public void Process()
    {
        var numbers = new List<int> { 1, 2, 3, 4, 5, 6 };
        var evens = CollectionUtils.Filter(numbers, x => x % 2 == 0);
        Console.WriteLine(string.Join(", ", evens)); // 输出: 2, 4, 6

        var people = new List<Person>
        {
            new Person { Name = "Alice", Age = 25 },
            new Person { Name = "Bob", Age = 25 },
            new Person { Name = "Charlie", Age = 30 }
        };
        var groupedByAge = CollectionUtils.GroupBy(people, p => p.Age);
        foreach (var group in groupedByAge)
        {
            Console.WriteLine($"Age {group.Key}: {string.Join(", ", group.Value.Select(p => p.Name))}");
        }
        // 输出:
        // Age 25: Alice, Bob
        // Age 30: Charlie
    }
}

public class Person
{
    public string Name { get; set; }
    public int Age { get; set; }
}
```

**设计亮点**：
- 使用 `IEnumerable` 支持延迟执行，性能优化。
- 返回不可变集合（如 `IReadOnlyDictionary`），提高线程安全性。
- 方法职责单一，易于测试。
- 结合 LINQ，保持 C# 的原生风格。

---

#### 3. 缓存模块（类似 Guava 的 `Cache`）

**场景**：提供一个简单的内存缓存，支持过期策略和最大容量。

**实践**：
- 使用线程安全的实现（`ConcurrentDictionary`）。
- 支持配置（如过期时间、最大容量）。
- 提供异步和同步接口。

```csharp
using System;
using System.Collections.Concurrent;
using System.Threading.Tasks;

public class SimpleCache<TKey, TValue>
{
    private readonly ConcurrentDictionary<TKey, CacheEntry> _cache = new();
    private readonly TimeSpan _expiration;
    private readonly int _maxSize;

    private class CacheEntry
    {
        public TValue Value { get; }
        public DateTime Expiry { get; }

        public CacheEntry(TValue value, TimeSpan expiration)
        {
            Value = value;
            Expiry = DateTime.UtcNow + expiration;
        }

        public bool IsExpired => DateTime.UtcNow > Expiry;
    }

    public SimpleCache(TimeSpan expiration, int maxSize = int.MaxValue)
    {
        _expiration = expiration;
        _maxSize = maxSize;
    }

    /// <summary>
    /// 获取或添加缓存项。
    /// </summary>
    public TValue GetOrAdd(TKey key, Func<TKey, TValue> factory)
    {
        Preconditions.CheckNotNull(key, nameof(key));
        Preconditions.CheckNotNull(factory, nameof(factory));

        CleanUp();

        return _cache.AddOrUpdate(
            key,
            k => new CacheEntry(factory(k), _expiration),
            (k, entry) =>
            {
                if (entry.IsExpired)
                {
                    return new CacheEntry(factory(k), _expiration);
                }
                return entry;
            }).Value;
    }

    private void CleanUp()
    {
        if (_cache.Count > _maxSize)
        {
            foreach (var entry in _cache)
            {
                if (entry.Value.IsExpired)
                {
                    _cache.TryRemove(entry.Key, out _);
                }
            }
        }
    }
}

// 使用示例
public class Example
{
    public void Process()
    {
        var cache = new SimpleCache<string, string>(TimeSpan.FromSeconds(10), maxSize: 100);
        string value = cache.GetOrAdd("key1", key =>
        {
            Console.WriteLine($"Computing value for {key}");
            return "value1";
        });
        Console.WriteLine(value); // 输出: Computing value for key1, value1

        string cachedValue = cache.GetOrAdd("key1", key => "newValue");
        Console.WriteLine(cachedValue); // 输出: value1（缓存未过期）
    }
}
```

**设计亮点**：
- 使用 `ConcurrentDictionary` 确保线程安全。
- 支持配置过期时间和最大容量，灵活性强。
- 惰性清理策略，性能开销低。
- API 简单，支持函数式风格（通过 `Func` 提供值工厂）。

---

### 三、借鉴 Guava 的其他经验

1. **链式 API 设计**  
   Guava 的 `FluentIterable` 和 `Builder` 模式提供流畅的 API。在 C# 中，可以使用建造者模式或扩展方法实现类似效果。

   ```csharp
   public class StringBuilder
   {
       private readonly System.Text.StringBuilder _sb = new();

       public StringBuilder Append(string value)
       {
           _sb.Append(value);
           return this;
       }

       public string Build() => _sb.ToString();
   }

   // 使用示例
   var result = new StringBuilder()
       .Append("Hello")
       .Append(" ")
       .Append("World")
       .Build(); // 输出: Hello World
   ```

2. **函数式编程支持**  
   Guava 提供 `Function` 和 `Predicate` 等函数式接口。C# 中可以使用 `Func` 和 `Predicate`，结合 LINQ，简化代码。

3. **性能优化**  
   - 避免不必要的对象分配（如在集合操作中复用缓冲区）。
   - 使用结构体（`struct`）替代小对象，减少 GC 压力。

4. **跨平台兼容性**  
   如果模块需要支持 .NET Framework 和 .NET Core，确保使用兼容的 API，并通过条件编译处理差异。

---

### 四、总结

通过借鉴 Guava 的设计理念，C# 的通用功能模块开发应遵循以下关键点：
- **清晰的职责划分**：模块功能单一，类和方法职责明确。
- **简洁的 API**：提供直观、类型安全的接口，降低使用门槛。
- **安全与性能兼顾**：优先不可变性和线程安全性，同时优化性能。
- **文档与测试完备**：每个公共 API 提供清晰的注释和测试用例。

在实践中，可以从常见需求入手（如前置条件检查、缓存等），逐步构建模块，并通过代码审查和用户反馈优化设计。C# 的语言特性（如 LINQ、泛型、异步编程）与 Guava 的设计哲学相辅相成，能够开发出高质量的通用功能模块。

## Gemini Pro
确实，Google Guava 是 Java 世界中一个非常优秀的通用功能模块库，它提供了许多在日常开发中非常有用的工具类，涵盖了集合、缓存、并发、I/O、字符串处理、基本类型处理、校验、反射等多个方面。我们可以从 Guava 的设计哲学和实现中学习很多，并将其应用到 C# 通用功能模块的开发中。

以下是如何借鉴 Guava 的思想，在 C# 中开发通用功能模块的一些原则和具体实践：

一、核心原则 (Principles)
--------------------

1.  **解决实际问题 (Solve Real, Common Problems)**：
    *   **Guava 的体现**：Guava 的每个组件都旨在解决 Java 开发中反复出现的常见问题。
    *   **C# 实践**：你的通用模块应该专注于解决你在多个项目或团队中反复遇到的痛点。避免过度设计或创建很少被使用的功能。

2.  **简洁易用 (Simplicity and Clarity)**：
    *   **Guava 的体现**：API 设计直观，方法名清晰，易于理解和使用。
    *   **C# 实践**：
        *   使用清晰、描述性的命名（类名、方法名、参数名）。
        *   提供流畅的 API（Fluent Interface），例如通过扩展方法或链式调用。
        *   保持方法参数数量少，职责单一。

3.  **不可变性优先 (Immutability by Default/Preference)**：
    *   **Guava 的体现**：提供了大量不可变集合 (`ImmutableList`, `ImmutableMap` 等)。不可变对象线程安全，易于推理。
    *   **C# 实践**：
        *   优先使用 `System.Collections.Immutable` 命名空间下的不可变集合。
        *   设计自定义类型时，尽可能使其属性只读（`readonly` 字段，只有 `get` 的属性）。
        *   C# 9+ 的 `record` 类型是创建不可变数据类的好选择。

4.  **避免 `null` (Avoid Nulls / Null Safety)**：
    *   **Guava 的体现**：推荐使用 `Optional<T>` 来表示可能缺失的值，而不是返回 `null`。很多 Guava API 不接受 `null` 参数，或明确指出 `null` 的行为。
    *   **C# 实践**：
        *   积极使用 C# 8+ 的可空引用类型 (Nullable Reference Types) 来明确标识哪些引用类型可以为 `null`。
        *   对于方法返回值，如果一个值可能不存在，可以考虑返回一个自定义的 `Option<T>` 或 `Maybe<T>` 结构体（尽管 C# 社区对此接受度不如 Java 的 `Optional` 高，通常更倾向于 `bool TryGet(out T value)`模式或直接使用可空引用/值类型）。
        *   在模块内部，对公开 API 的参数进行 `null` 检查。

5.  **快速失败 (Fail Fast / Preconditions)**：
    *   **Guava 的体现**：`Preconditions` 类用于在方法开头检查参数的有效性，如果无效则立即抛出异常。
    *   **C# 实践**：
        *   在公共方法的开头校验参数。可以使用自定义的 `Guard` 或 `Ensure` 静态类，或者直接使用 `if` 语句抛出 `ArgumentNullException`, `ArgumentOutOfRangeException`, `ArgumentException` 等。
        *   C# 10 引入了 `ArgumentNullException.ThrowIfNull()` 这样的辅助方法。

6.  **泛型化 (Generics for Type Safety)**：
    *   **Guava 的体现**：广泛使用 Java 泛型来提供类型安全。
    *   **C# 实践**：充分利用 C# 强大的泛型系统，使你的工具类能适用于多种数据类型，同时保证编译时类型安全。

7.  **高性能 (Performance Conscious)**：
    *   **Guava 的体现**：Guava 的许多组件都经过精心设计和优化，以提供良好的性能。
    *   **C# 实践**：
        *   关注性能敏感区域，避免不必要的对象分配（尤其是在循环中）。
        *   了解 `struct` vs `class` 的选择，`Span<T>` 和 `Memory<T>` 的使用场景。
        *   进行性能测试和分析，但避免过早优化。

8.  **良好的文档和示例 (Good Documentation and Examples)**：
    *   **Guava 的体现**：拥有详尽的 Javadoc 和官方文档。
    *   **C# 实践**：
        *   为所有公共 API 编写清晰的 XML 文档注释，以便生成 IntelliSense 和外部文档。
        *   提供代码示例，展示如何使用你的模块。

9.  **可测试性 (Testability)**：
    *   **Guava 的体现**：Guava 本身有非常高的测试覆盖率。
    *   **C# 实践**：设计模块时考虑单元测试。避免静态类中过多的静态状态（如果必须，确保可重置或隔离），优先使用依赖注入（尽管对于纯工具类，静态方法更常见）。

10. **专注和内聚 (Focus and Cohesion)**：
    *   **Guava 的体现**：虽然 Guava 功能多，但其内部子模块（如 `com.google.common.collect`, `com.google.common.base`）是高度内聚的。
    *   **C# 实践**：将相关的功能组织在同一个命名空间或程序集中。确保每个类或方法都有明确的职责。

二、具体实践 (Practical Implementation with C# Examples)
------------------------------------------------------

让我们创建一些 C# 示例来模拟 Guava 中的一些概念。

**项目结构建议：**

*   创建一个类库项目，例如 `MyCompany.CommonUtilities`。
*   根据功能组织命名空间，如 `MyCompany.CommonUtilities.Collections`, `MyCompany.CommonUtilities.Strings`, `MyCompany.CommonUtilities.Validation`。

**示例 1：前置条件校验 (Preconditions / Guards)**

类似 Guava 的 `Preconditions`。

```csharp
// In MyCompany.CommonUtilities.Validation/Ensure.cs
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis; // For NotNullWhen
using System.Linq;
using System.Runtime.CompilerServices; // For CallerArgumentExpression

namespace MyCompany.CommonUtilities.Validation
{
    public static class Ensure
    {
        public static T NotNull<T>(T value, [CallerArgumentExpression("value")] string? paramName = null) where T : class
        {
            // C# 10+ has ArgumentNullException.ThrowIfNull(value, paramName);
            if (value == null)
            {
                throw new ArgumentNullException(paramName);
            }
            return value;
        }

        public static T? NotNullIfNotNull<T>(T? value, [CallerArgumentExpression("value")] string? paramName = null) where T : class
        {
            // This is useful if you want to allow null but if it's not null, ensure something about it
            // Or more commonly, for struct arguments that are nullable
            return value; // The check is for the caller - if they pass non-null, it's fine.
        }

        public static string NotNullOrEmpty(string value, [CallerArgumentExpression("value")] string? paramName = null)
        {
            NotNull(value, paramName); // Check for null first
            if (string.IsNullOrEmpty(value)) // Technically redundant with NotNull, but good for clarity if called directly
            {
                throw new ArgumentException("String cannot be empty.", paramName);
            }
            return value;
        }

        public static string NotNullOrWhiteSpace(string value, [CallerArgumentExpression("value")] string? paramName = null)
        {
            NotNull(value, paramName);
            if (string.IsNullOrWhiteSpace(value))
            {
                throw new ArgumentException("String cannot be null or consist only of white-space characters.", paramName);
            }
            return value;
        }

        public static ICollection<T> NotNullOrEmpty<T>(ICollection<T> collection, [CallerArgumentExpression("collection")] string? paramName = null)
        {
            NotNull(collection, paramName);
            if (collection.Count == 0)
            {
                throw new ArgumentException("Collection cannot be empty.", paramName);
            }
            return collection;
        }

        public static void IsTrue(bool condition, string message, [CallerArgumentExpression("condition")] string? paramName = null)
        {
            if (!condition)
            {
                throw new ArgumentException(message, paramName);
            }
        }

        // ... other checks like IsInRange, IsGreaterThan, etc.
    }
}

// Usage:
public class UserService
{
    public void UpdateUsername(int userId, string newUsername)
    {
        Ensure.IsTrue(userId > 0, "User ID must be positive.", nameof(userId));
        Ensure.NotNullOrWhiteSpace(newUsername, nameof(newUsername));

        // ... logic
    }
}
```

**示例 2：字符串工具 (String Utilities)**

类似 Guava 的 `Strings`, `Splitter`, `Joiner`。C# 的 `string` 和 LINQ 已经很强大，但有时可以提供更流畅或特定场景的 API。

```csharp
// In MyCompany.CommonUtilities.Strings/StringExtensions.cs
using MyCompany.CommonUtilities.Validation;
using System;
using System.Collections.Generic;
using System.Linq;

namespace MyCompany.CommonUtilities.Strings
{
    public static class StringExtensions
    {
        /// <summary>
        /// Checks if a string is null, empty, or consists only of white-space characters.
        /// Syntactic sugar for string.IsNullOrWhiteSpace.
        /// </summary>
        public static bool IsNullOrWhiteSpace(this string? value)
        {
            return string.IsNullOrWhiteSpace(value);
        }

        /// <summary>
        /// Checks if a string is null or empty.
        /// Syntactic sugar for string.IsNullOrEmpty.
        /// </summary>
        public static bool IsNullOrEmpty(this string? value)
        {
            return string.IsNullOrEmpty(value);
        }

        /// <summary>
        /// Joins a sequence of strings with the specified separator, skipping null or empty elements.
        /// </summary>
        public static string JoinSkipEmpty(this IEnumerable<string?>? source, string separator)
        {
            if (source == null) return string.Empty;
            Ensure.NotNull(separator, nameof(separator)); // Separator itself shouldn't be null

            return string.Join(separator, source.Where(s => !string.IsNullOrEmpty(s)));
        }

        /// <summary>
        _/// Truncates the string to a specified maximum length, appending an ellipsis if truncated.
        /// </summary>
        public static string Truncate(this string? value, int maxLength, string ellipsis = "...")
        {
            if (string.IsNullOrEmpty(value)) return string.Empty; // or value itself if you prefer
            Ensure.IsTrue(maxLength >= 0, "Max length must be non-negative.", nameof(maxLength));
            Ensure.NotNull(ellipsis, nameof(ellipsis));

            if (value.Length <= maxLength)
            {
                return value;
            }
            if (maxLength <= ellipsis.Length) // Not enough space for ellipsis
            {
                return value.Substring(0, maxLength); // Just truncate, no ellipsis
            }
            return value.Substring(0, maxLength - ellipsis.Length) + ellipsis;
        }
    }

    // Guava's Splitter is more powerful, allowing chained configurations.
    // Here's a simplified fluent splitter concept:
    public class FluentSplitter
    {
        private readonly string _source;
        private char _separator = ','; // Default separator
        private bool _trimResults = false;
        private bool _omitEmptyStrings = false;

        private FluentSplitter(string source)
        {
            _source = Ensure.NotNull(source, nameof(source));
        }

        public static FluentSplitter On(string source)
        {
            return new FluentSplitter(source);
        }

        public FluentSplitter WithSeparator(char separator)
        {
            _separator = separator;
            return this;
        }

        public FluentSplitter TrimResults()
        {
            _trimResults = true;
            return this;
        }

        public FluentSplitter OmitEmptyStrings()
        {
            _omitEmptyStrings = true;
            return this;
        }

        public IEnumerable<string> Split()
        {
            IEnumerable<string> result = _source.Split(_separator);

            if (_trimResults)
            {
                result = result.Select(s => s.Trim());
            }

            if (_omitEmptyStrings)
            {
                result = result.Where(s => !string.IsNullOrEmpty(s));
            }
            return result.ToList(); // ToList to materialize, or return IEnumerable
        }
    }
}

// Usage:
// string data = " apple , banana ,, orange ";
// var parts = FluentSplitter.On(data)
//                           .WithSeparator(',')
//                           .TrimResults()
//                           .OmitEmptyStrings()
//                           .Split(); // ["apple", "banana", "orange"]

// string longText = "This is a very long text that needs truncation.";
// string shortText = longText.Truncate(20); // "This is a very long..."
```

**示例 3：集合工具 (Collection Utilities)**

.NET LINQ 非常强大。Guava 的 `Iterables`, `Lists`, `Maps` 等在 Java 中填补了标准库的一些空白。在 C# 中，我们更多的是提供便利的扩展或特定场景的帮助类。

```csharp
// In MyCompany.CommonUtilities.Collections/CollectionExtensions.cs
using MyCompany.CommonUtilities.Validation;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics.CodeAnalysis; // For NotNullWhen

namespace MyCompany.CommonUtilities.Collections
{
    public static class CollectionExtensions
    {
        /// <summary>
        /// Checks if a collection is null or empty.
        /// </summary>
        public static bool IsNullOrEmpty<T>([NotNullWhen(false)] this IEnumerable<T>? source)
        {
            if (source == null) return true;
            // For ICollection, Count is faster. For general IEnumerable, Any() is better than Count().
            if (source is ICollection<T> collection) return collection.Count == 0;
            if (source is IReadOnlyCollection<T> readOnlyCollection) return readOnlyCollection.Count == 0;
            return !source.Any();
        }

        /// <summary>
        /// Adds items from the source enumerable to the collection if they are not null.
        /// </summary>
        public static void AddRangeIfNotNull<T>(this ICollection<T> target, IEnumerable<T?>? source) where T : class
        {
            Ensure.NotNull(target, nameof(target));
            if (source == null) return;

            foreach (var item in source)
            {
                if (item != null)
                {
                    target.Add(item);
                }
            }
        }
        
        /// <summary>
        /// Partitions a sequence into two collections based on a predicate.
        /// </summary>
        /// <typeparam name="T">The type of the elements of source.</typeparam>
        /// <param name="source">An <see cref="IEnumerable{T}"/> to partition.</param>
        /// <param name="predicate">A function to test each element for a condition.</param>
        /// <returns>A tuple containing two lists: the first with elements that satisfy the predicate,
        /// and the second with elements that do not.</returns>
        public static (List<T> TrueList, List<T> FalseList) Partition<T>(
            this IEnumerable<T> source, 
            Func<T, bool> predicate)
        {
            Ensure.NotNull(source, nameof(source));
            Ensure.NotNull(predicate, nameof(predicate));

            var trueList = new List<T>();
            var falseList = new List<T>();

            foreach (var item in source)
            {
                if (predicate(item))
                {
                    trueList.Add(item);
                }
                else
                {
                    falseList.Add(item);
                }
            }
            return (trueList, falseList);
        }
    }
}

// Usage:
// List<int> numbers = new List<int> { 1, 2, 3, 4, 5, 6 };
// var (evens, odds) = numbers.Partition(n => n % 2 == 0);
// evens will be [2, 4, 6], odds will be [1, 3, 5]

// List<string> myStrings = null;
// if (myStrings.IsNullOrEmpty()) { /* ... */ }
```

**示例 4：Option/Maybe 类型 (Alternative to Nullable Reference/Value Types for expressiveness)**

虽然 C# 有可空类型，但有时一个明确的 `Option<T>` 类型能更清晰地表达“可能有值也可能没有值”的语义，特别是当 `null` 本身有特定含义，或者希望链式操作可能不存在的值时。

```csharp
// In MyCompany.CommonUtilities.Functional/Option.cs
using System;
using System.Collections.Generic;

namespace MyCompany.CommonUtilities.Functional
{
    public readonly struct Option<T> : IEquatable<Option<T>>
    {
        private readonly T _value;
        public bool HasValue { get; }

        public T Value => HasValue ? _value : throw new InvalidOperationException("Option has no value.");

        private Option(T value)
        {
            _value = value;
            HasValue = true;
        }

        public static Option<T> Some(T value)
        {
            // For reference types, you might want to Ensure.NotNull(value, nameof(value));
            // Or allow Option<string>.Some(null) if null is a valid "Some" value in your domain.
            // Typically, Some(null) for reference types is discouraged; None should be used.
            if (value == null && typeof(T).IsClass) // Or !typeof(T).IsValueType
            {
                 // This behavior is debatable. Some prefer Some(null) to be an InvalidOperationException
                 // or for Some() to throw if value is null.
                 // Guava's Optional.of(null) throws. Optional.ofNullable(null) returns empty.
                 // For simplicity here, we let Option<string>.Some(null) be a thing,
                 // but often it's better to enforce non-null for Some.
            }
            return new Option<T>(value);
        }

        public static Option<T> None { get; } = new Option<T>(); // Default struct constructor sets HasValue to false

        public T GetValueOrDefault(T defaultValue) => HasValue ? _value : defaultValue;
        public T GetValueOrDefault() => HasValue ? _value : default!; // default! for T

        // Fluent operations
        public Option<TResult> Map<TResult>(Func<T, TResult> map) =>
            HasValue ? Option<TResult>.Some(map(_value)) : Option<TResult>.None;

        public Option<TResult> FlatMap<TResult>(Func<T, Option<TResult>> map) =>
            HasValue ? map(_value) : Option<TResult>.None;

        public void Match(Action<T> onSome, Action onNone)
        {
            if (HasValue) onSome(_value); else onNone();
        }

        public TResult Match<TResult>(Func<T, TResult> onSome, Func<TResult> onNone) =>
            HasValue ? onSome(_value) : onNone();
            
        public override bool Equals(object? obj) => obj is Option<T> option && Equals(option);

        public bool Equals(Option<T> other) =>
            HasValue == other.HasValue &&
            (!HasValue || EqualityComparer<T>.Default.Equals(_value, other._value));

        public override int GetHashCode() => HasValue ? HashCode.Combine(HasValue, _value) : HashCode.Combine(HasValue);

        public static bool operator ==(Option<T> left, Option<T> right) => left.Equals(right);
        public static bool operator !=(Option<T> left, Option<T> right) => !(left == right);

        public override string ToString() => HasValue ? $"Some({_value})" : "None";
    }

    public static class Option
    {
        public static Option<T> Some<T>(T value) => Option<T>.Some(value);
        public static Option<T> None<T>() => Option<T>.None;
         public static Option<T> FromNullable<T>(T? value) where T : class 
            => value != null ? Some(value) : None<T>();

        public static Option<T> FromNullable<T>(T? value) where T : struct
            => value.HasValue ? Some(value.Value) : None<T>();
    }
}

// Usage:
// Option<string> FindSetting(string key) {
//     string? value = _settings.TryGetValue(key, out var v) ? v : null;
//     return Option.FromNullable(value); // For reference types
// }
//
// Option<int> ParseInt(string s) {
//    return int.TryParse(s, out int result) ? Option.Some(result) : Option.None<int>();
// }

// var settingValue = FindSetting("timeout")
//                      .Map(s => s.ToUpperInvariant())
//                      .GetValueOrDefault("DEFAULT_TIMEOUT");
//
// ParseInt("123").Match(
//    onSome: num => Console.WriteLine($"Parsed: {num}"),
//    onNone: () => Console.WriteLine("Failed to parse")
// );
```

三、开发通用模块的最佳实践
------------------------

1.  **单元测试 (Unit Testing)**：
    *   使用 XUnit, NUnit, 或 MSTest 为你的通用模块编写全面的单元测试。
    *   测试边界条件、null 输入、预期行为和异常情况。

2.  **XML 文档注释 (XML Documentation Comments)**：
    *   如上例所示，为所有 `public` 和 `protected` 成员编写。这将为用户提供 IntelliSense，并可以用于生成文档。

3.  **版本控制 (Versioning)**：
    *   使用语义化版本控制 (Semantic Versioning, SemVer: MAJOR.MINOR.PATCH)。
    *   例如：`1.0.0` -> `1.0.1` (bug fixes), `1.1.0` (new features, backward compatible), `2.0.0` (breaking changes).

4.  **分发 (Distribution)**：
    *   将你的通用模块打包成 NuGet 包，方便在不同项目中共享和版本管理。

5.  **代码审查 (Code Reviews)**：
    *   让团队成员审查你的通用代码，有助于发现问题、改进设计和确保一致性。

6.  **持续集成 (Continuous Integration)**：
    *   设置 CI/CD 管道自动构建、测试和发布你的 NuGet 包。

7.  **考虑 .NET Standard (Target .NET Standard)**：
    *   如果希望你的通用库能被更广泛的 .NET 项目（.NET Framework, .NET Core/.NET 5+ , Xamarin等）使用，请将其目标框架设置为合适的 `.NET Standard` 版本 (例如 `netstandard2.0` 或 `netstandard2.1`)。

8.  **避免过度泛化 (Avoid Over-Generalization)**:
    *   只创建那些你确实需要的、被证明有用的工具。不要为了“可能有用”而添加功能。

通过遵循这些原则和实践，并从 Guava 这样的优秀库中汲取灵感，你可以在 C# 中开发出高质量、实用且易于维护的通用功能模块。记住，许多 Guava 的功能在 .NET BCL (Base Class Library) 中已经有很好的对应实现（特别是 LINQ 和 `System.Collections.Immutable`），所以重点是填补空白或提供更符合特定需求的便利API。

## Gemini
好的，从 Google Guava 中学习并以 C# 为例来探讨如何更好地开发通用功能模块，这是一个非常棒的思路。Guava 之所以成功，在于其出色的 **API 设计**、**实用性**和**对语言核心库的有力补充**。

我们可以从 Guava 的设计哲学中提炼出几个核心原则，并结合 C# 的语言特性，将其付诸实践。

### 开发通用功能模块的核心原则

开发通用模块时，应遵循以下几个关键原则，这些原则在 Guava 的设计中体现得淋漓尽致：

1. **专注与内聚 (Focused & Cohesive)**
    
    - **原则**: 每个模块或类应该只做一件事，并且把它做好。避免创建“万能”的上帝类 (God Class)。
    - **实践**: 在 C# 中，可以利用 `static` 类来组织纯粹的工具方法。例如，Guava 的 `Strings` 类专注于字符串操作，`Preconditions` 类专注于前置条件检查。在 C# 中，你可以创建自己的 `StringUtils` 或 `Guard` 静态类。
2. **清晰与表意 (Clear & Expressive)**
    
    - **原则**: API 应该易于理解和使用，方法名和参数名应清晰地表达其意图。好的 API 本身就是文档。
    - **实践**: 使用描述性的名称。例如，Guava 的 `Splitter.on(',').trimResults().omitEmptyStrings()` 读起来就像一句自然语言。在 C# 中，可以利用**链式调用 (Fluent Interface)** 和**扩展方法 (Extension Methods)** 来实现类似的效果。
3. **不可变性优先 (Immutability First)**
    
    - **原则**: 除非必要，否则应优先设计不可变对象。不可变对象是线程安全的，易于推理和缓存。
    - **实践**: Guava 提供了丰富的不可变集合 (Immutable Collections)。在 C# 中，虽然标准库没有直接对等的实现，但你可以：
        - 使用 `IReadOnlyList<T>`, `IReadOnlyDictionary<TKey, TValue>` 等只读接口作为公共 API 的返回类型。
        - 在 C# 9.0+ 中使用 `record` 类型来轻松创建不可变对象。
        - 创建自定义的不可变类，其字段在构造后便不可更改。
4. **预防和快速失败 (Prevention & Fail-Fast)**
    
    - **原则**: 及早地发现和报告错误，而不是让错误在系统深处才暴露出来。
    - **实践**: Guava 的 `Preconditions` 类是这一原则的典范。在 C# 中，可以创建一个类似的 `Guard` 或 `Ensure` 类来统一进行参数校验。这比在每个方法内部写一堆 `if (arg == null) throw new ArgumentNullException(...)` 要清晰得多。
5. **减少样板代码 (Reduce Boilerplate Code)**
    
    - **原则**: 消除重复、冗长的代码，让开发者专注于业务逻辑。
    - **实践**: Guava 的 `Objects.toStringHelper()`、`ComparisonChain` 等都是为了简化常见任务。在 C# 中：
        - 利用 **LINQ** 处理集合操作。
        - 利用**扩展方法**为现有类型添加新功能。
        - 利用**源生成器 (Source Generators)** (较高级) 来在编译时自动生成重复代码。

---

### C# 具体实践

下面我们通过一些 C# 代码示例来展示如何应用上述原则。

#### 示例 1: 字符串操作的链式调用 (模仿 `Splitter`)

假设我们要开发一个强大的字符串分割工具，可以像 Guava 的 `Splitter` 一样链式调用。

C#

```
// 静态类作为入口，提供流畅的API
public static class StringSplitter
{
    public static Splitter On(char separator) => new Splitter(separator);
    public static Splitter On(string separator) => new Splitter(separator);
}

// 核心逻辑类，支持链式配置
public class Splitter
{
    private readonly string _separator;
    private bool _trimResults = false;
    private bool _omitEmptyStrings = false;

    // 构造函数设为 internal，强制通过 StringSplitter.On() 创建
    internal Splitter(char separator) => _separator = separator.ToString();
    internal Splitter(string separator) => _separator = separator;

    public Splitter TrimResults()
    {
        _trimResults = true;
        return this; // 返回自身以实现链式调用
    }

    public Splitter OmitEmptyStrings()
    {
        _omitEmptyStrings = true;
        return this;
    }

    public IEnumerable<string> Split(string source)
    {
        var parts = source.Split(new[] { _separator }, StringSplitOptions.None);
        IEnumerable<string> result = parts;

        if (_trimResults)
        {
            result = result.Select(s => s.Trim());
        }

        if (_omitEmptyStrings)
        {
            result = result.Where(s => !string.IsNullOrEmpty(s));
        }

        return result;
    }
}

// 使用示例
public class Demo
{
    public void Run()
    {
        var input = " apple , banana,, cherry ";
        var results = StringSplitter.On(',')
                                    .TrimResults()
                                    .OmitEmptyStrings()
                                    .Split(input);

        // results 将会是 ["apple", "banana", "cherry"]
        foreach (var item in results)
        {
            Console.WriteLine(item);
        }
    }
}
```

✨ **这个例子体现了**:

- **清晰与表意**: `StringSplitter.On(',').TrimResults().OmitEmptyStrings()` 非常直观。
- **专注与内聚**: `StringSplitter` 和 `Splitter` 类只负责字符串分割这一件事。

---

#### 示例 2: 前置条件检查 (模仿 `Preconditions`)

创建一个静态的 `Guard` 类来统一参数验证，实现快速失败。

C#

```
public static class Guard
{
    public static T NotNull<T>(T value, string paramName) where T : class
    {
        if (value is null)
        {
            throw new ArgumentNullException(paramName);
        }
        return value;
    }

    public static string NotNullOrEmpty(string value, string paramName)
    {
        NotNull(value, paramName);
        if (string.IsNullOrEmpty(value))
        {
            throw new ArgumentException("Parameter cannot be empty.", paramName);
        }
        return value;
    }

    public static void IsTrue(bool condition, string message)
    {
        if (!condition)
        {
            throw new ArgumentException(message);
        }
    }
}

// 使用示例
public class UserService
{
    private readonly string _adminRole = "Admin";

    public void PromoteUser(string username, string role)
    {
        // 使用 Guard 进行前置条件检查
        Guard.NotNullOrEmpty(username, nameof(username));
        Guard.NotNullOrEmpty(role, nameof(role));
        Guard.IsTrue(role != _adminRole, "Cannot promote user to Admin role directly.");

        // ... 业务逻辑 ...
        Console.WriteLine($"User '{username}' promoted to role '{role}'.");
    }
}
```

✨ **这个例子体现了**:

- **预防和快速失败**: 在方法执行的最初阶段就进行检查，避免无效状态。
- **减少样板代码**: `Guard.NotNullOrEmpty(...)` 比手写 `if` 判断和 `throw` 语句更简洁。

---

#### 示例 3: 扩展方法的妙用

扩展方法是 C# 中增强现有类型功能的利器，非常适合用来构建通用模块，因为它不会污染原始类的接口。

C#

```
public static class CollectionExtensions
{
    /// <summary>
    /// Checks if a collection is null or has no elements.
    /// </summary>
    public static bool IsNullOrEmpty<T>(this ICollection<T> collection)
    {
        return collection == null || collection.Count == 0;
    }

    /// <summary>
    /// Executes an action for each element of the IEnumerable.
    /// A more fluent alternative to the foreach statement.
    /// </summary>
    public static void ForEach<T>(this IEnumerable<T> source, Action<T> action)
    {
        Guard.NotNull(source, nameof(source));
        Guard.NotNull(action, nameof(action));

        foreach (var item in source)
        {
            action(item);
        }
    }
}

// 使用示例
public class DataProcessor
{
    public void Process(List<string> data)
    {
        if (data.IsNullOrEmpty()) // 使用扩展方法
        {
            Console.WriteLine("No data to process.");
            return;
        }

        data.Where(d => d.StartsWith("A"))
            .ToList()
            .ForEach(d => Console.WriteLine($"Processing item: {d}")); // 链式调用 LINQ 和自定义扩展
    }
}
```

✨ **这个例子体现了**:

- **非侵入式扩展**: 无需修改 `ICollection<T>` 或 `IEnumerable<T>` 的源代码即可为其添加功能。
- **提升代码流畅性**: `data.IsNullOrEmpty()` 和 `...ForEach(...)` 使代码更易读。

### 总结

向 Guava 学习开发 C# 通用模块，核心在于吸收其设计哲学，并利用 C# 的语言特性（静态类、扩展方法、LINQ、泛型、`record` 等）加以实现。

**关键步骤回顾**:

1. **识别痛点**: 找到那些在多个项目中反复出现的、繁琐的、易出错的代码片段（如字符串处理、集合操作、参数校验）。
2. **单一职责**: 为每个功能领域创建一个独立的静态类或一组小而专注的类。
3. **设计流畅API**: 善用方法链、扩展方法和清晰的命名，让代码读起来像自然语言。
4. **拥抱不可变性**: 优先返回只读集合，使用 `record` 定义数据传输对象。
5. **统一校验**: 创建一个 `Guard` 类来处理所有前置条件检查，实现快速失败。
6. **编写文档和测试**: 好的通用模块必须有清晰的 XML 文档注释和全面的单元测试，以确保其质量和可用性。

通过遵循这些原则和实践，你就能在 C# 中开发出像 Guava 一样健壮、优雅且备受欢迎的通用功能模块。

## Claude
Google Guava是Java生态中优秀的通用功能库，它的设计理念和模式同样适用于C#开发。以下是开发通用功能模块应遵循的核心原则和具体实践：

## 核心设计原则

**1. 单一职责原则 (SRP)** 每个模块只专注一个功能领域，保持清晰的边界。

```csharp
// 好的设计 - 专注字符串操作
public static class StringHelper
{
    public static bool IsNullOrWhiteSpace(string value) => string.IsNullOrWhiteSpace(value);
    public static string SafeSubstring(string value, int start, int length) { /* ... */ }
}

// 好的设计 - 专注集合操作  
public static class CollectionHelper
{
    public static bool IsNullOrEmpty<T>(ICollection<T> collection) { /* ... */ }
    public static IEnumerable<T> EmptyIfNull<T>(IEnumerable<T> source) { /* ... */ }
}
```

**2. 防御性编程** 对输入参数进行严格校验，提供清晰的错误信息。

```csharp
public static class Preconditions
{
    public static T CheckNotNull<T>(T reference, string parameterName = null) 
        where T : class
    {
        if (reference == null)
            throw new ArgumentNullException(parameterName ?? nameof(reference));
        return reference;
    }

    public static void CheckArgument(bool expression, string message = null)
    {
        if (!expression)
            throw new ArgumentException(message ?? "Invalid argument");
    }

    public static void CheckState(bool expression, string message = null)
    {
        if (!expression)
            throw new InvalidOperationException(message ?? "Invalid state");
    }
}
```

**3. 不可变性设计** 优先设计不可变的数据结构，提高线程安全性。

```csharp
public sealed class ImmutableRange<T> where T : IComparable<T>
{
    public T Start { get; }
    public T End { get; }
    
    private ImmutableRange(T start, T end)
    {
        Start = Preconditions.CheckNotNull(start, nameof(start));
        End = Preconditions.CheckNotNull(end, nameof(end));
        Preconditions.CheckArgument(start.CompareTo(end) <= 0, "Start must be <= End");
    }
    
    public static ImmutableRange<T> Create(T start, T end) => new ImmutableRange<T>(start, end);
    
    public bool Contains(T value) => Start.CompareTo(value) <= 0 && value.CompareTo(End) <= 0;
}
```

**4. 流式API设计** 提供链式调用，提高代码可读性。

```csharp
public static class FluentValidator<T>
{
    private readonly T _value;
    private readonly string _parameterName;
    
    private FluentValidator(T value, string parameterName)
    {
        _value = value;
        _parameterName = parameterName;
    }
    
    public static FluentValidator<T> Check(T value, string parameterName = null)
        => new FluentValidator<T>(value, parameterName);
    
    public FluentValidator<T> NotNull() where T : class
    {
        if (_value == null)
            throw new ArgumentNullException(_parameterName);
        return this;
    }
    
    public FluentValidator<T> Matches(Predicate<T> predicate, string message = null)
    {
        if (!predicate(_value))
            throw new ArgumentException(message ?? "Value does not match predicate", _parameterName);
        return this;
    }
    
    public T Value => _value;
}

// 使用示例
var validatedEmail = FluentValidator
    .Check(email, nameof(email))
    .NotNull()
    .Matches(e => e.Contains("@"), "Invalid email format")
    .Value;
```

## 具体实践模式

**1. Optional模式处理空值**

```csharp
public struct Optional<T>
{
    private readonly T _value;
    private readonly bool _hasValue;
    
    private Optional(T value)
    {
        _value = value;
        _hasValue = value != null;
    }
    
    public static Optional<T> Of(T value) => new Optional<T>(Preconditions.CheckNotNull(value));
    public static Optional<T> OfNullable(T value) => value == null ? Empty() : new Optional<T>(value);
    public static Optional<T> Empty() => default(Optional<T>);
    
    public bool IsPresent => _hasValue;
    public T Value => _hasValue ? _value : throw new InvalidOperationException("No value present");
    
    public T OrElse(T defaultValue) => _hasValue ? _value : defaultValue;
    public T OrElseGet(Func<T> supplier) => _hasValue ? _value : supplier();
    
    public Optional<TResult> Map<TResult>(Func<T, TResult> mapper)
        => _hasValue ? Optional<TResult>.OfNullable(mapper(_value)) : Optional<TResult>.Empty();
}
```

**2. 缓存工具模块**

```csharp
public class MemoryCache<TKey, TValue>
{
    private readonly ConcurrentDictionary<TKey, CacheEntry<TValue>> _cache = new();
    private readonly TimeSpan _defaultExpiration;
    
    public MemoryCache(TimeSpan defaultExpiration)
    {
        _defaultExpiration = defaultExpiration;
    }
    
    public TValue GetOrAdd(TKey key, Func<TKey, TValue> valueFactory, TimeSpan? expiration = null)
    {
        var entry = _cache.GetOrAdd(key, k => new CacheEntry<TValue>(
            valueFactory(k), 
            DateTime.UtcNow.Add(expiration ?? _defaultExpiration)));
            
        return entry.IsExpired ? RefreshEntry(key, valueFactory, expiration) : entry.Value;
    }
    
    private TValue RefreshEntry(TKey key, Func<TKey, TValue> valueFactory, TimeSpan? expiration)
    {
        var newEntry = new CacheEntry<TValue>(
            valueFactory(key), 
            DateTime.UtcNow.Add(expiration ?? _defaultExpiration));
        _cache.TryUpdate(key, newEntry, _cache[key]);
        return newEntry.Value;
    }
}

internal class CacheEntry<T>
{
    public T Value { get; }
    public DateTime ExpirationTime { get; }
    public bool IsExpired => DateTime.UtcNow > ExpirationTime;
    
    public CacheEntry(T value, DateTime expirationTime)
    {
        Value = value;
        ExpirationTime = expirationTime;
    }
}
```

**3. 函数式工具**

```csharp
public static class Functions
{
    public static Func<T, TResult> Memoize<T, TResult>(Func<T, TResult> function)
    {
        var cache = new ConcurrentDictionary<T, TResult>();
        return input => cache.GetOrAdd(input, function);
    }
    
    public static Action<T> DoNothing<T>() => _ => { };
    
    public static Func<T, T> Identity<T>() => x => x;
    
    public static Predicate<T> AlwaysTrue<T>() => _ => true;
    public static Predicate<T> AlwaysFalse<T>() => _ => false;
}
```

## 最佳实践总结

1. **API设计要直观**：方法名清晰表达意图，参数顺序符合直觉
2. **错误处理要明确**：提供具体的异常信息，避免吞噬异常
3. **性能要考虑**：避免不必要的对象创建，合理使用缓存
4. **文档要完整**：提供清晰的XML文档注释和使用示例
5. **测试要充分**：覆盖正常流程、边界条件和异常情况
6. **版本要兼容**：新版本保持向后兼容，遵循语义版本控制

通过学习Guava的设计模式，可以构建出既实用又优雅的C#通用功能模块，为项目开发提供坚实的基础设施支持。

## GPT
借助 Google Guava 的思想来开发 **C# 中的通用功能模块** 是一个非常好的实践方向。Guava 是 Google Java 项目中提供的一组核心库，强调 **可复用性、健壮性、简洁性和高性能**，很多理念在 C# 中也可以复用。

---

## 🧭 一、设计通用功能模块的核心理念

### ✅ 1. **关注点分离（Separation of Concerns）**

- 模块只做一件事，做得好。
    
- 把通用功能（如缓存、校验、集合工具、字符串处理等）和业务逻辑彻底分开。
    

### ✅ 2. **组合优于继承**

- 避免为工具类创建层级继承体系，而是通过组合、扩展方法等方式实现。
    

### ✅ 3. **函数式思维 + 可组合性**

- 尽量使用 `Func<T>`, `Action<T>`、`IEnumerable<T>` 等，让模块更通用。
    
- 避免硬编码特定逻辑。
    

### ✅ 4. **不可变性和线程安全**

- 类似 Guava 的 `ImmutableList`, 在 C# 中可用 `ImmutableList<T>`（System.Collections.Immutable）提升并发环境下的健壮性。
    

### ✅ 5. **失败优雅处理**

- 使用 `TryXXX` 模式（比如 TryParse），或返回 Result 对象封装结果与错误，提升健壮性。
    

---

## 🧱 二、Guava 中几个典型模块及 C# 实践

---

### 1. **Preconditions 预条件检查**

#### 📘 Guava 示例：

```java
Preconditions.checkNotNull(obj, "Object cannot be null");
```

#### 💡 C# 示例：

```csharp
public static class Check
{
    public static T NotNull<T>(T obj, string paramName)
    {
        if (obj == null) throw new ArgumentNullException(paramName);
        return obj;
    }
}
```

---

### 2. **Optional 可选值处理**

#### 📘 Guava 示例：

```java
Optional<String> name = Optional.of("Tom");
```

#### 💡 C# 示例（C# 本身没有 Optional，但可以自定义）：

```csharp
public readonly struct Option<T>
{
    private readonly T _value;
    public bool HasValue { get; }
    public T Value => HasValue ? _value : throw new InvalidOperationException();

    private Option(T value)
    {
        _value = value;
        HasValue = true;
    }

    public static Option<T> Some(T value) => new(value);
    public static Option<T> None() => new();
}
```

---

### 3. **Cache 缓存模块（类似 Guava CacheBuilder）**

#### 💡 C# 示例（简版内存缓存）：

```csharp
public class MemoryCache<TKey, TValue>
{
    private readonly Dictionary<TKey, (TValue Value, DateTime Expiry)> _cache = new();
    private readonly TimeSpan _expiryTime;

    public MemoryCache(TimeSpan expiryTime)
    {
        _expiryTime = expiryTime;
    }

    public TValue GetOrAdd(TKey key, Func<TValue> factory)
    {
        if (_cache.TryGetValue(key, out var entry) && entry.Expiry > DateTime.Now)
            return entry.Value;

        var value = factory();
        _cache[key] = (value, DateTime.Now.Add(_expiryTime));
        return value;
    }
}
```

---

### 4. **集合工具（类似 Guava 的 Lists、Sets 工具）**

#### 💡 C# 示例：

```csharp
public static class ListUtils
{
    public static List<T> FilterNotNull<T>(IEnumerable<T?> source) where T : class
    {
        return source.Where(x => x != null).ToList()!;
    }

    public static Dictionary<TKey, List<T>> GroupByList<T, TKey>(IEnumerable<T> source, Func<T, TKey> keySelector)
    {
        return source.GroupBy(keySelector).ToDictionary(g => g.Key, g => g.ToList());
    }
}
```

---

### 5. **字符串工具（类似 Guava 的 `Strings`, `Joiner`, `Splitter`）**

#### 💡 C# 示例：

```csharp
public static class StringUtils
{
    public static string Join<T>(string separator, IEnumerable<T> items)
    {
        return string.Join(separator, items);
    }

    public static List<string> Split(string input, string separator)
    {
        return input.Split(new[] { separator }, StringSplitOptions.RemoveEmptyEntries).ToList();
    }

    public static bool IsNullOrEmpty(string? input) => string.IsNullOrEmpty(input);
}
```

---

## 🧠 三、通用模块开发的实践建议

|原则|具体做法|
|---|---|
|✅ 单一职责|每个类只做一件事，比如 StringUtils 只负责字符串处理|
|✅ 测试驱动|每个工具类都应有完整单元测试|
|✅ API 文档|提供 XML 注释或 Markdown 使用文档|
|✅ 面向接口|公共逻辑抽象为接口，让用户更灵活替换实现|
|✅ 性能考量|避免重复计算和不必要的对象创建（如缓存）|

---

## 🧪 四、实际项目中常用通用模块类型

|模块类型|功能例子|
|---|---|
|校验模块|检查参数、格式合法性、数据范围等|
|字符串工具|拼接、分割、格式化、转义等|
|集合工具|分组、去重、求交集并集差集等|
|缓存模块|本地内存缓存、LRU 缓存等|
|时间处理模块|格式化、转换、时间段处理等|
|IO 工具|文件读写、目录操作、路径合并等|
|异常封装|自定义异常 + 错误码体系|

---

## ✅ 总结：如何用 C# 构建 Guava 风格的通用模块

1. **模块化设计**：每类功能一个独立静态类或服务接口；
    
2. **高度复用**：使用泛型、委托、扩展方法提升灵活性；
    
3. **优雅错误处理**：推荐 `TryXXX` 或返回 Result；
    
4. **清晰文档 + 单元测试**：每个模块应易于使用和测试；
    
5. **参考开源库结构**：学习 Guava、Apache Commons、MoreLinq 等库的命名和组织方式。
    

如果你有具体的模块（比如缓存、集合、字符串处理）想要用 C# 来写，我可以帮你一步步实现。需要我现在就帮你写一个模块的完整结构示例吗？