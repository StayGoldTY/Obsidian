### 3.7 Feature Envy(依恋情结)
对象技术的全部要点在于：这是一种“将数据和对数据的操作行为包装在一起”
的技术。

有一种经典气味是：函数对某个类的兴趣高过对自己所处类的兴趣。

这种孺慕之情最通常的焦点便是数据。无数次经验里，我们看到某个函数为了计算某个
值，从另一个对象那儿调用几乎半打的取值函数。

疗法显而易见：把这个函数移至另一个地点。你应该使用Move Method(142)把它移到它该去的地方。有时候函数中只有一部分受这种依恋之苦，这时候你应该使用Extract Method(110)把这一部分提炼到独立函数中，再使用Move Method(142)带它去它的梦中家园。

当然，并非所有情况都这么简单。一个函数往往会用到几个类的功能，那么它
究竟该被置于何处呢?我们的原则是：判断哪个类拥有最多被此函数使用的数据，然
后就把这个函数和那些数据摆在一起。如果先以Extract Method(110)将这个函数分
解为数个较小函数并分别置放于不同地点，上述步骤也就比较容易完成了。

有几个复杂精巧的模式破坏了这个规则。说起这个话题，GoF[Gangof Four]的
Strategy和Visitor立刻跳入我的脑海，Kent Beck的SelfDelegation[Beck]也在此列。使
用这些模式是为了对抗坏味道Divergent Change。最根本的原则是：将总是一起变化的东西放在一块儿。

数据和引用这些数据的行为总是一起变化的，但也有例外。如果例外出现，我们就搬移那些行为，保持变化只在一地发生。Srategy和Visitor使你得以轻松修改函数行为，因为它们将少量需被覆写的行为隔离开来---当然也付出了“多一层间接性”的代价。

### 3.8 Data Clumps(数据泥团)
数据项就像小孩子，喜欢成群结队地待在一块儿。你常常可以在很多地方看到相同的三四项数据：两个类中相同的字段、许多函数签名中相同的参数。

这些总是绑在一起出现的数据真应该拥有属于它们自己的对象。首先请找出这些数据以字段形式出现的地方，运用Exract Class(149)将它们提炼到一个独立对象中。然后将注
意力转移到函数签名上，运用mtroduce Parameter Object (295)或Preserve Whole
Object(288)为它减肥。这么做的直接好处是可以将很多参数列缩短，简化函数调用。

是的，不必在意Data Clumps只用上新对象的一部分字段，只要以新对象取代两个(或
更多)字段，你就值回票价了。

*一个好的评判办法是：删掉众多数据中的一项。这么做，其他数据有没有因而失去意义?如果它们不再有意义，这就是个明确信号：你应该为它们产生一个新对象。*

减少字段和参数的个数，当然可以去除一些坏味道，但更重要的是：一旦拥有
新对象，你就有机会让程序散发出一种芳香。得到新对象后，你就可以着手寻找
Feature Envy,这可以帮你指出能够移至新类中的种种程序行为。不必太久，所有的
类都将在它们的小小社会中充分发挥价值。

### 3.10 Switch Statements(switch惊悚现身)
面向对象程序的一个最明显特征就是：少用switch(或case)语句。从本质
上说，switch语句的问题在于重复。你常会发现同样的switch语句散布于不同地
点。如果要为它添加一个新的case子句，就必须找到所有switch语句并修改它们。
面向对象中的多态概念可为此带来优雅的解决办法。

大多数时候，一看到switch语句，你就应该考虑以多态来替换它。问题是多态该出现在哪儿?

switch语句常常根据类型码进行选择，你要的是“与该类型码相关的函数或类”,所以应该使用Exract Method(110)将switch语句提炼到一个独立函数中，再以Move Method(142)将它搬移到需要多态性的那个类里。此时你必须决定是否使用Replace Type Code with Subclasses (223)或Replace Type Code with State/Stra-tegy(227)。一旦这样完成继承结构之后，你就可以运用Replace Conditional withPolymorphism(255)了。

如果你只是在单一函数中有些选择事例，且并不想改动它们，那么多态就有点杀鸡用牛刀了。这种情况下Replace Parameter with Explicit Methods (285)是个不错的
选择。如果你的选择条件之一是null,可以试试Introduce Null Object (260)。

### 3.13 Speculative Generality(夸夸其谈未来性)
这个令我们十分敏感的坏味道，命名者是Brian Foote。当有人说“噢，我想我
们总有一天需要做这事”,并因而企图以各式各样的钩子和特殊情况来处理一些非必
要的事情，这种坏味道就出现了。

那么做的结果往往造成系统更难理解和维护。如果所有装置都会被用到，那就值得那么做；如果用不到，就不值得。用不上的装置只会挡你的路，所以，把它搬开吧。

如果你的某个抽象类其实没有太大作用，请运用Collapse Hierarchy(344)。不必
要的委托可运用Inline Class(154)除掉。如果函数的某些参数未被用上，可对它实施
Remove Parameter(277)。如果函数名称带有多余的抽象意味，应该对它实施Rename
Method (273),让它现实一些。

如果函数或类的唯一用户是测试用例，这就飘出了坏味道Speculative Generality。如果你发现这样的函数或类，请把它们连同其测试用例一并删掉。但如果它们的用途是帮助测试用例检测正当功能，当然必须刀下留人。
