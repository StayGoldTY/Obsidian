

**1、单一职责原则（Single Responsibilities Principle）【SRP】**

> （1）SRP(Single ResponsibilitiesPrinciple)的定义：就一个类而言，应该仅有一个引起它变化的原因。==简而言之，就是功能要单一==。
> 
> （2）如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其它职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏。(敏捷软件开发)
> 
> （3）**软件设计真正要做的许多内容，就是发现职责并把那些职责相互分离**。
> 
> ---
> 
> 小结：==单一职责原则（SRP）可以看做是低耦合、高内聚在面向对象原则上的引申==，将职责定义为引起变化的原因，以提高内聚性来减少引起变化的原因。责任过多，引起它变化的原因就越多，这样就会导致职责依赖，大大损伤其内聚性和耦合度。

**2、开闭原则（Open Close Principle）【OCP】**

开闭原则的意思是：==对扩展开放，对修改关闭==。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。

> （1）OCP(Open-Close  
> Principle)的定义：就是说软件实体(类，方法等等)应该可以扩展（扩展可以理解为增加），但是不能在原来的方法或者类上修改，也可以这样说，对增加代码开放，对修改代码关闭。  
> （2）OCP的两个特征： 对于扩展（增加）是开放的，因为它不影响原来的，这是新增加的。对于修改是封闭的，如果总是修改，逻辑会越来越复杂。
> 
> ---
> 
> 小结：开放封闭原则（OCP）是面向对象设计的核心思想。遵循这个原则可以为我们面向对象的设计带来巨大的好处：可维护（维护成本小，做管理简单，影响最小）、可扩展（有新需求，增加就好）、可复用（不耦合，可以使用以前代码）、灵活性好（维护方便、简单）。开发人员应该仅对程序中出现频繁变化的那些部分做出抽象，但是不能过激，对应用程序中的每个部分都刻意地进行抽象同样也不是一个好主意。拒绝不成熟的抽象和抽象本身一样重要。

**3、里氏代换原则（Liskov Substitution Principle）【LSP】**

里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，==任何基类可以出现的地方，子类一定可以出现==。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。**实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现**，所以里氏代换原则是对实现抽象化的具体步骤的规范。

> （1）LSP(Liskov SubstitutionPrinciple)的定义：子类型必须能够替换掉它们的父类型。更直白的说，LSP是实现面向接口编程的基础。
> 
> ---
> 
> 小结：任何基类可以出现的地方，子类一定可以出现，所以我们可以实现面向接口编程。  
> LSP是继承复用的基石，只有当子类可以替换掉基类，软件的功能不受到影响时，基类才能真正被复用，而子类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。

**4、依赖倒转原则（Dependence Inversion Principle）【DIP】**

这个原则是开闭原则的基础，具体内容：==针对接口编程，依赖于抽象而不依赖于具体==。

> （1）DIP(Dependence InversionPrinciple)的定义：抽象不应该依赖细节，细节应该依赖于抽象。简单说就是，我们要针对接口编程，而不要针对实现编程。
> 
> （2）高层模块不应该依赖低层模块，两个都应该依赖抽象，因为抽象是稳定的。抽象不应该依赖具体（细节），具体（细节）应该依赖抽象。
> 
> ---
> 
> 小结：依赖倒置原则其实可以说是面向对象设计的标志，如果在我们编码的时候考虑的是面向接口编程，而不是简单的功能实现，体现了抽象的稳定性，只有这样才符合面向对象的设计。

**5、接口隔离原则（Interface Segregation Principle）【ISP】**

这个原则的意思是：==使用多个隔离的接口，比使用单个接口要好==。它还有另外一个意思是：==降低类之间的耦合度==。由此可见，其实设计模式就是从大型软件==架构出发、便于升级和维护==的软件设计思想，它==强调降低依赖，降低耦合==。

> （1）接口隔离原则（Interface Segregation Principle,ISP）指的是使用多个专门的接口比使用单一的总接口要好。也就是说不要让一个单一的接口承担过多的职责，而应把每个职责分离到多个专门的接口中，进行接口分离。过于臃肿的接口是对接口的一种污染。
> 
> （2）使用多个专门的接口比使用单一的总接口要好。
> 
> （3）一个类对另外一个类的依赖性应当是建立在最小的接口上的。
> 
> （4）一个接口代表一个角色，不应当将不同的角色都交给一个接口。没有关系的接口合并在一起，形成一个臃肿的大接口，这是对角色和接口的污染。
> 
> （5）“不应该强迫客户依赖于它们不用的方法。接口属于客户，不属于它所在的类层次结构。”这个说得很明白了，再通俗点说，不要强迫客户使用它们不用的方法，如果强迫用户使用它们不使用的方法，那么这些客户就会面临由于这些不使用的方法的改变所带来的改变。
> 
> ---
> 
> 小结：接口隔离原则（ISP）告诉我们，在做接口设计的时候，要尽量设计的接口功能单一，功能单一，使它变化的因素就少，这样就更稳定，其实这体现了高内聚，低耦合的原则，这样做也避免接口的污染。

**6、迪米特法则，又称最少知道原则（Demeter Principle）**

最少知道原则是指：==一个实体应当尽量少地与其他实体之间发生相互作用【！！！】，使得系统功能模块相对独立==。

**7、合成复用原则（Composite Reuse Principle）【CRP】**

合成复用原则是指：==尽量使用合成/聚合的方式，而不是使用继承【！！！】==。

> （1）组合复用原则（Composite Reuse Principle, CRP）就是在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分。新对象通过向这些对象的委派达到复用已用功能的目的。简单地说，就是要尽量使用合成/聚合，尽量不要使用继承。
> 
> （2）要使用好组合复用原则，首先需要区分”Has—A”和“Is—A”的关系。“Is—A”是指一个类是另一个类的“一种”，是属于的关系，而“Has—A”则不同，它表示某一个角色具有某一项责任。导致错误的使用继承而不是聚合的常见的原因是错误地把“Has—A”当成“Is—A”.例如：鸡是动物，这就是“Is-A”的表现，某人有一个手枪，People类型里面包含一个Gun类型，这就是“Has-A”的表现。
> 
> ---
> 
> 小结：组合/聚合复用原则可以使系统更加灵活，类与类之间的耦合度降低，一个类的变化对其他类造成的影响相对较少，因此一般首选使用组合/聚合来实现复用；其次才考虑继承，在使用继承时，需要严格遵循里氏替换原则，有效使用继承会有助于对问题的理解，降低复杂度，而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度，因此需要慎重使用继承复用。