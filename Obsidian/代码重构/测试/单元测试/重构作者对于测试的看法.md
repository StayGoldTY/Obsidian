### 添加更多测试

现在，我们应该继续添加更多测试。我遵循的风格是：观察class该做的所有事情，然后针对任何一项功能的任何一种可能失败情况，进行测试。这不同于某些程序 员提倡的「测试所有public函数」。记住，测试应该是一种风险驱动（risk driven）行为，测试的目的是希望找出现在或未来可能出现的错误。所以我不会去测试那些仅仅读或写一个值域的访问函数（accessors），因为它们太简单了，不大可能出错。

这一点很重要，因为如果你撰写过多测试，结果往往测试量反而不够。我常常阅读许多测试相关书籍，我的反应是：测试需要做那么多工作，令我退避三舍。这种书起不了预期效果，因为它让你觉得测试有大量工作要做。事实上，**哪怕只做一点点测试，你也能从中受益**。测试的要诀是：**测试你最担心出错的部分。这样你就能从测试工作中得到最大利益。**


TIP：编写未臻完善的测试并实际运行，好过对完美测试的无尽等待。

什么时候应该停下来？我相信这样的话你听过很多次：「任何测试都不能证明一个程序没有臭虫」。这是真的，但这不会影响「测试可以提高编程速度」。

我曾经见过数种测试规则建议，其目的都是保证你能够测试所有情况的一切组合。这些东西值得一看，但是别让它们影响你。当测试数量达到一定程度之后，测试效益就会呈现递减态势，而非持续递增；如果试图编写太多测试，你也可能因为工作量太大而气馁，最后什么都写不成。

你应该把测试集中在可能出错的地方。观察代码，看哪儿变得复杂；观察函数，思考哪些地方可能出错。是的，你的测试不可能找出所有臭虫，但一旦进行重构，你可以更好地理解整个程序，从而找到更多臭虫。虽然我总是以单独一个测试套件开始重构，但前进途中我总会加入更多测试。

TIP：不要因为「测试无法捕捉所有臭虫」，就不撰写测试代码，因为测试的确可以描捉到大多数臭虫。

对象技术有个微妙处：继承（inheritance）和多态（polymorphism ）会让测试变得比较困难，因为将有许多种组合需要测试。如果你有3个彼此合作的abstract classes ，每个abstract classes 有三个subclasses，那么你总共拥有九个可供选择的classes，和27种组合。我并不总是试着测试所有可能组合，但我会尽量测试每一个classes，这可以大大减少各种组合所造成的风险。如果这些classes之间彼此有合理的独立性，我很可能不会尝试所有组合。是的，我总有可能遗漏些什么，但我觉得「花合理时间抓出大多数臭虫」要好过「穷尽一生抓出所有臭虫」。

测试代码和产品代码（待测代码）之间有个区别：你可以放心地拷贝、编辑测试代 码。处理多种组合情况以及面对多个可供选择的classes时，我经常这么做。首先测试「标准发薪过程」，然后加上「资历」和「年底前停薪」条件，然后又去掉这两个条件……。只要在合理的测试装备（test fixture）上准备好一些简单的替换样本，我就能够很快生成不同的test case (测试用例），然后就可以利用重构手法分解出真正常用的各种东西。

我希望这一章能够让你对于「撰写测试代码」有一些感觉。关于这个主题，我可以说上很多，但如果那么做，就有点喧宾夺主了。总而言之，请构筑一个良好的臭虫检测器（bug detector）并经常运行它；这对任何开发工作都是一个美好的工具，并且是重构的前提。