![[Pasted image 20240415170027.png]]
上面的这个地方如果后续内存泄漏优化无用的话，可以尝试

***
后续排查发现就是因为在dotnetty里面使用了task.run导致了执行顺序不能保证，会出现不可预测的内存泄露情况，但是使用await 相关的操作就不会。
**问题就是用await的话，有下面两个坏结果

1.因为代码里面大量用了.Result这种写法，导致可能出现死锁的情况

2.直接用await的方式测试发现性能下降很多，经常发生阻塞

[[2024-04-29]]
终于在昨天晚上十点多的时候想到，上面的两个问题其实主要是业务代码里面的问题，我们不必要纠结dotnetty里面的处理方式，只要保证dotnetty里面全部都是await的形式执行即可。
至于上面的说的两个问题可以通过把业务代码的执行改成await  Task.Run的执行方式就能避免
改动如下：
![[Pasted image 20240429160130.png]]
经过大量测试  65560的泄露问题解决了，还有一些其他的泄露，不过这个都是小问题了，基本上问题不大了

**问：.net core中 Task.Run执行 和 await Task.Run执行有什么区别能详细跟我举例说明一下吗
`.NET Core` 中 `Task.Run` 和 `await Task.Run` 的区别主要体现在它们如何处理异步操作的方式上。

**不使用 await**

当使用 `Task.Run` 而不使用 `await` 时,它会在线程池中启动一个新的后台线程来执行指定的操作。主线程会立即返回,而不会等待操作完成。这种方式适用于执行一些 CPU 密集型的操作,可以充分利用多核 CPU 的优势,提高整体吞吐量。但需要注意的是,如果在主线程上还有其他操作需要执行,它可能会在后台线程完成之前就结束了,导致后台线程的执行结果无法得到处理。

**使用 await**

当使用 `await Task.Run` 时,它会异步等待操作完成。主线程在遇到 `await` 关键字时会暂时把控制权交给运行时,转而去执行其他工作,直到后台线程操作完成并获得结果后,主线程会恢复执行后面的代码。这种方式特别适用于执行一些IO密集型的操作,比如网络请求或访问数据库等,可以避免线程被阻塞而无法执行其他工作。

下面是一个简单的示例,展示了它们的区别:

```csharp
using System;
using System.Threading;
using System.Threading.Tasks;

class Program
{
    static void Main()
    {
        // 不使用 await
        Task task1 = Task.Run(() =>
        {
            Thread.Sleep(3000); // 模拟一个长时间运行的操作
            Console.WriteLine("Task1 completed");
        });

        Console.WriteLine("Main thread continues...");
        // 主线程在后台线程完成之前就结束了,导致 Task1 的结果无法被处理

        // 使用 await
        Task task2 = Task.Run(async () =>
        {
            await Task.Delay(3000); // 模拟一个长时间运行的操作
            Console.WriteLine("Task2 completed");
        });

        Console.WriteLine("Waiting for Task2...");
        task2.Wait(); // 等待 Task2 完成
        Console.WriteLine("Task2 completed and processed");
    }
}
```

在上面的例子中:

- 对于 `task1`,它通过 `Task.Run` 在线程池中启动了一个新线程,模拟了一个长时间运行的操作。但由于主线程没有等待它完成就结束了,所以 `Task1 completed` 这行代码没有机会被执行。
- 对于 `task2`,它也是通过 `Task.Run` 启动了一个新线程,但在主线程中使用了 `await` 和 `.Wait()` 来等待它完成。因此,`Task2 completed` 这行代码得以执行,并且主线程能够处理它的结果。

总的来说,`Task.Run` 适用于需要并行执行 CPU 密集型操作的场景,而 `await Task.Run` 则更适合用于异步执行 IO 密集型操作,可以避免线程被阻塞,充分利用异步编程模型的优势。选择使用哪种方式,需要根据具体的应用场景来权衡。


**继续问：也就是说 await Task.Run 和普通的 await 其他操作都是类似的效果，都是会等待后面的执行完成再执行其他内容，用task.run并不会改变这点，只是说是单独开一个线程去执行，就这一个差别是吧

是的,您总结得非常好。`await Task.Run`和`await`其他异步操作的效果是类似的,都会让主线程暂时切换出去执行其他工作,等待异步操作完成后再恢复执行后续代码。

唯一的区别在于,`Task.Run`会明确在线程池中启动一个新的工作线程来执行指定的操作。而`await`其他异步操作时,则由运行时根据具体情况选择在已有线程上执行或者创建新线程执行。

所以`await Task.Run`确保了指定的操作一定在一个新的工作线程上执行,而不是复用当前线程。这对于一些CPU密集型的长时间运行的操作很有帮助,可以避免阻塞住主线程或其他关键线程。

但对于大多数偏向I/O操作的异步代码,您可以直接使用`await`配合相应的异步API,而不一定非要用`Task.Run`包装,这样可以让运行时自行决策线程的调度,更加高效。

因此,`Task.Run`为您提供了在必要时将操作强制在新线程中执行的能力,但在其他大多数情况下,直接使用`await`即可实现异步等待的效果。两者的异同之处正如您所总结的那样。
***
后记
为了排查内存泄露的问题，前前后后经历了两个多月，从过年来到昨天晚上才完全解决，期间尝试过各种方法前面主要解决
* 数据库的泄露问题
* 用了redis订阅发布导致的泄露
**上面的两个基本上解决了60%以上的泄露问题

最后就是这个问题，用时接近两个月，期间忽视了老婆和孩子，真的很惭愧。
自己还是太愚钝了，用尽了各种方法，查找了各种资料才勉强解决
这样基本上解决了90%的泄露问题，后面其他小的泄露问题遇到再解决问题也不大了。

当然解决问题其实只是很小的一步，我在这个过程里面学会使用了各种分析内存泄露的工具和方法，真的收益良多。还尝试各种去阅读dotnetty和netty的源码，感觉自己和他们的差距真的很大，需要进步的地方太多太多了。这辈子肯定学不完，唯一想得是朝着正确的方向走就可以了。