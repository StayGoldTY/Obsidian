在实际项目开发中，确实经常会听到类似“方法不超过 15 行、类不能太大”等建议。这些“行数限制”最初都是为了**降低阅读和理解复杂度**，从而保证代码易读、易维护。但如果把这些建议生硬地理解为“越短越好”，则很容易陷入“过度拆分、浅模块化”的陷阱，反而让上层调用者需要拼装过多的小函数或类，导致**整体认知负担**依旧很高。

换言之：

- **行数限制**更多只是种“提示”或“风格建议”，让我们时刻警惕一个函数或一个类是否“承担了太多职责、导致难以理解”。
- 真正的**本质**仍然是：要让代码**易于理解、易于维护**，而不一定要盲目地拆分到只有几行代码的函数。

下面提供一些在编程实践中可以提高能力、平衡这两方面需求的思路。

---

## 1. 清晰的模块边界，先关注“抽象的深度”

当我们要设计某个功能时，首先要思考**抽象是否合理**、**模块接口是否深**，而不是先从“行数多少”这种表面指标入手。一个合适的深模块能让调用者“一次调用搞定一件事”，内部怎么实现对外并不重要。

- 如果一个方法虽然行数较多，但它对外暴露的是一个**高价值、完成独立任务**的接口（如“支付处理”这种核心业务流程），并且**对上层大幅简化复杂度**，那么它即使有几十行甚至上百行，也有它存在的价值。
- 如果一个方法只有几行，但本质上只做了些“零碎”的工作，导致调用方需要了解过多流程细节，那么这种方法看似短小，实则**没有有效地减少复杂度**，甚至增大了认知负担。

因此，与其单纯关心“代码行数”，不如关注以下问题：

1. 模块/类是否**对外暴露**了一个**完整、封装良好的功能**？
2. 模块/类内部的实现对上层来说是不是**基本不用关心**？
3. 是否可以**在接口层面**就让使用者感到逻辑清晰、简单易用？

如果上述问题都能肯定，那么函数体或类体稍微大一些也无可厚非。

---

## 2. 合理的“小函数”与“深模块”并不冲突

“小函数”并不是指把所有逻辑都强行拆成碎片，而是在以下场景时，可以考虑拆分：

1. **代码块语义独立**：当某段逻辑在语义上可以独立出来成为单独一段，并具有一个明确名字（函数名）描述其所做的事情时，拆出去也能让主流程更清晰。
2. **减少重复**：如果某段逻辑在多个地方复用，提炼成一个小函数是自然的选择。
3. **简化主流程阅读**：即使只用一次，如果这段逻辑过于庞大，抽取为单独函数能让主流程的可读性更高，也是一种可行的做法。

需要注意的是：拆分小函数时，**保持高内聚**也很重要。拆分出来的小函数应该“自足”，不依赖过多外部上下文；否则很容易导致调用者需要在多处传递大堆的上下文信息，反而破坏可读性。

---

## 3. 命名、注释与意图表达

减少认知负担的关键之一在于让代码**“好读”**。以下是几个相关建议：

1. **命名**：好的命名会暗示这个函数或类做什么，也会暗示为什么要这么做。与业务逻辑吻合的命名有助于降低阅读代码时的心智负担。
2. **注释**：注释不应只是“翻译”代码逻辑，更应该阐述**为什么做**以及一些**关键业务决策点**。当别人或自己隔一段时间再回来看时，这些注释能帮助快速回忆或理解。
3. **函数/类的职责说明**：在适当位置（例如文件头或类注释）说明这个模块提供的核心功能、“为何需要它”，对新阅读者非常友好。

---

## 4. 领域驱动设计（DDD）与业务划分

在大型系统中，如果能借助**领域驱动设计（DDD）**的思路来划分问题域，往往能更好地达到“深模块”的效果：

1. 将系统划分为多个业务领域（Bounded Context）；
2. 每个领域内部设计相对独立的一组模块；
3. 不同领域之间只通过约定好的接口（比如应用服务或领域服务）进行通信。

这样做的好处是：**每个模块只处理自己领域内的业务逻辑**，对外暴露较少但“深度”足够的 API 或方法，为上层调用者提供一个**简洁完备**的功能集合。

---

## 5. 合理的测试覆盖

在实践中，模块内部逻辑越多、行数越多，开发者就越担心“出bug或难维护”。但如果**单元测试**、**集成测试**够完善，那么对业务逻辑中的变化也更有信心。

- 对“深模块”而言，只要**对外提供的接口稳定**并且有足够的自动化测试覆盖，就不会轻易被外部的变化破坏。
- 测试也可以帮助你在设计阶段反思：这个模块的接口是否清晰、易于测试；测试写着写着就发现，这个模块是不是过于复杂、需要拆分。

---

## 6. 多写、多看、多反思

写代码本身是一种技能，而提高技能的过程往往需要**多写、多看**。

1. **多看优秀项目或开源库**：看看别人是怎么设计模块、命名、抽象的。不要局限在行数多少，而是看看那些“深度封装”的接口，怎么让使用者“有的放矢”。
2. **多尝试、迭代**：写完后回过头来审视——“如果我不是写这段代码的人，我能快速理解它吗？” 如果感到不清晰，就问自己“哪里不清晰”、“为什么不清晰”，并尝试改进。
3. **团队 Code Review**：在团队里积极参与 Code Review，倾听不同同事的意见，看看别人如何看待“深”与“浅”、拆分与合并。

---

## 总结

- **方法行数限制/类大小**是一种提示性规则，帮助我们警惕“方法/类过于臃肿”。但也不要盲目地把一切都拆得“只剩几行”而忽略了抽象和封装的质量。
- **深模块**强调的是“高内聚、对外隐藏复杂度”，在设计层面能够为上层调用者降低认知负担，这才是真正意义上的**减少复杂度**。
- 要想写出既“模块深、接口简单”又“可读、易维护”的代码，需要从**合理的模块划分、清晰的命名和接口**、以及**充分的测试**等多方面持续练习和总结。

实战中保持**抽象深度**与**代码可读性**之间的平衡，并与团队协作在 Code Review 中吸收经验教训，才是提升编程能力、编写低认知负担代码的关键。